<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Cairo Core Library Docs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cairo Core Library Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="what-is-the-cairo-core-library"><a class="header" href="#what-is-the-cairo-core-library">What is the Cairo core library?</a></h2>
<p>The Cairo core library provides the foundational building blocks for writing provable programs in Cairo. It offers essential utilities, data structures, mathematical functions, cryptographic tools, and system interactions making it suitable for both onchain and offchain development Whether you are working on Starknet smart contracts, cryptographic applications, or general-purpose Cairo programs, the core library provides the fundamental tools needed.</p>
<p>The core library is included in Cairo by default, meaning its features are available by simply importing specific modules into your program as follows:</p>
<pre><code class="language-rust">use core::array::Array;

fn main() {
    let mut arr = Array::new();
    arr.append(42);
}</code></pre>
<h2 id="how-to-use-this-documentation"><a class="header" href="#how-to-use-this-documentation">How to use this documentation?</a></h2>
<p>This documentation serves as a comprehensive reference for all components of the Cairo Core Library. It organizes functionality into modules, constants, functions, types, and traits, allowing developers to explore and understand available features efficiently. It is auto-generated from the core library's codebase using <a href="https://docs.swmansion.com/scarb/docs/extensions/documentation-generation.html">Scarb</a>, so if you find a bug, have a feature request, or want to improve the documentation, simply report an issue or submit a pull request on either <a href="https://github.com/starkware-libs/cairo">Cairo's</a> or <a href="https://github.com/software-mansion/scarb">Scarb's</a> GitHub repositories.</p>
<p>If you already know what you are looking for, the fastest way to find it is to use the search bar at the top of the page. Otherwise, you can take <a href="intro.html#a-quick-tour-of-the-documentation">a quick tour of the documentation</a> and start clicking on anything the seems interesting. If this is your first time, we recommend starting with browsing the library's modules and experimenting with their functionality in your Cairo programs.</p>
<p>Happy coding! ð“…ƒ</p>
<h2 id="a-quick-tour-of-the-documentation"><a class="header" href="#a-quick-tour-of-the-documentation">A quick tour of the documentation</a></h2>
<p>This documentation is structured into the following sections:</p>
<ul>
<li>
<p><a href="./modules.html">Modules</a> â€“ The main building blocks of the library
This section includes all standard modules, each serving a distinct purpose:</p>
<ul>
<li>
<p>Core Utilities:</p>
<ul>
<li><code>core</code> â€“ The base module with essential utilities</li>
<li><code>traits</code> â€“ Common behavior definitions used across multiple types</li>
<li><code>boolean</code> â€“ Boolean logic operations</li>
<li><code>array</code> â€“ Dynamic data structures for storing and managing sequences of values</li>
<li><code>dict</code> â€“ Key-value storage structures</li>
<li><code>option</code> â€“ Represents optional values</li>
<li><code>result</code> â€“ Used for error handling</li>
</ul>
</li>
<li>
<p>Numerical and Mathematical Modules:</p>
<ul>
<li><code>integer</code> â€“ Fixed-size integer operations (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, etc.)</li>
<li><code>math</code> â€“ Core mathematical functions</li>
<li><code>ops</code> â€“ Arithmetic and logical operators</li>
<li><code>num</code> â€“ Numeric utilities and traits</li>
<li><code>cmp</code> â€“ Comparisons and ordering</li>
</ul>
</li>
<li>
<p>Cryptography and Hashing:</p>
<ul>
<li><code>hash</code> â€“ Generic hash utilities.</li>
<li><code>poseidon</code>, <code>pedersen</code>, <code>keccak</code>, <code>sha256</code> â€“ Cryptographic hash functions</li>
<li><code>ecdsa</code> â€“ Signature verification and elliptic curve cryptography</li>
</ul>
</li>
<li>
<p>Starknet-Specific Modules:</p>
<ul>
<li><code>starknet</code> â€“ Essential utilities for writing smart contracts</li>
<li><code>syscalls</code> â€“ Low-level Starknet system interactions</li>
<li><code>storage</code> â€“ On-chain storage management</li>
<li><code>event</code> â€“ Emitting events for contract execution tracking</li>
<li><code>contract_address</code> â€“ Starknet contract address utilities</li>
<li><code>account</code> â€“ Account contract functionality</li>
</ul>
</li>
<li>
<p>Other Utilities:</p>
<ul>
<li><code>debug</code> â€“ Debugging tools</li>
<li><code>fmt</code> â€“ String formatting utilities</li>
<li><code>serde</code> â€“ Serialization and deserialization</li>
<li><code>metaprogramming</code> â€“ Advanced compile-time utilities</li>
<li><code>zeroable</code> â€“ Zero-initialized types</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Constants â€“ Predefined values for cryptographic and mathematical operations, , such as:</p>
<ul>
<li><code>stark_curve::ALPHA, BETA, ORDER</code> â€“ Constants for Stark curve operations</li>
<li><code>byte_array::BYTE_ARRAY_MAGIC</code> â€“ Special values used in byte array manipulation</li>
</ul>
</li>
<li>
<p>Free Functions â€“ Globally accessible functions that donâ€™t belong to a specific type, such as:</p>
<ul>
<li><code>panic_with_felt252</code> â€“ Triggers a panic with a given value</li>
<li><code>circuit_add</code>, <code>circuit_sub</code>, <code>circuit_mul</code> â€“ Circuit-based arithmetic functions</li>
<li><code>keccak_syscall</code>, <code>sha256_process_block_syscall</code> â€“ Cryptographic hashing functions</li>
</ul>
</li>
<li>
<p>Structs â€“ Data structures used throughout Cairo programs, such as:</p>
<ul>
<li><code>Span&lt;T&gt;</code> â€“ A lightweight view over a contiguous memory block</li>
<li><code>Range&lt;T&gt;</code> â€“ Represents a range of values</li>
<li><code>BlockInfo</code>, <code>TxInfo</code>, <code>ExecutionInfo</code> â€“ Used for retrieving Starknet execution details</li>
<li><code>EventEmitter</code> â€“ Helps in emitting events from contracts</li>
</ul>
</li>
<li>
<p>Enums â€“ Enumerations for handling multiple possible values, such as:</p>
<ul>
<li><code>Option&lt;T&gt;</code> â€“ Represents either <code>Some(value)</code> or None</li>
<li><code>Result&lt;T, E&gt;</code> â€“ Represents either <code>Ok(value)</code> or <code>Err(error)</code></li>
<li><code>PanicResult</code> â€“ Handles different types of panics in execution.</li>
</ul>
</li>
<li>
<p>Type Aliases â€“ Shorthand for commonly used types, such as:</p>
<ul>
<li><code>usize</code> â€“ Represents an unsigned integer type used for indexing</li>
<li><code>SyscallResult&lt;T&gt;</code> â€“ A standardized way of handling syscall return values</li>
<li><code>NonZeroEcPoint</code> â€“ Ensures that an elliptic curve point is non-zero</li>
</ul>
</li>
<li>
<p>Traits â€“ Shared behavior implementations for different types, such as:</p>
<ul>
<li><code>Copy</code>, <code>Drop</code> â€“ Memory management traits.</li>
<li><code>PartialEq</code>, <code>PartialOrd</code> â€“ Used for comparisons</li>
<li><code>Iterator</code>, <code>IntoIterator</code> â€“ Traits for iterating over collections</li>
<li><code>Serialize</code>, <code>Deserialize</code> â€“ Serialization and deserialization behaviors</li>
</ul>
</li>
<li>
<p>Impls â€“ Concrete implementations of traits for various types, such as:</p>
<ul>
<li><code>CircuitElementDrop</code>, <code>CircuitElementCopy</code> â€“ Implementations for circuit computations</li>
<li><code>SpanIndex</code> â€“ Allows indexing into <code>Span&lt;T&gt;</code></li>
<li><code>PedersenImpl</code>, <code>PoseidonImpl</code> â€“ Implementations for cryptographic hashing</li>
</ul>
</li>
<li>
<p>Extern Types â€“ Special types defined outside of Cairo but used within the language.</p>
<ul>
<li><code>RangeCheck</code> â€“ A type for enforcing range constraints in computations</li>
<li><code>SegmentArena</code> â€“ Handles Cairo memory segment allocation</li>
<li><code>EcPoint</code>, <code>EcState</code> â€“ Represent elliptic curve points and their state</li>
</ul>
</li>
<li>
<p>Extern Functions â€“ Functions linked from external environments.</p>
<ul>
<li><code>felt252_div</code> â€“ Division operation for <code>felt252</code></li>
<li><code>blake2s_compress</code>, <code>blake2s_finalize</code> â€“ Blake2s hash operations</li>
<li><code>storage_read_syscall</code>, <code>storage_write_syscall</code> â€“ Direct Starknet storage interactions</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<ul>
<li>
<p><a href="./core.html">core</a></p>
</li>
<li>
<p><a href="./core-traits.html">traits</a></p>
</li>
<li>
<p><a href="./core-boolean.html">boolean</a></p>
</li>
<li>
<p><a href="./core-circuit.html">circuit</a></p>
</li>
<li>
<p><a href="./core-felt_252.html">felt_252</a></p>
</li>
<li>
<p><a href="./core-box.html">box</a></p>
</li>
<li>
<p><a href="./core-nullable.html">nullable</a></p>
</li>
<li>
<p><a href="./core-array.html">array</a></p>
</li>
<li>
<p><a href="./core-dict.html">dict</a></p>
</li>
<li>
<p><a href="./core-result.html">result</a></p>
</li>
<li>
<p><a href="./core-option.html">option</a></p>
</li>
<li>
<p><a href="./core-clone.html">clone</a></p>
</li>
<li>
<p><a href="./core-ec.html">ec</a></p>
</li>
<li>
<p><a href="./core-ecdsa.html">ecdsa</a></p>
</li>
<li>
<p><a href="./core-integer.html">integer</a></p>
</li>
<li>
<p><a href="./core-math.html">math</a></p>
</li>
<li>
<p><a href="./core-num.html">num</a></p>
</li>
<li>
<p><a href="./core-ops.html">ops</a></p>
</li>
<li>
<p><a href="./core-cmp.html">cmp</a></p>
</li>
<li>
<p><a href="./core-gas.html">gas</a></p>
</li>
<li>
<p><a href="./core-panics.html">panics</a></p>
</li>
<li>
<p><a href="./core-serde.html">serde</a></p>
</li>
<li>
<p><a href="./core-hash.html">hash</a></p>
</li>
<li>
<p><a href="./core-keccak.html">keccak</a></p>
</li>
<li>
<p><a href="./core-sha256.html">sha256</a></p>
</li>
<li>
<p><a href="./core-pedersen.html">pedersen</a></p>
</li>
<li>
<p><a href="./core-poseidon.html">poseidon</a></p>
</li>
<li>
<p><a href="./core-debug.html">debug</a></p>
</li>
<li>
<p><a href="./core-fmt.html">fmt</a></p>
</li>
<li>
<p><a href="./core-starknet.html">starknet</a></p>
</li>
<li>
<p><a href="./core-internal.html">internal</a></p>
</li>
<li>
<p><a href="./core-zeroable.html">zeroable</a></p>
</li>
<li>
<p><a href="./core-bytes_31.html">bytes_31</a></p>
</li>
<li>
<p><a href="./core-byte_array.html">byte_array</a></p>
</li>
<li>
<p><a href="./core-string.html">string</a></p>
</li>
<li>
<p><a href="./core-to_byte_array.html">to_byte_array</a></p>
</li>
<li>
<p><a href="./core-testing.html">testing</a></p>
</li>
<li>
<p><a href="./core-metaprogramming.html">metaprogramming</a></p>
</li>
<li>
<p><a href="./core-prelude.html">prelude</a></p>
</li>
<li>
<p><a href="./core-iter.html">iter</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve.html">stark_curve</a></p>
</li>
<li>
<p><a href="./core-math-one_based.html">one_based</a></p>
</li>
<li>
<p><a href="./core-num-traits.html">num::traits</a></p>
</li>
<li>
<p><a href="./core-num-traits-zero.html">zero</a></p>
</li>
<li>
<p><a href="./core-num-traits-one.html">one</a></p>
</li>
<li>
<p><a href="./core-num-traits-bit_size.html">bit_size</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops.html">num::traits::ops</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing.html">overflowing</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping.html">wrapping</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked.html">checked</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating.html">saturating</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-pow.html">pow</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-sqrt.html">sqrt</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widemul.html">widemul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widesquare.html">widesquare</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-overflow_based.html">num::traits::ops::wrapping::overflow_based</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-overflow_based.html">num::traits::ops::checked::overflow_based</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-overflow_based.html">num::traits::ops::saturating::overflow_based</a></p>
</li>
<li>
<p><a href="./core-ops-index.html">index</a></p>
</li>
<li>
<p><a href="./core-serde-into_felt252_based.html">serde::into_felt252_based</a></p>
</li>
<li>
<p><a href="./core-hash-into_felt252_based.html">hash::into_felt252_based</a></p>
</li>
<li>
<p><a href="./core-fmt-into_felt252_based.html">fmt::into_felt252_based</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access.html">storage_access</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls.html">syscalls</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait.html">secp256_trait</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256k1.html">secp256k1</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256r1.html">secp256r1</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address.html">contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address.html">eth_address</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature.html">eth_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash.html">class_hash</a></p>
</li>
<li>
<p><a href="./core-starknet-event.html">event</a></p>
</li>
<li>
<p><a href="./core-starknet-account.html">account</a></p>
</li>
<li>
<p><a href="./core-starknet-storage.html">storage</a></p>
</li>
<li>
<p><a href="./core-starknet-testing.html">starknet::testing</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int.html">bounded_int</a></p>
</li>
<li>
<p><a href="./core-zeroable-zero_based.html">zero_based</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core"><a class="header" href="#core">core</a></h1>
<p>Fully qualified path: <code>core</code></p>
<h2 id="modules-1"><a class="header" href="#modules-1">Modules</a></h2>
<ul>
<li>
<p><a href="./core-traits.html">traits</a></p>
</li>
<li>
<p><a href="./core-boolean.html">boolean</a></p>
</li>
<li>
<p><a href="./core-circuit.html">circuit</a></p>
</li>
<li>
<p><a href="./core-felt_252.html">felt_252</a></p>
</li>
<li>
<p><a href="./core-box.html">box</a></p>
</li>
<li>
<p><a href="./core-nullable.html">nullable</a></p>
</li>
<li>
<p><a href="./core-array.html">array</a></p>
</li>
<li>
<p><a href="./core-dict.html">dict</a></p>
</li>
<li>
<p><a href="./core-result.html">result</a></p>
</li>
<li>
<p><a href="./core-option.html">option</a></p>
</li>
<li>
<p><a href="./core-clone.html">clone</a></p>
</li>
<li>
<p><a href="./core-ec.html">ec</a></p>
</li>
<li>
<p><a href="./core-ecdsa.html">ecdsa</a></p>
</li>
<li>
<p><a href="./core-integer.html">integer</a></p>
</li>
<li>
<p><a href="./core-math.html">math</a></p>
</li>
<li>
<p><a href="./core-num.html">num</a></p>
</li>
<li>
<p><a href="./core-ops.html">ops</a></p>
</li>
<li>
<p><a href="./core-cmp.html">cmp</a></p>
</li>
<li>
<p><a href="./core-gas.html">gas</a></p>
</li>
<li>
<p><a href="./core-panics.html">panics</a></p>
</li>
<li>
<p><a href="./core-serde.html">serde</a></p>
</li>
<li>
<p><a href="./core-hash.html">hash</a></p>
</li>
<li>
<p><a href="./core-keccak.html">keccak</a></p>
</li>
<li>
<p><a href="./core-sha256.html">sha256</a></p>
</li>
<li>
<p><a href="./core-pedersen.html">pedersen</a></p>
</li>
<li>
<p><a href="./core-poseidon.html">poseidon</a></p>
</li>
<li>
<p><a href="./core-debug.html">debug</a></p>
</li>
<li>
<p><a href="./core-fmt.html">fmt</a></p>
</li>
<li>
<p><a href="./core-starknet.html">starknet</a></p>
</li>
<li>
<p><a href="./core-internal.html">internal</a></p>
</li>
<li>
<p><a href="./core-zeroable.html">zeroable</a></p>
</li>
<li>
<p><a href="./core-bytes_31.html">bytes_31</a></p>
</li>
<li>
<p><a href="./core-byte_array.html">byte_array</a></p>
</li>
<li>
<p><a href="./core-string.html">string</a></p>
</li>
<li>
<p><a href="./core-to_byte_array.html">to_byte_array</a></p>
</li>
<li>
<p><a href="./core-testing.html">testing</a></p>
</li>
<li>
<p><a href="./core-metaprogramming.html">metaprogramming</a></p>
</li>
<li>
<p><a href="./core-prelude.html">prelude</a></p>
</li>
<li>
<p><a href="./core-iter.html">iter</a></p>
</li>
</ul>
<h2 id="free-functions"><a class="header" href="#free-functions">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-panic_with_felt252.html">panic_with_felt252</a></p>
</li>
<li>
<p><a href="./core-assert.html">assert</a></p>
</li>
</ul>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<ul>
<li>
<p><a href="./core-bool.html">bool</a></p>
</li>
<li>
<p><a href="./core-never.html">never</a></p>
</li>
</ul>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type aliases</a></h2>
<ul>
<li><a href="./core-usize.html">usize</a></li>
</ul>
<h2 id="impls"><a class="header" href="#impls">Impls</a></h2>
<ul>
<li>
<p><a href="./core-BoolSerde.html">BoolSerde</a></p>
</li>
<li>
<p><a href="./core-BoolBitAnd.html">BoolBitAnd</a></p>
</li>
<li>
<p><a href="./core-BoolBitOr.html">BoolBitOr</a></p>
</li>
<li>
<p><a href="./core-BoolNot.html">BoolNot</a></p>
</li>
<li>
<p><a href="./core-BoolBitXor.html">BoolBitXor</a></p>
</li>
<li>
<p><a href="./core-BoolPartialEq.html">BoolPartialEq</a></p>
</li>
<li>
<p><a href="./core-BoolFelt252DictValue.html">BoolFelt252DictValue</a></p>
</li>
<li>
<p><a href="./core-BoolIntoFelt252.html">BoolIntoFelt252</a></p>
</li>
<li>
<p><a href="./core-Felt252Serde.html">Felt252Serde</a></p>
</li>
<li>
<p><a href="./core-Felt252Add.html">Felt252Add</a></p>
</li>
<li>
<p><a href="./core-Felt252AddEq.html">Felt252AddEq</a></p>
</li>
<li>
<p><a href="./core-Felt252Sub.html">Felt252Sub</a></p>
</li>
<li>
<p><a href="./core-Felt252SubEq.html">Felt252SubEq</a></p>
</li>
<li>
<p><a href="./core-Felt252Mul.html">Felt252Mul</a></p>
</li>
<li>
<p><a href="./core-Felt252MulEq.html">Felt252MulEq</a></p>
</li>
<li>
<p><a href="./core-Felt252Neg.html">Felt252Neg</a></p>
</li>
<li>
<p><a href="./core-Felt252PartialEq.html">Felt252PartialEq</a></p>
</li>
<li>
<p><a href="./core-Felt252TryIntoNonZero.html">Felt252TryIntoNonZero</a></p>
</li>
<li>
<p><a href="./core-Felt252Default.html">Felt252Default</a></p>
</li>
<li>
<p><a href="./core-Felt252Felt252DictValue.html">Felt252Felt252DictValue</a></p>
</li>
<li>
<p><a href="./core-boolCopy.html">boolCopy</a></p>
</li>
<li>
<p><a href="./core-boolDrop.html">boolDrop</a></p>
</li>
<li>
<p><a href="./core-boolDefault.html">boolDefault</a></p>
</li>
<li>
<p><a href="./core-felt252Copy.html">felt252Copy</a></p>
</li>
<li>
<p><a href="./core-felt252Drop.html">felt252Drop</a></p>
</li>
</ul>
<h2 id="extern-types"><a class="header" href="#extern-types">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-RangeCheck.html">RangeCheck</a></p>
</li>
<li>
<p><a href="./core-SegmentArena.html">SegmentArena</a></p>
</li>
<li>
<p><a href="./core-felt252.html">felt252</a></p>
</li>
</ul>
<h2 id="extern-functions"><a class="header" href="#extern-functions">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-bool_and_impl.html">bool_and_impl</a></p>
</li>
<li>
<p><a href="./core-bool_or_impl.html">bool_or_impl</a></p>
</li>
<li>
<p><a href="./core-bool_not_impl.html">bool_not_impl</a></p>
</li>
<li>
<p><a href="./core-bool_xor_impl.html">bool_xor_impl</a></p>
</li>
<li>
<p><a href="./core-bool_to_felt252.html">bool_to_felt252</a></p>
</li>
<li>
<p><a href="./core-felt252_const.html">felt252_const</a></p>
</li>
<li>
<p><a href="./core-felt252_add.html">felt252_add</a></p>
</li>
<li>
<p><a href="./core-felt252_sub.html">felt252_sub</a></p>
</li>
<li>
<p><a href="./core-felt252_mul.html">felt252_mul</a></p>
</li>
<li>
<p><a href="./core-felt252_div.html">felt252_div</a></p>
</li>
<li>
<p><a href="./core-felt252_is_zero.html">felt252_is_zero</a></p>
</li>
<li>
<p><a href="./core-dup.html">dup</a></p>
</li>
<li>
<p><a href="./core-drop.html">drop</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">traits</a></h1>
<p>Fully qualified path: <code>core::traits</code></p>
<h2 id="traits-1"><a class="header" href="#traits-1">Traits</a></h2>
<ul>
<li>
<p><a href="./core-traits-Copy.html">Copy</a></p>
</li>
<li>
<p><a href="./core-traits-Drop.html">Drop</a></p>
</li>
<li>
<p><a href="./core-traits-Add.html">Add</a></p>
</li>
<li>
<p><a href="./core-traits-AddEq.html">AddEq</a></p>
</li>
<li>
<p><a href="./core-traits-Sub.html">Sub</a></p>
</li>
<li>
<p><a href="./core-traits-SubEq.html">SubEq</a></p>
</li>
<li>
<p><a href="./core-traits-Mul.html">Mul</a></p>
</li>
<li>
<p><a href="./core-traits-MulEq.html">MulEq</a></p>
</li>
<li>
<p><a href="./core-traits-Div.html">Div</a></p>
</li>
<li>
<p><a href="./core-traits-DivEq.html">DivEq</a></p>
</li>
<li>
<p><a href="./core-traits-Rem.html">Rem</a></p>
</li>
<li>
<p><a href="./core-traits-RemEq.html">RemEq</a></p>
</li>
<li>
<p><a href="./core-traits-DivRem.html">DivRem</a></p>
</li>
<li>
<p><a href="./core-traits-PartialEq.html">PartialEq</a></p>
</li>
<li>
<p><a href="./core-traits-BitAnd.html">BitAnd</a></p>
</li>
<li>
<p><a href="./core-traits-BitOr.html">BitOr</a></p>
</li>
<li>
<p><a href="./core-traits-BitXor.html">BitXor</a></p>
</li>
<li>
<p><a href="./core-traits-BitNot.html">BitNot</a></p>
</li>
<li>
<p><a href="./core-traits-PartialOrd.html">PartialOrd</a></p>
</li>
<li>
<p><a href="./core-traits-Into.html">Into</a></p>
</li>
<li>
<p><a href="./core-traits-TryInto.html">TryInto</a></p>
</li>
<li>
<p><a href="./core-traits-Neg.html">Neg</a></p>
</li>
<li>
<p><a href="./core-traits-Not.html">Not</a></p>
</li>
<li>
<p><a href="./core-traits-IndexView.html">IndexView</a></p>
</li>
<li>
<p><a href="./core-traits-Index.html">Index</a></p>
</li>
<li>
<p><a href="./core-traits-Destruct.html">Destruct</a></p>
</li>
<li>
<p><a href="./core-traits-PanicDestruct.html">PanicDestruct</a></p>
</li>
<li>
<p><a href="./core-traits-Default.html">Default</a></p>
</li>
<li>
<p><a href="./core-traits-Felt252DictValue.html">Felt252DictValue</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolean"><a class="header" href="#boolean">boolean</a></h1>
<p>Boolean operations.  The <code>bool</code> type is a primitive type in Cairo representing a boolean value that can be either <code>true</code> or <code>false</code>. This module provides trait implementations for boolean operations.  # Examples  Basic boolean operations:</p>
<pre><code class="language-cairo">
let value = true;
assert!(value == true);
assert!(!value == false);
</code></pre>
<p>Converting to optional values with <a href="%5B%60BoolTrait::then_some%60%5D"><code>BoolTrait::then_some</code></a>:</p>
<pre><code class="language-cairo">use core::boolean::BoolTrait;

let bool_value = true;
let result = bool_value.then_some(42_u8);
assert!(result == Option::Some(42));

let bool_value = false;
let result = bool_value.then_some(42_u8);
assert!(result == Option::None);
</code></pre>
<p>Fully qualified path: <code>core::boolean</code></p>
<h2 id="traits-2"><a class="header" href="#traits-2">Traits</a></h2>
<ul>
<li><a href="./core-boolean-BoolTrait.html">BoolTrait</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit"><a class="header" href="#circuit">circuit</a></h1>
<p>Fully qualified path: <code>core::circuit</code></p>
<h2 id="free-functions-1"><a class="header" href="#free-functions-1">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-circuit-circuit_add.html">circuit_add</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_sub.html">circuit_sub</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_inverse.html">circuit_inverse</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_mul.html">circuit_mul</a></p>
</li>
</ul>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<ul>
<li>
<p><a href="./core-circuit-u384.html">u384</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitElement.html">CircuitElement</a></p>
</li>
</ul>
<h2 id="enums-1"><a class="header" href="#enums-1">Enums</a></h2>
<ul>
<li><a href="./core-circuit-AddInputResult.html">AddInputResult</a></li>
</ul>
<h2 id="type-aliases-1"><a class="header" href="#type-aliases-1">Type aliases</a></h2>
<ul>
<li>
<p><a href="./core-circuit-u96.html">u96</a></p>
</li>
<li>
<p><a href="./core-circuit-ConstZero.html">ConstZero</a></p>
</li>
<li>
<p><a href="./core-circuit-ConstOne.html">ConstOne</a></p>
</li>
</ul>
<h2 id="traits-3"><a class="header" href="#traits-3">Traits</a></h2>
<ul>
<li>
<p><a href="./core-circuit-CircuitElementTrait.html">CircuitElementTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitOutputsTrait.html">CircuitOutputsTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitInputs.html">CircuitInputs</a></p>
</li>
<li>
<p><a href="./core-circuit-AddInputResultTrait.html">AddInputResultTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-EvalCircuitTrait.html">EvalCircuitTrait</a></p>
</li>
</ul>
<h2 id="impls-1"><a class="header" href="#impls-1">Impls</a></h2>
<ul>
<li>
<p><a href="./core-circuit-CircuitElementDrop.html">CircuitElementDrop</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitElementCopy.html">CircuitElementCopy</a></p>
</li>
<li>
<p><a href="./core-circuit-DestructFailureGuarantee.html">DestructFailureGuarantee</a></p>
</li>
</ul>
<h2 id="extern-types-1"><a class="header" href="#extern-types-1">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-circuit-RangeCheck96.html">RangeCheck96</a></p>
</li>
<li>
<p><a href="./core-circuit-AddMod.html">AddMod</a></p>
</li>
<li>
<p><a href="./core-circuit-MulMod.html">MulMod</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitModulus.html">CircuitModulus</a></p>
</li>
<li>
<p><a href="./core-circuit-Circuit.html">Circuit</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitInput.html">CircuitInput</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt_252"><a class="header" href="#felt_252">felt_252</a></h1>
<p>felt252. Utilities for the <code>felt252</code> type.  The implementations defined in this module can be accessed by using the traits directly.</p>
<p>Fully qualified path: <code>core::felt_252</code></p>
<h2 id="impls-2"><a class="header" href="#impls-2">Impls</a></h2>
<ul>
<li>
<p><a href="./core-felt_252-Felt252Zero.html">Felt252Zero</a></p>
</li>
<li>
<p><a href="./core-felt_252-Felt252One.html">Felt252One</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box"><a class="header" href="#box">box</a></h1>
<p>Boxes. <code>Box&lt;T&gt;</code> is a smart pointer that allows for:  * Storing values of arbitrary size while maintaining a fixed-size pointer * Enabling recursive types that would otherwise have infinite size * Moving large data structures efficiently by passing pointers instead of copying values  # Examples  Creating a new box with <a href="%5B%60BoxTrait::new%60%5D"><code>BoxTrait::new</code></a>:</p>
<pre><code class="language-cairo">let boxed = BoxTrait::new(42);
let unboxed = boxed.unbox();
</code></pre>
<p>Working with larger structures:</p>
<pre><code class="language-cairo">let large_array = array![1, 2, 3, 4, 5];
let boxed_array = BoxTrait::new(large_array);
</code></pre>
<p>Creating a recursive data structure:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Copy, Drop, Debug)]
</span>enum BinaryTree {
    Leaf: u32,
    Node: (u32, Box&lt;BinaryTree&gt;, Box&lt;BinaryTree&gt;)
}

let leaf = BinaryTree::Leaf(1);
let node = BinaryTree::Node((2, BoxTrait::new(leaf), BoxTrait::new(leaf)));
println!("{:?}", node);
</code></pre>
<p>NOTE: A <code>Box&lt;T&gt;</code> is a smart pointer type that provides a way to store a value of type <code>T</code> in Cairo VM's boxed segment, leaving only a pointer in the execution segment.</p>
<p>Fully qualified path: <code>core::box</code></p>
<h2 id="traits-4"><a class="header" href="#traits-4">Traits</a></h2>
<ul>
<li><a href="./core-box-BoxTrait.html">BoxTrait</a></li>
</ul>
<h2 id="extern-types-2"><a class="header" href="#extern-types-2">Extern types</a></h2>
<ul>
<li><a href="./core-box-Box.html">Box</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullable"><a class="header" href="#nullable">nullable</a></h1>
<p>Nullable A wrapper type for handling optional values.  <code>Nullable&lt;T&gt;</code> is a wrapper type that can either contain a value stored in a <code>Box&lt;T&gt;</code> or be null. It provides a safe way to handle optional values without the risk of dereferencing null pointers.  This makes it particularly useful in dictionaries that store complex data structures that don't implement the <code>Felt252DictValue</code> trait; instead, they can be wrapped inside a <code>Nullable</code>.  # Examples  Basic usage:</p>
<pre><code class="language-cairo">let value: Nullable&lt;u32&gt; = NullableTrait::new(10);
let unwrapped_value = value.deref();
</code></pre>
<p>Handling null values:</p>
<pre><code class="language-cairo">let null_value: Nullable&lt;u32&gt; = Default::default();
let unwrapped_value = null_value.deref_or(1);
</code></pre>
<p>Checking if the value is null:</p>
<pre><code class="language-cairo">let value: Nullable&lt;u32&gt; = NullableTrait::new(10);
let is_null = if value.is_null() {
    // Handle null case
} else {
    // Handle non-null case
};
</code></pre>
<p>Fully qualified path: <code>core::nullable</code></p>
<h2 id="enums-2"><a class="header" href="#enums-2">Enums</a></h2>
<ul>
<li><a href="./core-nullable-FromNullableResult.html">FromNullableResult</a></li>
</ul>
<h2 id="traits-5"><a class="header" href="#traits-5">Traits</a></h2>
<ul>
<li><a href="./core-nullable-NullableTrait.html">NullableTrait</a></li>
</ul>
<h2 id="extern-types-3"><a class="header" href="#extern-types-3">Extern types</a></h2>
<ul>
<li><a href="./core-nullable-Nullable.html">Nullable</a></li>
</ul>
<h2 id="extern-functions-1"><a class="header" href="#extern-functions-1">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-nullable-null.html">null</a></p>
</li>
<li>
<p><a href="./core-nullable-nullable_from_box.html">nullable_from_box</a></p>
</li>
<li>
<p><a href="./core-nullable-match_nullable.html">match_nullable</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">array</a></h1>
<p>Module for <code>Array</code> and other continuous same type collections. A contiguous collection of elements of the same type in memory, written <code>Array&lt;T&gt;</code>.  Arrays have O(1) indexing, O(1) push and O(1) pop (from the front).  Arrays can only be mutated by appending to the end or popping from the front.  # Examples  You can explicitly create an <a href="./core-array-Array.html"><code>Array</code></a> with <a href="%5B%60ArrayTrait::new%60%5D"><code>ArrayTrait::new</code></a>:</p>
<pre><code class="language-cairo">let arr: Array&lt;usize&gt; = ArrayTrait::new();
</code></pre>
<p>...or by using the <code>array!</code> macro:</p>
<pre><code class="language-cairo">let arr: Array&lt;usize&gt; = array![];

let arr: Array&lt;usize&gt; = array![1, 2, 3, 4, 5];
</code></pre>
<p>You can <a href="%5B%60append%60%5D"><code>append</code></a> values onto the end of an array:</p>
<pre><code class="language-cairo">let mut arr = array![1, 2];
arr.append(3);
</code></pre>
<p>Popping values from the front works like this:</p>
<pre><code class="language-cairo">let mut arr = array![1, 2];
let one = arr.pop_front(); // Returns Option::Some(1)
</code></pre>
<p>Arrays support indexing (through the <a href="./core-traits-IndexView.html"><code>IndexView</code></a> trait):</p>
<pre><code class="language-cairo">let arr = array![1, 2, 3];
let three = arr[2]; // Returns a snapshot (@T)
</code></pre>
<p>Arrays can be converted to <a href="./core-array-Span.html"><code>Span</code></a>s for read-only access:</p>
<pre><code class="language-cairo">let arr = array![1, 2, 3];
let span = arr.span();
</code></pre>
<p>A span can be manipulated without affecting the original array:</p>
<pre><code class="language-cairo">let mut arr = array![1, 2, 3];
let mut span = arr.span();
span.pop_back();
assert!(arr == array![1, 2, 3]);
</code></pre>
<p>Fully qualified path: <code>core::array</code></p>
<h2 id="structs-1"><a class="header" href="#structs-1">Structs</a></h2>
<ul>
<li>
<p><a href="./core-array-Span.html">Span</a></p>
</li>
<li>
<p><a href="./core-array-SpanIter.html">SpanIter</a></p>
</li>
<li>
<p><a href="./core-array-ArrayIter.html">ArrayIter</a></p>
</li>
</ul>
<h2 id="traits-6"><a class="header" href="#traits-6">Traits</a></h2>
<ul>
<li>
<p><a href="./core-array-ToSpanTrait.html">ToSpanTrait</a></p>
</li>
<li>
<p><a href="./core-array-ArrayTrait.html">ArrayTrait</a></p>
</li>
<li>
<p><a href="./core-array-SpanTrait.html">SpanTrait</a></p>
</li>
</ul>
<h2 id="impls-3"><a class="header" href="#impls-3">Impls</a></h2>
<ul>
<li><a href="./core-array-SpanIndex.html">SpanIndex</a></li>
</ul>
<h2 id="extern-types-4"><a class="header" href="#extern-types-4">Extern types</a></h2>
<ul>
<li><a href="./core-array-Array.html">Array</a></li>
</ul>
<h2 id="extern-functions-2"><a class="header" href="#extern-functions-2">Extern functions</a></h2>
<ul>
<li><a href="./core-array-array_snapshot_pop_front.html">array_snapshot_pop_front</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dict"><a class="header" href="#dict">dict</a></h1>
<p>Dictionary. A dictionary-like data structure that maps <code>felt252</code> keys to values of any type.  The <code>Felt252Dict</code> provides efficient key-value storage with operations for inserting, retrieving, and updating values. Each operation creates a new entry that can be validated through a process called squashing.  # Examples  One can create a new dictionary using the <a href="%5B%60Default::default%60%5D"><code>Default::default</code></a> method:</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

let mut dict: Felt252Dict&lt;u8&gt; = Default::default();
</code></pre>
<p>... then insert new values corresponding to a given key with the <a href="%5B%60Felt252DictTrait::insert%60%5D"><code>Felt252DictTrait::insert</code></a> method, and retrieve any value given a key with the <a href="%5B%60Felt252DictTrait::get%60%5D"><code>Felt252DictTrait::get</code></a> method.</p>
<pre><code class="language-cairo">dict.insert(0, 10);
dict.insert(1, 20);
assert!(dict.get(0) == 10);
assert!(dict.get(1) == 20);

dict.insert(0, 20);
assert!(dict.get(0) == 20
</code></pre>
<p>It is also possible to use the <a href="%5B%60Felt252DictTrait::entry%60%5D"><code>Felt252DictTrait::entry</code></a> method to retrieve the last entry given a certain key. In this case, the method takes ownership of the dictionary and returns the entry to update. After that, using the <a href="%5B%60Felt252DictEntryTrait::finalize%60%5D"><code>Felt252DictEntryTrait::finalize</code></a> allows to create a new entry in the dictionary. Using <code>entry</code> and <code>finalize</code> methods can be very useful given that it does not require the type in the dictionary to be copyable, meaning that we can use non-copyable types like arrays as dictionary values.</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

let mut dict: Felt252Dict&lt;u8&gt; = Default::default();
dict.insert(0, 10);

let (entry, prev_value) = dict.entry(0);
let new_value: u8 = 20;
dict = entry.finalize(new_value);
</code></pre>
<p>Fully qualified path: <code>core::dict</code></p>
<h2 id="traits-7"><a class="header" href="#traits-7">Traits</a></h2>
<ul>
<li>
<p><a href="./core-dict-Felt252DictTrait.html">Felt252DictTrait</a></p>
</li>
<li>
<p><a href="./core-dict-Felt252DictEntryTrait.html">Felt252DictEntryTrait</a></p>
</li>
</ul>
<h2 id="extern-types-5"><a class="header" href="#extern-types-5">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-dict-Felt252Dict.html">Felt252Dict</a></p>
</li>
<li>
<p><a href="./core-dict-SquashedFelt252Dict.html">SquashedFelt252Dict</a></p>
</li>
<li>
<p><a href="./core-dict-Felt252DictEntry.html">Felt252DictEntry</a></p>
</li>
</ul>
<h2 id="extern-functions-3"><a class="header" href="#extern-functions-3">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-dict-felt252_dict_new.html">felt252_dict_new</a></p>
</li>
<li>
<p><a href="./core-dict-felt252_dict_squash.html">felt252_dict_squash</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result"><a class="header" href="#result">result</a></h1>
<p>Result.</p>
<p>Fully qualified path: <code>core::result</code></p>
<h2 id="enums-3"><a class="header" href="#enums-3">Enums</a></h2>
<ul>
<li><a href="./core-result-Result.html">Result</a></li>
</ul>
<h2 id="traits-8"><a class="header" href="#traits-8">Traits</a></h2>
<ul>
<li><a href="./core-result-ResultTrait.html">ResultTrait</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option">option</a></h1>
<p>Option.</p>
<p>Fully qualified path: <code>core::option</code></p>
<h2 id="enums-4"><a class="header" href="#enums-4">Enums</a></h2>
<ul>
<li><a href="./core-option-Option.html">Option</a></li>
</ul>
<h2 id="traits-9"><a class="header" href="#traits-9">Traits</a></h2>
<ul>
<li><a href="./core-option-OptionTrait.html">OptionTrait</a></li>
</ul>
<h2 id="impls-4"><a class="header" href="#impls-4">Impls</a></h2>
<ul>
<li><a href="./core-option-DestructOption.html">DestructOption</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clone"><a class="header" href="#clone">clone</a></h1>
<p>Clone. The <code>Clone</code> trait provides the ability to duplicate instances of types that cannot be 'implicitly copied'.  In Cairo, some simple types are "implicitly copyable": when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy, and are not at risk of accessing un-allocated memory, so the compiler considers them cheap and safe to copy. For other types, copies must be made explicitly, by convention implementing the <a href="./core-clone-Clone.html"><code>Clone</code></a> trait and calling the <a href="%5B%60Clone::clone%60%5D"><code>Clone::clone</code></a> method.  # Examples</p>
<pre><code class="language-cairo">let arr = array![1, 2, 3];
let cloned_arr = arr.clone();
assert!(arr == cloned_arr);
</code></pre>
<p>You can use the <code>#[derive(Clone)]</code> attribute to automatically generate the implementation for your type:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Clone, Drop)]
</span>struct Sheep {
   name: ByteArray,
   age: u8,
}

fn main() {
   let dolly = Sheep {
       name: "Dolly",
       age: 6,
   };

   let cloned_sheep = dolly.clone();  // Famous cloned sheep!
}
</code></pre>
<p>Fully qualified path: <code>core::clone</code></p>
<h2 id="traits-10"><a class="header" href="#traits-10">Traits</a></h2>
<ul>
<li><a href="./core-clone-Clone.html">Clone</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec"><a class="header" href="#ec">ec</a></h1>
<p>EC. This module contains functions and constructs related to elliptic curve operations on the Stark curve.</p>
<p>Fully qualified path: <code>core::ec</code></p>
<h2 id="modules-2"><a class="header" href="#modules-2">Modules</a></h2>
<ul>
<li><a href="./core-ec-stark_curve.html">stark_curve</a></li>
</ul>
<h2 id="type-aliases-2"><a class="header" href="#type-aliases-2">Type aliases</a></h2>
<ul>
<li><a href="./core-ec-NonZeroEcPoint.html">NonZeroEcPoint</a></li>
</ul>
<h2 id="traits-11"><a class="header" href="#traits-11">Traits</a></h2>
<ul>
<li>
<p><a href="./core-ec-EcStateTrait.html">EcStateTrait</a></p>
</li>
<li>
<p><a href="./core-ec-EcPointTrait.html">EcPointTrait</a></p>
</li>
</ul>
<h2 id="impls-5"><a class="header" href="#impls-5">Impls</a></h2>
<ul>
<li>
<p><a href="./core-ec-EcStateImpl.html">EcStateImpl</a></p>
</li>
<li>
<p><a href="./core-ec-EcPointImpl.html">EcPointImpl</a></p>
</li>
</ul>
<h2 id="extern-types-6"><a class="header" href="#extern-types-6">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-ec-EcOp.html">EcOp</a></p>
</li>
<li>
<p><a href="./core-ec-EcPoint.html">EcPoint</a></p>
</li>
<li>
<p><a href="./core-ec-EcState.html">EcState</a></p>
</li>
</ul>
<h2 id="extern-functions-4"><a class="header" href="#extern-functions-4">Extern functions</a></h2>
<ul>
<li><a href="./core-ec-ec_point_unwrap.html">ec_point_unwrap</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecdsa"><a class="header" href="#ecdsa">ecdsa</a></h1>
<p>Fully qualified path: <code>core::ecdsa</code></p>
<h2 id="free-functions-2"><a class="header" href="#free-functions-2">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-ecdsa-check_ecdsa_signature.html">check_ecdsa_signature</a></p>
</li>
<li>
<p><a href="./core-ecdsa-recover_public_key.html">recover_public_key</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer"><a class="header" href="#integer">integer</a></h1>
<p>Integer.</p>
<p>Fully qualified path: <code>core::integer</code></p>
<h2 id="free-functions-3"><a class="header" href="#free-functions-3">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-integer-u128_wrapping_add.html">u128_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u128_wrapping_sub.html">u128_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u128_wide_mul.html">u128_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u128_overflowing_mul.html">u128_overflowing_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u8_wrapping_add.html">u8_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u8_wrapping_sub.html">u8_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u16_wrapping_add.html">u16_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u16_wrapping_sub.html">u16_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u32_wrapping_add.html">u32_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u32_wrapping_sub.html">u32_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u64_wrapping_add.html">u64_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u64_wrapping_sub.html">u64_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflowing_add.html">u256_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflowing_sub.html">u256_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflow_sub.html">u256_overflow_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflowing_mul.html">u256_overflowing_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflow_mul.html">u256_overflow_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u256_wide_mul.html">u256_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u128_add_with_bounded_int_carry.html">u128_add_with_bounded_int_carry</a></p>
</li>
<li>
<p><a href="./core-integer-u512_safe_div_rem_by_u256.html">u512_safe_div_rem_by_u256</a></p>
</li>
</ul>
<h2 id="structs-2"><a class="header" href="#structs-2">Structs</a></h2>
<ul>
<li>
<p><a href="./core-integer-u256.html">u256</a></p>
</li>
<li>
<p><a href="./core-integer-u512.html">u512</a></p>
</li>
</ul>
<h2 id="impl-aliases"><a class="header" href="#impl-aliases">Impl aliases</a></h2>
<ul>
<li>
<p><a href="./core-integer-U8Zeroable.html">U8Zeroable</a></p>
</li>
<li>
<p><a href="./core-integer-U16Zeroable.html">U16Zeroable</a></p>
</li>
<li>
<p><a href="./core-integer-U32Zeroable.html">U32Zeroable</a></p>
</li>
<li>
<p><a href="./core-integer-U64Zeroable.html">U64Zeroable</a></p>
</li>
<li>
<p><a href="./core-integer-U128Zeroable.html">U128Zeroable</a></p>
</li>
<li>
<p><a href="./core-integer-U256Zeroable.html">U256Zeroable</a></p>
</li>
</ul>
<h2 id="traits-12"><a class="header" href="#traits-12">Traits</a></h2>
<ul>
<li>
<p><a href="./core-integer-NumericLiteral.html">NumericLiteral</a></p>
</li>
<li>
<p><a href="./core-integer-BoundedInt.html">BoundedInt</a></p>
</li>
<li>
<p><a href="./core-integer-AbsAndSign.html">AbsAndSign</a></p>
</li>
</ul>
<h2 id="impls-6"><a class="header" href="#impls-6">Impls</a></h2>
<ul>
<li>
<p><a href="./core-integer-U128TryIntoNonZero.html">U128TryIntoNonZero</a></p>
</li>
<li>
<p><a href="./core-integer-U32TryIntoNonZero.html">U32TryIntoNonZero</a></p>
</li>
<li>
<p><a href="./core-integer-U256TryIntoNonZero.html">U256TryIntoNonZero</a></p>
</li>
<li>
<p><a href="./core-integer-Felt252TryIntoU8.html">Felt252TryIntoU8</a></p>
</li>
<li>
<p><a href="./core-integer-U8IntoFelt252.html">U8IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-Felt252TryIntoU16.html">Felt252TryIntoU16</a></p>
</li>
<li>
<p><a href="./core-integer-U16IntoFelt252.html">U16IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-Felt252TryIntoU32.html">Felt252TryIntoU32</a></p>
</li>
<li>
<p><a href="./core-integer-U32IntoFelt252.html">U32IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-Felt252TryIntoU64.html">Felt252TryIntoU64</a></p>
</li>
<li>
<p><a href="./core-integer-U64IntoFelt252.html">U64IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-Felt252TryIntoU128.html">Felt252TryIntoU128</a></p>
</li>
<li>
<p><a href="./core-integer-U128IntoFelt252.html">U128IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-Felt252IntoU256.html">Felt252IntoU256</a></p>
</li>
<li>
<p><a href="./core-integer-U256TryIntoFelt252.html">U256TryIntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-I8IntoFelt252.html">I8IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-I16IntoFelt252.html">I16IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-I32IntoFelt252.html">I32IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-I64IntoFelt252.html">I64IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-I128IntoFelt252.html">I128IntoFelt252</a></p>
</li>
</ul>
<h2 id="extern-types-7"><a class="header" href="#extern-types-7">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-integer-u128.html">u128</a></p>
</li>
<li>
<p><a href="./core-integer-U128MulGuarantee.html">U128MulGuarantee</a></p>
</li>
<li>
<p><a href="./core-integer-Bitwise.html">Bitwise</a></p>
</li>
<li>
<p><a href="./core-integer-u8.html">u8</a></p>
</li>
<li>
<p><a href="./core-integer-u16.html">u16</a></p>
</li>
<li>
<p><a href="./core-integer-u32.html">u32</a></p>
</li>
<li>
<p><a href="./core-integer-u64.html">u64</a></p>
</li>
<li>
<p><a href="./core-integer-i8.html">i8</a></p>
</li>
<li>
<p><a href="./core-integer-i16.html">i16</a></p>
</li>
<li>
<p><a href="./core-integer-i32.html">i32</a></p>
</li>
<li>
<p><a href="./core-integer-i64.html">i64</a></p>
</li>
<li>
<p><a href="./core-integer-i128.html">i128</a></p>
</li>
</ul>
<h2 id="extern-functions-5"><a class="header" href="#extern-functions-5">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-integer-u128_to_felt252.html">u128_to_felt252</a></p>
</li>
<li>
<p><a href="./core-integer-u128_overflowing_add.html">u128_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u128_overflowing_sub.html">u128_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u128_sqrt.html">u128_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u128_safe_divmod.html">u128_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u128_is_zero.html">u128_is_zero</a></p>
</li>
<li>
<p><a href="./core-integer-u128_byte_reverse.html">u128_byte_reverse</a></p>
</li>
<li>
<p><a href="./core-integer-u8_overflowing_add.html">u8_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u8_overflowing_sub.html">u8_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u8_wide_mul.html">u8_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u8_sqrt.html">u8_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u8_safe_divmod.html">u8_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u16_overflowing_add.html">u16_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u16_overflowing_sub.html">u16_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u16_wide_mul.html">u16_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u16_sqrt.html">u16_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u16_safe_divmod.html">u16_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u32_overflowing_add.html">u32_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u32_overflowing_sub.html">u32_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u32_wide_mul.html">u32_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u32_sqrt.html">u32_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u32_safe_divmod.html">u32_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u64_overflowing_add.html">u64_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u64_overflowing_sub.html">u64_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u64_wide_mul.html">u64_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u64_sqrt.html">u64_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u64_safe_divmod.html">u64_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u256_sqrt.html">u256_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-upcast.html">upcast</a></p>
</li>
<li>
<p><a href="./core-integer-downcast.html">downcast</a></p>
</li>
<li>
<p><a href="./core-integer-i8_wide_mul.html">i8_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i8_diff.html">i8_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i16_wide_mul.html">i16_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i16_diff.html">i16_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i32_wide_mul.html">i32_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i32_diff.html">i32_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i64_wide_mul.html">i64_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i64_diff.html">i64_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i128_diff.html">i128_diff</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math"><a class="header" href="#math">math</a></h1>
<p>Math. Mathematical operations and utilities.  Provides extended GCD, modular inverse, and modular arithmetic operations.</p>
<p>Fully qualified path: <code>core::math</code></p>
<h2 id="modules-3"><a class="header" href="#modules-3">Modules</a></h2>
<ul>
<li><a href="./core-math-one_based.html">one_based</a></li>
</ul>
<h2 id="free-functions-4"><a class="header" href="#free-functions-4">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-math-egcd.html">egcd</a></p>
</li>
<li>
<p><a href="./core-math-inv_mod.html">inv_mod</a></p>
</li>
<li>
<p><a href="./core-math-u256_inv_mod.html">u256_inv_mod</a></p>
</li>
<li>
<p><a href="./core-math-u256_div_mod_n.html">u256_div_mod_n</a></p>
</li>
<li>
<p><a href="./core-math-u256_mul_mod_n.html">u256_mul_mod_n</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="num"><a class="header" href="#num">num</a></h1>
<p>Module containing the traits for relevant for numeric types.</p>
<p>Fully qualified path: <code>core::num</code></p>
<h2 id="modules-4"><a class="header" href="#modules-4">Modules</a></h2>
<ul>
<li><a href="./core-num-traits.html">traits</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ops"><a class="header" href="#ops">ops</a></h1>
<p>Module containing the operations that can be performed on the different types.</p>
<p>Fully qualified path: <code>core::ops</code></p>
<h2 id="modules-5"><a class="header" href="#modules-5">Modules</a></h2>
<ul>
<li><a href="./core-ops-index.html">index</a></li>
</ul>
<h2 id="structs-3"><a class="header" href="#structs-3">Structs</a></h2>
<ul>
<li><a href="./core-ops-range-Range.html">Range</a></li>
</ul>
<h2 id="traits-13"><a class="header" href="#traits-13">Traits</a></h2>
<ul>
<li>
<p><a href="./core-ops-index-Index.html">Index</a></p>
</li>
<li>
<p><a href="./core-ops-index-IndexView.html">IndexView</a></p>
</li>
<li>
<p><a href="./core-ops-arith-AddAssign.html">AddAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-SubAssign.html">SubAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-MulAssign.html">MulAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-DivAssign.html">DivAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-RemAssign.html">RemAssign</a></p>
</li>
<li>
<p><a href="./core-ops-deref-Deref.html">Deref</a></p>
</li>
<li>
<p><a href="./core-ops-deref-SnapshotDeref.html">SnapshotDeref</a></p>
</li>
<li>
<p><a href="./core-ops-deref-DerefMut.html">DerefMut</a></p>
</li>
<li>
<p><a href="./core-ops-function-FnOnce.html">FnOnce</a></p>
</li>
<li>
<p><a href="./core-ops-function-Fn.html">Fn</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmp"><a class="header" href="#cmp">cmp</a></h1>
<p>Module for comparison operations. Utilities for comparing and ordering values. This module contains functions that rely on the <code>PartialOrd</code> trait for comparing values.  # Examples</p>
<pre><code class="language-cairo">use core::cmp::{min, max, minmax};

assert!(min(10, 20) == 10);
assert!(max(10, 20) == 20);

assert!(minmax(20, 10) == (10, 20));
assert!(minmax(10, 20) == (10, 20));
</code></pre>
<p>Fully qualified path: <code>core::cmp</code></p>
<h2 id="free-functions-5"><a class="header" href="#free-functions-5">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-cmp-min.html">min</a></p>
</li>
<li>
<p><a href="./core-cmp-max.html">max</a></p>
</li>
<li>
<p><a href="./core-cmp-minmax.html">minmax</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gas"><a class="header" href="#gas">gas</a></h1>
<p>Module for handling gas operations.</p>
<p>Fully qualified path: <code>core::gas</code></p>
<h2 id="extern-types-8"><a class="header" href="#extern-types-8">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-gas-BuiltinCosts.html">BuiltinCosts</a></p>
</li>
<li>
<p><a href="./core-gas-GasBuiltin.html">GasBuiltin</a></p>
</li>
</ul>
<h2 id="extern-functions-6"><a class="header" href="#extern-functions-6">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-gas-withdraw_gas.html">withdraw_gas</a></p>
</li>
<li>
<p><a href="./core-gas-withdraw_gas_all.html">withdraw_gas_all</a></p>
</li>
<li>
<p><a href="./core-gas-redeposit_gas.html">redeposit_gas</a></p>
</li>
<li>
<p><a href="./core-gas-get_builtin_costs.html">get_builtin_costs</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panics"><a class="header" href="#panics">panics</a></h1>
<p>Panics. Core panic mechanism.  This module provides the core panic functionality used for error handling in Cairo. It defines the basic types and functions used to trigger and manage panics, which are Cairo's mechanism for handling unrecoverable errors.  Panics can be triggered in several ways:  Using the <code>panic</code> function:</p>
<pre><code class="language-cairo">use core::panics::panic;

panic(array!['An error occurred']);
</code></pre>
<p>Or using the <code>panic!</code> macro:</p>
<pre><code class="language-cairo">panic!("Panic message");
</code></pre>
<p>This macro internally converts the message into a <code>ByteArray</code> and uses <code>panic_with_byte_array</code>.</p>
<p>Fully qualified path: <code>core::panics</code></p>
<h2 id="free-functions-6"><a class="header" href="#free-functions-6">Free functions</a></h2>
<ul>
<li><a href="./core-panics-panic_with_byte_array.html">panic_with_byte_array</a></li>
</ul>
<h2 id="structs-4"><a class="header" href="#structs-4">Structs</a></h2>
<ul>
<li><a href="./core-panics-Panic.html">Panic</a></li>
</ul>
<h2 id="enums-5"><a class="header" href="#enums-5">Enums</a></h2>
<ul>
<li><a href="./core-panics-PanicResult.html">PanicResult</a></li>
</ul>
<h2 id="extern-functions-7"><a class="header" href="#extern-functions-7">Extern functions</a></h2>
<ul>
<li><a href="./core-panics-panic.html">panic</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serde"><a class="header" href="#serde">serde</a></h1>
<p>Serialization and Deserialization. Serialization and deserialization of data structures.  This module provides traits and implementations for converting Cairo types into a sequence of <code>felt252</code> values (serialization) and back (deserialization).  When passing values between Cairo and an external environment, serialization and deserialization are necessary to convert Cairo's data types into a sequence of <code>felt252</code> values, as <code>felt252</code> is the fundamental type of the language.  # The <code>Serde</code> Trait  All types that need to be serialized must implement the <code>Serde</code> trait. This includes both simple types that serialize to a single <code>felt252</code> and compound types (like <code>u256</code>) that require multiple <code>felt252</code> values.</p>
<p>Fully qualified path: <code>core::serde</code></p>
<h2 id="modules-6"><a class="header" href="#modules-6">Modules</a></h2>
<ul>
<li><a href="./core-serde-into_felt252_based.html">into_felt252_based</a></li>
</ul>
<h2 id="traits-14"><a class="header" href="#traits-14">Traits</a></h2>
<ul>
<li><a href="./core-serde-Serde.html">Serde</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash"><a class="header" href="#hash">hash</a></h1>
<p>Hash functions.</p>
<p>Fully qualified path: <code>core::hash</code></p>
<h2 id="modules-7"><a class="header" href="#modules-7">Modules</a></h2>
<ul>
<li><a href="./core-hash-into_felt252_based.html">into_felt252_based</a></li>
</ul>
<h2 id="traits-15"><a class="header" href="#traits-15">Traits</a></h2>
<ul>
<li>
<p><a href="./core-hash-HashStateTrait.html">HashStateTrait</a></p>
</li>
<li>
<p><a href="./core-hash-Hash.html">Hash</a></p>
</li>
<li>
<p><a href="./core-hash-LegacyHash.html">LegacyHash</a></p>
</li>
<li>
<p><a href="./core-hash-HashStateExTrait.html">HashStateExTrait</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak"><a class="header" href="#keccak">keccak</a></h1>
<p>Fully qualified path: <code>core::keccak</code></p>
<h2 id="free-functions-7"><a class="header" href="#free-functions-7">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-keccak-keccak_u256s_le_inputs.html">keccak_u256s_le_inputs</a></p>
</li>
<li>
<p><a href="./core-keccak-keccak_u256s_be_inputs.html">keccak_u256s_be_inputs</a></p>
</li>
<li>
<p><a href="./core-keccak-cairo_keccak.html">cairo_keccak</a></p>
</li>
<li>
<p><a href="./core-keccak-compute_keccak_byte_array.html">compute_keccak_byte_array</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha256"><a class="header" href="#sha256">sha256</a></h1>
<p>Implementation of the SHA-256 cryptographic hash function.  This module provides functions to compute SHA-256 hashes of data. The input data can be an array of 32-bit words, or a <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">use core::sha256::compute_sha256_byte_array;

let data = "Hello";
let hash = compute_sha256_byte_array(@data);
assert!(hash == [0x185f8db3, 0x2271fe25, 0xf561a6fc, 0x938b2e26, 0x4306ec30, 0x4eda5180,
0x7d17648, 0x26381969]);
</code></pre>
<p>Fully qualified path: <code>core::sha256</code></p>
<h2 id="free-functions-8"><a class="header" href="#free-functions-8">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-sha256-compute_sha256_u32_array.html">compute_sha256_u32_array</a></p>
</li>
<li>
<p><a href="./core-sha256-compute_sha256_byte_array.html">compute_sha256_byte_array</a></p>
</li>
</ul>
<h2 id="extern-types-9"><a class="header" href="#extern-types-9">Extern types</a></h2>
<ul>
<li><a href="./core-sha256-Sha256StateHandle.html">Sha256StateHandle</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersen"><a class="header" href="#pedersen">pedersen</a></h1>
<p>Pedersen Pedersen hash related traits implementations.  This module provides an implementation of the Pedersen hash function, which is a collision-resistant cryptographic hash function.  The <code>HashState</code> struct represents the state of a Pedersen hash computation. It contains a single <code>felt252</code> field <code>state</code> that holds the current hash value.  The <code>PedersenTrait</code> provides a <code>new</code> method to create a new <code>HashState</code> from a base value.  The <a href="%5B%60HashStateTrait%60%5D"><code>HashStateTrait</code></a> defined in the Hash module provides the <code>update</code> and <code>finalize</code> methods to update the hash state and obtain the final hash value, respectively.   # Examples</p>
<pre><code class="language-cairo">use core::hash::HashStateTrait;
use core::pedersen::PedersenTrait;

let mut state = PedersenTrait::new(0);
state = state.update(1);
state = state.update(2);
let hash = state.finalize();
assert!(hash == 0x07546be9ecb576c12cd00962356afd90b615d8ef50605bc13badfd1fd218c0d5);
</code></pre>
<p>Fully qualified path: <code>core::pedersen</code></p>
<h2 id="structs-5"><a class="header" href="#structs-5">Structs</a></h2>
<ul>
<li><a href="./core-pedersen-HashState.html">HashState</a></li>
</ul>
<h2 id="traits-16"><a class="header" href="#traits-16">Traits</a></h2>
<ul>
<li><a href="./core-pedersen-PedersenTrait.html">PedersenTrait</a></li>
</ul>
<h2 id="impls-7"><a class="header" href="#impls-7">Impls</a></h2>
<ul>
<li><a href="./core-pedersen-PedersenImpl.html">PedersenImpl</a></li>
</ul>
<h2 id="extern-types-10"><a class="header" href="#extern-types-10">Extern types</a></h2>
<ul>
<li><a href="./core-pedersen-Pedersen.html">Pedersen</a></li>
</ul>
<h2 id="extern-functions-8"><a class="header" href="#extern-functions-8">Extern functions</a></h2>
<ul>
<li><a href="./core-pedersen-pedersen.html">pedersen</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon"><a class="header" href="#poseidon">poseidon</a></h1>
<p>Poseidon Poseidon hash related traits implementations and functions.  This module provides cryptographic hash functions based on the Poseidon permutation.  The Poseidon hash function is an arithmetic-friendly hash function optimized for use in zero-knowledge proof systems. This module implements the Poseidon hash using a sponge construction for arbitrary-length inputs.  # Examples</p>
<pre><code class="language-cairo">use core::hash::HashStateTrait;
use core::poseidon::PoseidonTrait;

// Create a new hash state
let mut state = PoseidonTrait::new();

// Update with values
state = state.update(1);
state = state.update(2);

// Finalize to get the hash
let hash = state.finalize();
</code></pre>
<p>Fully qualified path: <code>core::poseidon</code></p>
<h2 id="free-functions-9"><a class="header" href="#free-functions-9">Free functions</a></h2>
<ul>
<li><a href="./core-poseidon-poseidon_hash_span.html">poseidon_hash_span</a></li>
</ul>
<h2 id="structs-6"><a class="header" href="#structs-6">Structs</a></h2>
<ul>
<li><a href="./core-poseidon-HashState.html">HashState</a></li>
</ul>
<h2 id="traits-17"><a class="header" href="#traits-17">Traits</a></h2>
<ul>
<li><a href="./core-poseidon-PoseidonTrait.html">PoseidonTrait</a></li>
</ul>
<h2 id="impls-8"><a class="header" href="#impls-8">Impls</a></h2>
<ul>
<li><a href="./core-poseidon-PoseidonImpl.html">PoseidonImpl</a></li>
</ul>
<h2 id="extern-types-11"><a class="header" href="#extern-types-11">Extern types</a></h2>
<ul>
<li><a href="./core-poseidon-Poseidon.html">Poseidon</a></li>
</ul>
<h2 id="extern-functions-9"><a class="header" href="#extern-functions-9">Extern functions</a></h2>
<ul>
<li><a href="./core-poseidon-hades_permutation.html">hades_permutation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug"><a class="header" href="#debug">debug</a></h1>
<p>Debug. Utilities related to printing of values at runtime. The recommended way of printing values is by using the <code>Display</code> and <code>Debug</code> traits available in the <a href="./core-fmt.html"><code>fmt</code></a> module. The items in this module are not public, and are not recommended to use.</p>
<p>Fully qualified path: <code>core::debug</code></p>
<h2 id="free-functions-10"><a class="header" href="#free-functions-10">Free functions</a></h2>
<ul>
<li><a href="./core-debug-print_byte_array_as_string.html">print_byte_array_as_string</a></li>
</ul>
<h2 id="traits-18"><a class="header" href="#traits-18">Traits</a></h2>
<ul>
<li><a href="./core-debug-PrintTrait.html">PrintTrait</a></li>
</ul>
<h2 id="impls-9"><a class="header" href="#impls-9">Impls</a></h2>
<ul>
<li>
<p><a href="./core-debug-Felt252PrintImpl.html">Felt252PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-BoolPrintImpl.html">BoolPrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-ContractAddressPrintImpl.html">ContractAddressPrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-U8PrintImpl.html">U8PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-U16PrintImpl.html">U16PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-U32PrintImpl.html">U32PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-U64PrintImpl.html">U64PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-U128PrintImpl.html">U128PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-U256PrintImpl.html">U256PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-I8PrintImpl.html">I8PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-I16PrintImpl.html">I16PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-I32PrintImpl.html">I32PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-I64PrintImpl.html">I64PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-I128PrintImpl.html">I128PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-ArrayGenericPrintImpl.html">ArrayGenericPrintImpl</a></p>
</li>
</ul>
<h2 id="extern-functions-10"><a class="header" href="#extern-functions-10">Extern functions</a></h2>
<ul>
<li><a href="./core-debug-print.html">print</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fmt"><a class="header" href="#fmt">fmt</a></h1>
<p>Functionality for formatting values.  The main components of this module are:  - <code>Error</code>: A type representing formatting errors. - <code>Formatter</code>: A struct that holds the configuration and buffer for formatting. - <code>Display</code>: A trait for standard formatting using the empty format ("{}"). - <code>Debug</code>: A trait for debug formatting using the empty format ("{:?}"). - <code>LowerHex</code>: A trait for hex formatting in lower case.  The module includes implementations of the <a href="%5B%60Display%60%5D"><code>Display</code></a>, <a href="%5B%60Debug%60%5D"><code>Debug</code></a> and <a href="%5B%60LowerHex%60%5D"><code>LowerHex</code></a> traits for various types.</p>
<p>Fully qualified path: <code>core::fmt</code></p>
<h2 id="modules-8"><a class="header" href="#modules-8">Modules</a></h2>
<ul>
<li><a href="./core-fmt-into_felt252_based.html">into_felt252_based</a></li>
</ul>
<h2 id="structs-7"><a class="header" href="#structs-7">Structs</a></h2>
<ul>
<li>
<p><a href="./core-fmt-Error.html">Error</a></p>
</li>
<li>
<p><a href="./core-fmt-Formatter.html">Formatter</a></p>
</li>
</ul>
<h2 id="traits-19"><a class="header" href="#traits-19">Traits</a></h2>
<ul>
<li>
<p><a href="./core-fmt-Display.html">Display</a></p>
</li>
<li>
<p><a href="./core-fmt-Debug.html">Debug</a></p>
</li>
<li>
<p><a href="./core-fmt-LowerHex.html">LowerHex</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="starknet"><a class="header" href="#starknet">starknet</a></h1>
<p>Starknet</p>
<p>Fully qualified path: <code>core::starknet</code></p>
<h2 id="modules-9"><a class="header" href="#modules-9">Modules</a></h2>
<ul>
<li>
<p><a href="./core-starknet-storage_access.html">storage_access</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls.html">syscalls</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait.html">secp256_trait</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256k1.html">secp256k1</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256r1.html">secp256r1</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address.html">contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address.html">eth_address</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature.html">eth_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash.html">class_hash</a></p>
</li>
<li>
<p><a href="./core-starknet-event.html">event</a></p>
</li>
<li>
<p><a href="./core-starknet-account.html">account</a></p>
</li>
<li>
<p><a href="./core-starknet-storage.html">storage</a></p>
</li>
<li>
<p><a href="./core-starknet-testing.html">testing</a></p>
</li>
</ul>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<ul>
<li><a href="./core-starknet-VALIDATED.html">VALIDATED</a></li>
</ul>
<h2 id="free-functions-11"><a class="header" href="#free-functions-11">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-info-get_execution_info.html">get_execution_info</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_caller_address.html">get_caller_address</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_contract_address.html">get_contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_block_info.html">get_block_info</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_tx_info.html">get_tx_info</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_block_timestamp.html">get_block_timestamp</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_block_number.html">get_block_number</a></p>
</li>
</ul>
<h2 id="structs-8"><a class="header" href="#structs-8">Structs</a></h2>
<ul>
<li>
<p><a href="./core-starknet-eth_address-EthAddress.html">EthAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-info-v2-ExecutionInfo.html">ExecutionInfo</a></p>
</li>
<li>
<p><a href="./core-starknet-info-BlockInfo.html">BlockInfo</a></p>
</li>
<li>
<p><a href="./core-starknet-info-v2-TxInfo.html">TxInfo</a></p>
</li>
<li>
<p><a href="./core-starknet-info-v2-ResourceBounds.html">ResourceBounds</a></p>
</li>
</ul>
<h2 id="type-aliases-3"><a class="header" href="#type-aliases-3">Type aliases</a></h2>
<ul>
<li><a href="./core-starknet-SyscallResult.html">SyscallResult</a></li>
</ul>
<h2 id="traits-20"><a class="header" href="#traits-20">Traits</a></h2>
<ul>
<li>
<p><a href="./core-starknet-SyscallResultTrait.html">SyscallResultTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-Store.html">Store</a></p>
</li>
<li>
<p><a href="./core-starknet-event-Event.html">Event</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContract.html">AccountContract</a></p>
</li>
</ul>
<h2 id="extern-types-12"><a class="header" href="#extern-types-12">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-starknet-System.html">System</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorageAddress.html">StorageAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-ContractAddress.html">ContractAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-ClassHash.html">ClassHash</a></p>
</li>
</ul>
<h2 id="extern-functions-11"><a class="header" href="#extern-functions-11">Extern functions</a></h2>
<ul>
<li><a href="./core-starknet-contract_address-contract_address_const.html">contract_address_const</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal"><a class="header" href="#internal">internal</a></h1>
<p>Internals.</p>
<p>Fully qualified path: <code>core::internal</code></p>
<h2 id="modules-10"><a class="header" href="#modules-10">Modules</a></h2>
<ul>
<li><a href="./core-internal-bounded_int.html">bounded_int</a></li>
</ul>
<h2 id="enums-6"><a class="header" href="#enums-6">Enums</a></h2>
<ul>
<li><a href="./core-internal-OptionRev.html">OptionRev</a></li>
</ul>
<h2 id="extern-functions-12"><a class="header" href="#extern-functions-12">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-internal-revoke_ap_tracking.html">revoke_ap_tracking</a></p>
</li>
<li>
<p><a href="./core-internal-require_implicit.html">require_implicit</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zeroable"><a class="header" href="#zeroable">zeroable</a></h1>
<p>Zeroable. Types and traits for handling non-zero values and zero checking operations.  This module provides the <a href="./core-zeroable-NonZero.html"><code>NonZero</code></a> wrapper type which guarantees that a value is never zero. The <a href="./core-zeroable-Zeroable.html"><code>Zeroable</code></a> trait is meant for internal use only. The public-facing equivalent is the <a href="%5B%60Zero%60%5D"><code>Zero</code></a> trait.  <a href="%5B%60Zero%60%5D"><code>Zero</code></a>: core::num::traits::zero::Zero</p>
<p>Fully qualified path: <code>core::zeroable</code></p>
<h2 id="modules-11"><a class="header" href="#modules-11">Modules</a></h2>
<ul>
<li><a href="./core-zeroable-zero_based.html">zero_based</a></li>
</ul>
<h2 id="enums-7"><a class="header" href="#enums-7">Enums</a></h2>
<ul>
<li><a href="./core-zeroable-IsZeroResult.html">IsZeroResult</a></li>
</ul>
<h2 id="impl-aliases-1"><a class="header" href="#impl-aliases-1">Impl aliases</a></h2>
<ul>
<li><a href="./core-zeroable-Felt252Zeroable.html">Felt252Zeroable</a></li>
</ul>
<h2 id="traits-21"><a class="header" href="#traits-21">Traits</a></h2>
<ul>
<li><a href="./core-zeroable-Zeroable.html">Zeroable</a></li>
</ul>
<h2 id="impls-10"><a class="header" href="#impls-10">Impls</a></h2>
<ul>
<li><a href="./core-zeroable-NonZeroIntoImpl.html">NonZeroIntoImpl</a></li>
</ul>
<h2 id="extern-types-13"><a class="header" href="#extern-types-13">Extern types</a></h2>
<ul>
<li><a href="./core-zeroable-NonZero.html">NonZero</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes_31"><a class="header" href="#bytes_31">bytes_31</a></h1>
<p>bytes31. Definitions and utilities for the <code>bytes31</code> type.  The <code>bytes31</code> type is a compact, indexable 31-byte type.  # Examples  Creating a <code>bytes31</code> from a <code>felt252</code>:</p>
<pre><code class="language-cairo">let value: bytes31 = 0xaabb.try_into().unwrap();
</code></pre>
<p>Accessing a byte by index:</p>
<pre><code class="language-cairo">assert!(value[0] == 0xbb);
</code></pre>
<p>Fully qualified path: <code>core::bytes_31</code></p>
<h2 id="constants-1"><a class="header" href="#constants-1">Constants</a></h2>
<ul>
<li>
<p><a href="./core-bytes_31-BYTES_IN_BYTES31.html">BYTES_IN_BYTES31</a></p>
</li>
<li>
<p><a href="./core-bytes_31-POW_2_128.html">POW_2_128</a></p>
</li>
<li>
<p><a href="./core-bytes_31-POW_2_8.html">POW_2_8</a></p>
</li>
</ul>
<h2 id="free-functions-12"><a class="header" href="#free-functions-12">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-bytes_31-split_bytes31.html">split_bytes31</a></p>
</li>
<li>
<p><a href="./core-bytes_31-one_shift_left_bytes_felt252.html">one_shift_left_bytes_felt252</a></p>
</li>
<li>
<p><a href="./core-bytes_31-one_shift_left_bytes_u128.html">one_shift_left_bytes_u128</a></p>
</li>
</ul>
<h2 id="traits-22"><a class="header" href="#traits-22">Traits</a></h2>
<ul>
<li><a href="./core-bytes_31-Bytes31Trait.html">Bytes31Trait</a></li>
</ul>
<h2 id="impls-11"><a class="header" href="#impls-11">Impls</a></h2>
<ul>
<li>
<p><a href="./core-bytes_31-Bytes31Impl.html">Bytes31Impl</a></p>
</li>
<li>
<p><a href="./core-bytes_31-Bytes31IndexView.html">Bytes31IndexView</a></p>
</li>
<li>
<p><a href="./core-bytes_31-Bytes31IntoFelt252.html">Bytes31IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-bytes_31-Bytes31IntoU256.html">Bytes31IntoU256</a></p>
</li>
<li>
<p><a href="./core-bytes_31-Felt252TryIntoBytes31.html">Felt252TryIntoBytes31</a></p>
</li>
<li>
<p><a href="./core-bytes_31-U8IntoBytes31.html">U8IntoBytes31</a></p>
</li>
<li>
<p><a href="./core-bytes_31-U128IntoBytes31.html">U128IntoBytes31</a></p>
</li>
</ul>
<h2 id="extern-types-14"><a class="header" href="#extern-types-14">Extern types</a></h2>
<ul>
<li><a href="./core-bytes_31-bytes31.html">bytes31</a></li>
</ul>
<h2 id="extern-functions-13"><a class="header" href="#extern-functions-13">Extern functions</a></h2>
<ul>
<li><a href="./core-bytes_31-bytes31_const.html">bytes31_const</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="byte_array"><a class="header" href="#byte_array">byte_array</a></h1>
<p>BytesArray. <code>ByteArray</code> is designed to handle large sequences of bytes with operations like appending, concatenation, and accessing individual bytes. It uses a structure that combines an <code>Array</code> of <code>bytes31</code> for full words and a <code>felt252</code> for handling partial words, optimizing for both space and performance.  # Examples  There are multiple ways to create a new <code>ByteArray</code>: - From a string literal:</p>
<pre><code class="language-cairo">let s = "Hello";
</code></pre>
<p>Using the <code>format!</code> macro:</p>
<pre><code class="language-cairo">let max_tps:u16 = 850;
let s = format!("Starknet's max TPS is: {}", max_tps);
</code></pre>
<p>You can append bytes to an existing <code>ByteArray</code>  with <a href="%5B%60ByteArrayTrait::append_byte%60%5D"><code>ByteArrayTrait::append_byte</code></a>:</p>
<pre><code class="language-cairo">let mut ba: ByteArray = "";
ba.append_byte(0x41); // Appending a single byte 'A'
</code></pre>
<p>You can create a new <code>ByteArray</code> from an existing one by concatenating with <code>+</code>:</p>
<pre><code class="language-cairo">let s = "Hello";
let message = s + " world!";
</code></pre>
<p>Indexing operations are available on the <code>ByteArray</code> type as well:</p>
<pre><code class="language-cairo">let mut ba: ByteArray = "ABC";
let first_bytes = ba[0]
assert!(first_byte == 0x41);
</code></pre>
<p>Fully qualified path: <code>core::byte_array</code></p>
<h2 id="constants-2"><a class="header" href="#constants-2">Constants</a></h2>
<ul>
<li><a href="./core-byte_array-BYTE_ARRAY_MAGIC.html">BYTE_ARRAY_MAGIC</a></li>
</ul>
<h2 id="structs-9"><a class="header" href="#structs-9">Structs</a></h2>
<ul>
<li><a href="./core-byte_array-ByteArray.html">ByteArray</a></li>
</ul>
<h2 id="traits-23"><a class="header" href="#traits-23">Traits</a></h2>
<ul>
<li><a href="./core-byte_array-ByteArrayTrait.html">ByteArrayTrait</a></li>
</ul>
<h2 id="impls-12"><a class="header" href="#impls-12">Impls</a></h2>
<ul>
<li>
<p><a href="./core-byte_array-ByteArrayStringLiteral.html">ByteArrayStringLiteral</a></p>
</li>
<li>
<p><a href="./core-byte_array-ByteArrayImpl.html">ByteArrayImpl</a></p>
</li>
<li>
<p><a href="./core-byte_array-ByteArrayIndexView.html">ByteArrayIndexView</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">string</a></h1>
<p>String.</p>
<p>Fully qualified path: <code>core::string</code></p>
<h2 id="traits-24"><a class="header" href="#traits-24">Traits</a></h2>
<ul>
<li><a href="./core-string-StringLiteral.html">StringLiteral</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="to_byte_array"><a class="header" href="#to_byte_array">to_byte_array</a></h1>
<p>to_byte_array. ASCII representation of numeric types for <code>ByteArray</code> manipulation.  This module enables conversion of numeric values into their ASCII string representation, with support for different numeric bases and efficient appending to existing <code>ByteArray</code>.  # Examples  Basic decimal formatting:</p>
<pre><code class="language-cairo">use core::to_byte_array::{FormatAsByteArray, AppendFormattedToByteArray};

let value: u32 = 42;
let base: NonZero&lt;u32&gt; = 10;

// Create a new formatted `ByteArray`
let formatted = value.format_as_byte_array(base);
assert!(formatted == "42");

// Append to an existing `ByteArray`
let mut buffer = "Value: ";
value.append_formatted_to_byte_array(ref buffer, base);
assert!(buffer == "Value: 42");
</code></pre>
<p>Custom base formatting:</p>
<pre><code class="language-cairo">use core::to_byte_array::FormatAsByteArray;
let value: u32 = 255;

// Hexadecimal representation
let hex = value.format_as_byte_array(16);
assert!(hex == "ff");

// Binary representation
let bin = value.format_as_byte_array(2);
assert!(bin == "11111111");
</code></pre>
<p>Fully qualified path: <code>core::to_byte_array</code></p>
<h2 id="traits-25"><a class="header" href="#traits-25">Traits</a></h2>
<ul>
<li>
<p><a href="./core-to_byte_array-AppendFormattedToByteArray.html">AppendFormattedToByteArray</a></p>
</li>
<li>
<p><a href="./core-to_byte_array-FormatAsByteArray.html">FormatAsByteArray</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">testing</a></h1>
<p>Module for testing only. Measurement of gas consumption for testing purpose.  This module provides the <code>get_available_gas</code> function, useful for asserting the amount of gas consumed by a particular operation or function call. By calling <code>get_available_gas</code> before and after the operation, you can calculate the exact amount of gas used.</p>
<p>Fully qualified path: <code>core::testing</code></p>
<h2 id="extern-functions-14"><a class="header" href="#extern-functions-14">Extern functions</a></h2>
<ul>
<li><a href="./core-testing-get_available_gas.html">get_available_gas</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metaprogramming"><a class="header" href="#metaprogramming">metaprogramming</a></h1>
<p>Metaprogramming.</p>
<p>Fully qualified path: <code>core::metaprogramming</code></p>
<h2 id="traits-26"><a class="header" href="#traits-26">Traits</a></h2>
<ul>
<li>
<p><a href="./core-metaprogramming-TypeEqual.html">TypeEqual</a></p>
</li>
<li>
<p><a href="./core-metaprogramming-IsTuple.html">IsTuple</a></p>
</li>
<li>
<p><a href="./core-metaprogramming-TupleSplit.html">TupleSplit</a></p>
</li>
<li>
<p><a href="./core-metaprogramming-TupleExtendFront.html">TupleExtendFront</a></p>
</li>
<li>
<p><a href="./core-metaprogramming-TupleSnapForward.html">TupleSnapForward</a></p>
</li>
<li>
<p><a href="./core-metaprogramming-SnapRemove.html">SnapRemove</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prelude"><a class="header" href="#prelude">prelude</a></h1>
<p>Preludes.</p>
<p>Fully qualified path: <code>core::prelude</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iter"><a class="header" href="#iter">iter</a></h1>
<p>Iterators.</p>
<p>Fully qualified path: <code>core::iter</code></p>
<h2 id="traits-27"><a class="header" href="#traits-27">Traits</a></h2>
<ul>
<li>
<p><a href="./core-iter-traits-iterator-Iterator.html">Iterator</a></p>
</li>
<li>
<p><a href="./core-iter-traits-iterator-IntoIterator.html">IntoIterator</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stark_curve"><a class="header" href="#stark_curve">stark_curve</a></h1>
<p>Fully qualified path: <code>core::ec::stark_curve</code></p>
<h2 id="constants-3"><a class="header" href="#constants-3">Constants</a></h2>
<ul>
<li>
<p><a href="./core-ec-stark_curve-ALPHA.html">ALPHA</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-BETA.html">BETA</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-ORDER.html">ORDER</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-GEN_X.html">GEN_X</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-GEN_Y.html">GEN_Y</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="one_based"><a class="header" href="#one_based">one_based</a></h1>
<p>Fully qualified path: <code>core::math::one_based</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-28"><a class="header" href="#traits-28">traits</a></h1>
<p>Fully qualified path: <code>core::num::traits</code></p>
<h2 id="modules-12"><a class="header" href="#modules-12">Modules</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-zero.html">zero</a></p>
</li>
<li>
<p><a href="./core-num-traits-one.html">one</a></p>
</li>
<li>
<p><a href="./core-num-traits-bit_size.html">bit_size</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops.html">ops</a></p>
</li>
</ul>
<h2 id="traits-29"><a class="header" href="#traits-29">Traits</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-zero-Zero.html">Zero</a></p>
</li>
<li>
<p><a href="./core-num-traits-one-One.html">One</a></p>
</li>
<li>
<p><a href="./core-num-traits-bit_size-BitSize.html">BitSize</a></p>
</li>
<li>
<p><a href="./core-num-traits-bounded-Bounded.html">Bounded</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingAdd.html">OverflowingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingSub.html">OverflowingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingMul.html">OverflowingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingAdd.html">WrappingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingSub.html">WrappingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingMul.html">WrappingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedAdd.html">CheckedAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedSub.html">CheckedSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedMul.html">CheckedMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-pow-Pow.html">Pow</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingAdd.html">SaturatingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingSub.html">SaturatingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingMul.html">SaturatingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widemul-WideMul.html">WideMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widesquare-WideSquare.html">WideSquare</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-sqrt-Sqrt.html">Sqrt</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero"><a class="header" href="#zero">zero</a></h1>
<p>Traits for types with an additive identity element.</p>
<p>Fully qualified path: <code>core::num::traits::zero</code></p>
<h2 id="traits-30"><a class="header" href="#traits-30">Traits</a></h2>
<ul>
<li><a href="./core-num-traits-zero-Zero.html">Zero</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="one"><a class="header" href="#one">one</a></h1>
<p>Traits for types with a multiplicative identity element.</p>
<p>Fully qualified path: <code>core::num::traits::one</code></p>
<h2 id="traits-31"><a class="header" href="#traits-31">Traits</a></h2>
<ul>
<li><a href="./core-num-traits-one-One.html">One</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit_size"><a class="header" href="#bit_size">bit_size</a></h1>
<p>Utilities for determining the bit size of types.</p>
<p>Fully qualified path: <code>core::num::traits::bit_size</code></p>
<h2 id="traits-32"><a class="header" href="#traits-32">Traits</a></h2>
<ul>
<li><a href="./core-num-traits-bit_size-BitSize.html">BitSize</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ops-1"><a class="header" href="#ops-1">ops</a></h1>
<p>Fully qualified path: <code>core::num::traits::ops</code></p>
<h2 id="modules-13"><a class="header" href="#modules-13">Modules</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-ops-overflowing.html">overflowing</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping.html">wrapping</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked.html">checked</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating.html">saturating</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-pow.html">pow</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-sqrt.html">sqrt</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widemul.html">widemul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widesquare.html">widesquare</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowing"><a class="header" href="#overflowing">overflowing</a></h1>
<p>Arithmetic operations with overflow detection.  This module provides traits for performing arithmetic operations that explicitly track potential numeric overflow conditions.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing</code></p>
<h2 id="traits-33"><a class="header" href="#traits-33">Traits</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingAdd.html">OverflowingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingSub.html">OverflowingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingMul.html">OverflowingMul</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping"><a class="header" href="#wrapping">wrapping</a></h1>
<p>Arithmetic operations with overflow and underflow wrapping.  This module provides traits for performing arithmetic operations that wrap around at the boundary of the type in case of overflow or underflow. This is particularly useful when you want to: - Perform arithmetic operations without panicking on overflow/underflow - Implement modular arithmetic - Handle cases where overflow is expected and desired  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::{WrappingAdd, WrappingSub, WrappingMul};

// Addition wrapping
let a: u8 = 255;
assert!(a.wrapping_add(1) == 0);

// Subtraction wrapping
let b: u8 = 0;
assert!(b.wrapping_sub(1) == 255);

// Multiplication wrapping
let c: u8 = 200;
assert!(c.wrapping_mul(2) == 144); // (200 * 2) % 256 = 144
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping</code></p>
<h2 id="modules-14"><a class="header" href="#modules-14">Modules</a></h2>
<ul>
<li><a href="./core-num-traits-ops-wrapping-overflow_based.html">overflow_based</a></li>
</ul>
<h2 id="traits-34"><a class="header" href="#traits-34">Traits</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingAdd.html">WrappingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingSub.html">WrappingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingMul.html">WrappingMul</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checked"><a class="header" href="#checked">checked</a></h1>
<p>Fully qualified path: <code>core::num::traits::ops::checked</code></p>
<h2 id="modules-15"><a class="header" href="#modules-15">Modules</a></h2>
<ul>
<li><a href="./core-num-traits-ops-checked-overflow_based.html">overflow_based</a></li>
</ul>
<h2 id="traits-35"><a class="header" href="#traits-35">Traits</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedAdd.html">CheckedAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedSub.html">CheckedSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedMul.html">CheckedMul</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturating"><a class="header" href="#saturating">saturating</a></h1>
<p>Saturating arithmetic operations for numeric types.  This module provides traits and implementations for arithmetic operations that saturate at the numeric type's boundaries instead of overflowing.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating</code></p>
<h2 id="modules-16"><a class="header" href="#modules-16">Modules</a></h2>
<ul>
<li><a href="./core-num-traits-ops-saturating-overflow_based.html">overflow_based</a></li>
</ul>
<h2 id="traits-36"><a class="header" href="#traits-36">Traits</a></h2>
<ul>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingAdd.html">SaturatingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingSub.html">SaturatingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingMul.html">SaturatingMul</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pow"><a class="header" href="#pow">pow</a></h1>
<p>Trait and implementations for raising a value to a power.  This module provides efficient exponentiation operations for numeric types using the square-and-multiply algorithm, which achieves logarithmic time complexity O(log n).</p>
<p>Fully qualified path: <code>core::num::traits::ops::pow</code></p>
<h2 id="traits-37"><a class="header" href="#traits-37">Traits</a></h2>
<ul>
<li><a href="./core-num-traits-ops-pow-Pow.html">Pow</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sqrt"><a class="header" href="#sqrt">sqrt</a></h1>
<p>Square root operation for unsigned numeric types.</p>
<p>Fully qualified path: <code>core::num::traits::ops::sqrt</code></p>
<h2 id="traits-38"><a class="header" href="#traits-38">Traits</a></h2>
<ul>
<li><a href="./core-num-traits-ops-sqrt-Sqrt.html">Sqrt</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widemul"><a class="header" href="#widemul">widemul</a></h1>
<p>Trait for performing multiplication that results in a wider type.  This module provides the <a href="%5B%60WideMul%60%5D"><code>WideMul</code></a> trait which enables multiplication operations that return a result type with double the bit width of the input types. This is particularly useful when you need to perform multiplication without worrying about overflow, as the result type can hold the full range of possible values.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WideMul;

// Multiplying two `u8` values to get a `u16` result
let a: u8 = 200;
let b: u8 = 100;
let result: u16 = a.wide_mul(b);
assert!(result == 20000);

// Multiplying two `u128` values to get a `u256` result
let x: u128 = 0xffffffffffffffffffffffffffffffff; // max u128
let y: u128 = 2;
let wide_result = x.wide_mul(y); // No overflow occurs
assert!(wide_result == 0x01fffffffffffffffffffffffffffffffe);
</code></pre>
<p>Available Implementations  The trait is implemented for the following type pairs: - <code>i8</code> â†’ <code>i16</code> - <code>i16</code> â†’ <code>i32</code> - <code>i32</code> â†’ <code>i64</code> - <code>i64</code> â†’ <code>i128</code> - <code>u8</code> â†’ <code>u16</code> - <code>u16</code> â†’ <code>u32</code> - <code>u32</code> â†’ <code>u64</code> - <code>u64</code> â†’ <code>u128</code> - <code>u128</code> â†’ <code>u256</code> - <code>u256</code> â†’ <code>u512</code></p>
<p>Fully qualified path: <code>core::num::traits::ops::widemul</code></p>
<h2 id="traits-39"><a class="header" href="#traits-39">Traits</a></h2>
<ul>
<li><a href="./core-num-traits-ops-widemul-WideMul.html">WideMul</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widesquare"><a class="header" href="#widesquare">widesquare</a></h1>
<p>Wide square operation.  This module provides the <a href="%5B%60WideSquare%60%5D"><code>WideSquare</code></a> trait which enables squaring operations that return a result type with double the bit width of the input type. This is particularly useful when you need to square a number without worrying about overflow, as the result type can hold the full range of possible values.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WideSquare;

// Squaring a `u8` value to get a `u16` result
let a: u8 = 200;
let result: u16 = a.wide_square();
assert!(result == 40000);

// Squaring a `u128` value to get a `u256` result
let x: u128 = 0xffffffffffffffffffffffffffffffff; // max u128
let wide_result: u256 = x.wide_square(); // No overflow occurs
assert!(wide_result == 0xfffffffffffffffffffffffffffffffe00000000000000000000000000000001);
</code></pre>
<p>Available Implementations  The trait is implemented for the following type pairs: - <code>i8</code> â†’ <code>i16</code> - <code>i16</code> â†’ <code>i32</code> - <code>i32</code> â†’ <code>i64</code> - <code>i64</code> â†’ <code>i128</code> - <code>u8</code> â†’ <code>u16</code> - <code>u16</code> â†’ <code>u32</code> - <code>u32</code> â†’ <code>u64</code> - <code>u64</code> â†’ <code>u128</code> - <code>u128</code> â†’ <code>u256</code> - <code>u256</code> â†’ <code>u512</code></p>
<p>Fully qualified path: <code>core::num::traits::ops::widesquare</code></p>
<h2 id="traits-40"><a class="header" href="#traits-40">Traits</a></h2>
<ul>
<li><a href="./core-num-traits-ops-widesquare-WideSquare.html">WideSquare</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflow_based"><a class="header" href="#overflow_based">overflow_based</a></h1>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::overflow_based</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflow_based-1"><a class="header" href="#overflow_based-1">overflow_based</a></h1>
<p>Fully qualified path: <code>core::num::traits::ops::checked::overflow_based</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflow_based-2"><a class="header" href="#overflow_based-2">overflow_based</a></h1>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::overflow_based</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index"><a class="header" href="#index">index</a></h1>
<p>Fully qualified path: <code>core::ops::index</code></p>
<h2 id="traits-41"><a class="header" href="#traits-41">Traits</a></h2>
<ul>
<li>
<p><a href="./core-ops-index-IndexView.html">IndexView</a></p>
</li>
<li>
<p><a href="./core-ops-index-Index.html">Index</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="into_felt252_based"><a class="header" href="#into_felt252_based">into_felt252_based</a></h1>
<p>Fully qualified path: <code>core::serde::into_felt252_based</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="into_felt252_based-1"><a class="header" href="#into_felt252_based-1">into_felt252_based</a></h1>
<p>Impl for <code>Hash</code> for types that can be converted into <code>felt252</code> using the <code>Into</code> trait. Usage example:</p>
<pre><code class="language-ignore">impl MyTypeHash&lt;S, +HashStateTrait&lt;S&gt;, +Drop&lt;S&gt;&gt; =
    core::hash::into_felt252_based::HashImpl&lt;MyType, S&gt;;`
</code></pre>
<p>Fully qualified path: <code>core::hash::into_felt252_based</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="into_felt252_based-2"><a class="header" href="#into_felt252_based-2">into_felt252_based</a></h1>
<p>Implementations for <code>Debug</code> and <code>LowerHex</code> for types that can be converted into <code>felt252</code> using the <code>Into</code> trait.  # Examples</p>
<pre><code class="language-cairo">impl MyTypeDebug = crate::fmt::into_felt252_based::DebugImpl&lt;MyType&gt;;`
impl MyTypeLowerHex = crate::fmt::into_felt252_based::LowerHexImpl&lt;MyType&gt;;
</code></pre>
<p>Fully qualified path: <code>core::fmt::into_felt252_based</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_access"><a class="header" href="#storage_access">storage_access</a></h1>
<p>Store trait and implementations for various types.</p>
<p>Fully qualified path: <code>core::starknet::storage_access</code></p>
<h2 id="traits-42"><a class="header" href="#traits-42">Traits</a></h2>
<ul>
<li>
<p><a href="./core-starknet-storage_access-Store.html">Store</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorePacking.html">StorePacking</a></p>
</li>
</ul>
<h2 id="extern-types-15"><a class="header" href="#extern-types-15">Extern types</a></h2>
<ul>
<li>
<p><a href="./core-starknet-storage_access-StorageAddress.html">StorageAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorageBaseAddress.html">StorageBaseAddress</a></p>
</li>
</ul>
<h2 id="extern-functions-15"><a class="header" href="#extern-functions-15">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-storage_access-storage_base_address_const.html">storage_base_address_const</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_base_address_from_felt252.html">storage_base_address_from_felt252</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_address_to_felt252.html">storage_address_to_felt252</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_address_from_base_and_offset.html">storage_address_from_base_and_offset</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_address_from_base.html">storage_address_from_base</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_address_try_from_felt252.html">storage_address_try_from_felt252</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syscalls"><a class="header" href="#syscalls">syscalls</a></h1>
<p>Module containing all the extern declaration of the syscalls.</p>
<p>Fully qualified path: <code>core::starknet::syscalls</code></p>
<h2 id="extern-functions-16"><a class="header" href="#extern-functions-16">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-syscalls-call_contract_syscall.html">call_contract_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-deploy_syscall.html">deploy_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-emit_event_syscall.html">emit_event_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_block_hash_syscall.html">get_block_hash_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_execution_info_syscall.html">get_execution_info_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_execution_info_v2_syscall.html">get_execution_info_v2_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-library_call_syscall.html">library_call_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-send_message_to_l1_syscall.html">send_message_to_l1_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-storage_read_syscall.html">storage_read_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-storage_write_syscall.html">storage_write_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-replace_class_syscall.html">replace_class_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_class_hash_at_syscall.html">get_class_hash_at_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-keccak_syscall.html">keccak_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-sha256_process_block_syscall.html">sha256_process_block_syscall</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256_trait"><a class="header" href="#secp256_trait">secp256_trait</a></h1>
<p>secp256</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait</code></p>
<h2 id="free-functions-13"><a class="header" href="#free-functions-13">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-secp256_trait-signature_from_vrs.html">signature_from_vrs</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-is_signature_entry_valid.html">is_signature_entry_valid</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-is_valid_signature.html">is_valid_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-recover_public_key.html">recover_public_key</a></p>
</li>
</ul>
<h2 id="structs-10"><a class="header" href="#structs-10">Structs</a></h2>
<ul>
<li><a href="./core-starknet-secp256_trait-Signature.html">Signature</a></li>
</ul>
<h2 id="traits-43"><a class="header" href="#traits-43">Traits</a></h2>
<ul>
<li>
<p><a href="./core-starknet-secp256_trait-Secp256Trait.html">Secp256Trait</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-Secp256PointTrait.html">Secp256PointTrait</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256k1"><a class="header" href="#secp256k1">secp256k1</a></h1>
<p>Functions and constructs related to elliptic curve operations on the secp256k1 curve.  This module provides functionality for performing operations on the secp256k1 elliptic curve, commonly used in cryptographic applications such as Bitcoin and Ethereum. It implements the traits defined in the <code>secp256_trait</code> module to ensure consistent behavior across different secp256 curve implementations.  Curve information: * Base field: q =   0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f * Scalar field: r =   0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 * Curve equation: y^2 = x^3 + 7</p>
<p>Fully qualified path: <code>core::starknet::secp256k1</code></p>
<h2 id="impls-13"><a class="header" href="#impls-13">Impls</a></h2>
<ul>
<li>
<p><a href="./core-starknet-secp256k1-Secp256k1Impl.html">Secp256k1Impl</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256k1-Secp256k1PointImpl.html">Secp256k1PointImpl</a></p>
</li>
</ul>
<h2 id="extern-types-16"><a class="header" href="#extern-types-16">Extern types</a></h2>
<ul>
<li><a href="./core-starknet-secp256k1-Secp256k1Point.html">Secp256k1Point</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256r1"><a class="header" href="#secp256r1">secp256r1</a></h1>
<p>Functions and constructs related to elliptic curve operations on the secp256r1 curve.  This module provides functionality for performing operations on the NIST P-256 (also known as secp256r1) elliptic curve. It implements the traits defined in the <code>secp256_trait</code> module to ensure consistent behavior across different secp256 curve implementations.  Curve information: * Base field: q =   0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff * Scalar field: r =   0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551 * a = -3 * b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b * Curve equation: y^2 = x^3 + ax + b</p>
<p>Fully qualified path: <code>core::starknet::secp256r1</code></p>
<h2 id="impls-14"><a class="header" href="#impls-14">Impls</a></h2>
<ul>
<li>
<p><a href="./core-starknet-secp256r1-Secp256r1Impl.html">Secp256r1Impl</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256r1-Secp256r1PointImpl.html">Secp256r1PointImpl</a></p>
</li>
</ul>
<h2 id="extern-types-17"><a class="header" href="#extern-types-17">Extern types</a></h2>
<ul>
<li><a href="./core-starknet-secp256r1-Secp256r1Point.html">Secp256r1Point</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract_address"><a class="header" href="#contract_address">contract_address</a></h1>
<p>ContractAddress</p>
<p>Fully qualified path: <code>core::starknet::contract_address</code></p>
<h2 id="impl-aliases-2"><a class="header" href="#impl-aliases-2">Impl aliases</a></h2>
<ul>
<li><a href="./core-starknet-contract_address-ContractAddressZeroable.html">ContractAddressZeroable</a></li>
</ul>
<h2 id="impls-15"><a class="header" href="#impls-15">Impls</a></h2>
<ul>
<li>
<p><a href="./core-starknet-contract_address-Felt252TryIntoContractAddress.html">Felt252TryIntoContractAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-ContractAddressIntoFelt252.html">ContractAddressIntoFelt252</a></p>
</li>
</ul>
<h2 id="extern-types-18"><a class="header" href="#extern-types-18">Extern types</a></h2>
<ul>
<li><a href="./core-starknet-contract_address-ContractAddress.html">ContractAddress</a></li>
</ul>
<h2 id="extern-functions-17"><a class="header" href="#extern-functions-17">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-contract_address-contract_address_const.html">contract_address_const</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-contract_address_to_felt252.html">contract_address_to_felt252</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-contract_address_try_from_felt252.html">contract_address_try_from_felt252</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eth_address"><a class="header" href="#eth_address">eth_address</a></h1>
<p>EthAddress</p>
<p>Fully qualified path: <code>core::starknet::eth_address</code></p>
<h2 id="structs-11"><a class="header" href="#structs-11">Structs</a></h2>
<ul>
<li><a href="./core-starknet-eth_address-EthAddress.html">EthAddress</a></li>
</ul>
<h2 id="impl-aliases-3"><a class="header" href="#impl-aliases-3">Impl aliases</a></h2>
<ul>
<li><a href="./core-starknet-eth_address-EthAddressZeroable.html">EthAddressZeroable</a></li>
</ul>
<h2 id="impls-16"><a class="header" href="#impls-16">Impls</a></h2>
<ul>
<li>
<p><a href="./core-starknet-eth_address-Felt252TryIntoEthAddress.html">Felt252TryIntoEthAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-EthAddressIntoFelt252.html">EthAddressIntoFelt252</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-U256IntoEthAddress.html">U256IntoEthAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-EthAddressSerde.html">EthAddressSerde</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-EthAddressPrintImpl.html">EthAddressPrintImpl</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eth_signature"><a class="header" href="#eth_signature">eth_signature</a></h1>
<p>EthSignature</p>
<p>Fully qualified path: <code>core::starknet::eth_signature</code></p>
<h2 id="free-functions-14"><a class="header" href="#free-functions-14">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-eth_signature-verify_eth_signature.html">verify_eth_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature-is_eth_signature_valid.html">is_eth_signature_valid</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature-public_key_point_to_eth_address.html">public_key_point_to_eth_address</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class_hash"><a class="header" href="#class_hash">class_hash</a></h1>
<p>ClassHash</p>
<p>Fully qualified path: <code>core::starknet::class_hash</code></p>
<h2 id="impl-aliases-4"><a class="header" href="#impl-aliases-4">Impl aliases</a></h2>
<ul>
<li><a href="./core-starknet-class_hash-ClassHashZeroable.html">ClassHashZeroable</a></li>
</ul>
<h2 id="impls-17"><a class="header" href="#impls-17">Impls</a></h2>
<ul>
<li>
<p><a href="./core-starknet-class_hash-Felt252TryIntoClassHash.html">Felt252TryIntoClassHash</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-ClassHashIntoFelt252.html">ClassHashIntoFelt252</a></p>
</li>
</ul>
<h2 id="extern-types-19"><a class="header" href="#extern-types-19">Extern types</a></h2>
<ul>
<li><a href="./core-starknet-class_hash-ClassHash.html">ClassHash</a></li>
</ul>
<h2 id="extern-functions-18"><a class="header" href="#extern-functions-18">Extern functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-class_hash-class_hash_const.html">class_hash_const</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-class_hash_to_felt252.html">class_hash_to_felt252</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-class_hash_try_from_felt252.html">class_hash_try_from_felt252</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event"><a class="header" href="#event">event</a></h1>
<p>Fully qualified path: <code>core::starknet::event</code></p>
<h2 id="traits-44"><a class="header" href="#traits-44">Traits</a></h2>
<ul>
<li>
<p><a href="./core-starknet-event-Event.html">Event</a></p>
</li>
<li>
<p><a href="./core-starknet-event-EventEmitter.html">EventEmitter</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="account"><a class="header" href="#account">account</a></h1>
<p>Account module defining the <a href="%5B%60Call%60%5D"><code>Call</code></a> struct and the <a href="./core-starknet-account-AccountContract.html"><code>AccountContract</code></a> trait.  The <code>Call</code> struct represents a call to a contract, with the following fields: - <code>to</code>: The address of the contract to call. - <code>selector</code>: The entry point selector in the called contract. - <code>calldata</code>: The calldata to pass to the entry point.  The <code>AccountContract</code> trait defines the standard interface for account contracts. It assumes that the calldata for invoke transactions is an <code>Array&lt;Call&gt;</code>, following the SNIP6 standard.  Implementing this trait allows contracts to function as account contracts in the Starknet network, supporting class declarations and batched call execution.</p>
<p>Fully qualified path: <code>core::starknet::account</code></p>
<h2 id="structs-12"><a class="header" href="#structs-12">Structs</a></h2>
<ul>
<li>
<p><a href="./core-starknet-account-Call.html">Call</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractDispatcher.html">AccountContractDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractLibraryDispatcher.html">AccountContractLibraryDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractSafeLibraryDispatcher.html">AccountContractSafeLibraryDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractSafeDispatcher.html">AccountContractSafeDispatcher</a></p>
</li>
</ul>
<h2 id="traits-45"><a class="header" href="#traits-45">Traits</a></h2>
<ul>
<li>
<p><a href="./core-starknet-account-AccountContract.html">AccountContract</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractDispatcherTrait.html">AccountContractDispatcherTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractSafeDispatcherTrait.html">AccountContractSafeDispatcherTrait</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">storage</a></h1>
<p>This module contains the storage-related types and traits for Cairo contracts. It provides abstractions for reading and writing to Starknet storage.  The front facing interface for the user is simple and intuitive, for example consider the following storage struct:</p>
<pre><code class="language-cairo"><span class="boring">[storage]
</span>struct Storage {
    a: felt252,
    b: Map&lt;felt252, felt52&gt;,
    c: Map&lt;felt52, Map&lt;felt52, felt52&gt;&gt;,
}
</code></pre>
<p>The user can access the storage members <code>a</code> and <code>b</code> using the following code:</p>
<pre><code class="language-cairo">fn use_storage(self: @ContractState) {
    let a_value = self.a.read();
    // For a Map, the user can use the `entry` method to access the value at a specific key:
    let b_value = self.b.entry(42).read();
    // Or simply pass the key to the `read` method:
    let b_value = self.b.read(42);
    // Accessing a nested Map must be done using the `entry` method, either:
    let c_value = self.c.entry(42).entry(43).read()
    // Or:
    let c_value = self.c.entry(42).read(43);
}
</code></pre>
<p>Under the hood, the storage access is more complex. The life cycle of a storage object is as follows: 1. The storage struct of a contract is represented by a <code>FlattenedStorage</code> struct, which    can be derefed into a struct containing a member for each storage member of the contract.    This member can be either a <code>StorageBase</code> or a <code>FlattenedStorage</code> instance. Members are    represented as a <code>FlattenedStorage</code> if the storage member is attributed with either    <code>#[substorage(v0)]</code> (for backward compatibility) or <code>#[flat]</code>. <code>FlattenedStorage</code> is used to    structure the storage access; however, it does not affect the address of the storage object. 2. <code>StorageBase</code> members of a <code>FlattenedStorage</code> struct hold a single <code>felt252</code> value, which is    the Keccak hash of the name of the member. For simple types, this value will be the address    of the member in the storage. 3. <code>StorageBase</code> members are then converted to <code>StoragePath</code> instances, which are essentially    a wrapper around a <code>HashState</code> instance, used to account for more values when computing the    address of the storage object. <code>StoragePath</code> instances can be updated with values coming from    two sources:- Storage nodes, which are structs that represent another struct with all its members
in the storage, similar to <code>FlattenedStorage</code>. However, unlike <code>FlattenedStorage</code>, the
path to the storage node does affect the address of the storage object. See <code>StorageNode</code>
for more details.</p>
<ul>
<li>Storage collections, specifically <code>Map</code> and <code>Vec</code>, simulate the behavior of collections by
updating the hash state with the key or index of the collection member.
After finishing the updates, the <code>StoragePath</code> instance is finalized, resulting in a<code>StoragePointer0Offset</code> instance, which is a pointer to the address of the storage object. Ifthe pointer is to an object of size greater than 1, the object is stored in a sequentialmanner starting from the address of the pointer. The whole object can be read or writtenusing <code>read</code> and <code>write</code> methods, and specific members can also be accessed in the case of astruct. See <code>SubPointers</code> for more details.The transitioning between the different types of storage objects is also called from the<code>Deref</code> trait, and thus, allowing an access to the members of the storage object in a simpleway.The types mentioned above are generic in the stored object type. This is done to providespecific behavior for each type of stored object, e.g., a <code>StoragePath</code> of <code>Map</code> type will havean <code>entry</code> method, but it won't have a <code>read</code> or <code>write</code> method, as <code>Map</code> is not storable byitself, only its values are.The generic type of the storage object can also be wrapped with a <code>Mutable</code> type, whichindicates that the storage object is mutable, i.e., it was created from a <code>ref</code> contract state,and thus the object can be written to.</li>
</ul>
<p>Fully qualified path: <code>core::starknet::storage</code></p>
<h2 id="structs-13"><a class="header" href="#structs-13">Structs</a></h2>
<ul>
<li>
<p><a href="./core-starknet-storage-StoragePointer.html">StoragePointer</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointer0Offset.html">StoragePointer0Offset</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePath.html">StoragePath</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-PendingStoragePath.html">PendingStoragePath</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-Mutable.html">Mutable</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-vec-Vec.html">Vec</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-StorageBase.html">StorageBase</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-FlattenedStorage.html">FlattenedStorage</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-Map.html">Map</a></p>
</li>
</ul>
<h2 id="traits-46"><a class="header" href="#traits-46">Traits</a></h2>
<ul>
<li>
<p><a href="./core-starknet-storage-StorageAsPointer.html">StorageAsPointer</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointerReadAccess.html">StoragePointerReadAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointerWriteAccess.html">StoragePointerWriteAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StorageAsPath.html">StorageAsPath</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-PendingStoragePathTrait.html">PendingStoragePathTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-vec-VecTrait.html">VecTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-vec-MutableVecTrait.html">MutableVecTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_node-StorageNode.html">StorageNode</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_node-StorageNodeMut.html">StorageNodeMut</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointers.html">SubPointers</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointersMut.html">SubPointersMut</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointersForward.html">SubPointersForward</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointersMutForward.html">SubPointersMutForward</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-StorageTrait.html">StorageTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-StorageTraitMut.html">StorageTraitMut</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-StorageMapReadAccess.html">StorageMapReadAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-StorageMapWriteAccess.html">StorageMapWriteAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-StoragePathEntry.html">StoragePathEntry</a></p>
</li>
</ul>
<h2 id="impls-18"><a class="header" href="#impls-18">Impls</a></h2>
<ul>
<li><a href="./core-starknet-storage-StorableStoragePointerReadAccess.html">StorableStoragePointerReadAccess</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-1"><a class="header" href="#testing-1">testing</a></h1>
<p>Module for starknet testing only. Provides functions useful for testing event emission, starknet state information, and the cheatcode concept in general. Testing utilities for Starknet contracts.  This module provides functions for testing Starknet contracts. The functions allow manipulation of blockchain state and storage variables during tests, as well as inspection of emitted events and messages.  Note: The functions in this module can only be used with the <code>cairo-test</code> testing framework. If you are using Starknet Foundry, refer to its <a href="%5Bdocumentation%5D(https://foundry-rs.github.io/starknet-foundry/appendix/cheatcodes.html)">https://foundry-rs.github.io/starknet-foundry/appendix/cheatcodes.html</a>.</p>
<p>Fully qualified path: <code>core::starknet::testing</code></p>
<h2 id="free-functions-15"><a class="header" href="#free-functions-15">Free functions</a></h2>
<ul>
<li>
<p><a href="./core-starknet-testing-set_block_number.html">set_block_number</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_caller_address.html">set_caller_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_contract_address.html">set_contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_sequencer_address.html">set_sequencer_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_block_timestamp.html">set_block_timestamp</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_version.html">set_version</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_account_contract_address.html">set_account_contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_max_fee.html">set_max_fee</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_transaction_hash.html">set_transaction_hash</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_chain_id.html">set_chain_id</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_nonce.html">set_nonce</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_signature.html">set_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_block_hash.html">set_block_hash</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-pop_log_raw.html">pop_log_raw</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-pop_log.html">pop_log</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-pop_l2_to_l1_message.html">pop_l2_to_l1_message</a></p>
</li>
</ul>
<h2 id="extern-functions-19"><a class="header" href="#extern-functions-19">Extern functions</a></h2>
<ul>
<li><a href="./core-starknet-testing-cheatcode.html">cheatcode</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounded_int"><a class="header" href="#bounded_int">bounded_int</a></h1>
<p>Fully qualified path: <code>core::internal::bounded_int</code></p>
<h2 id="traits-47"><a class="header" href="#traits-47">Traits</a></h2>
<ul>
<li>
<p><a href="./core-internal-bounded_int-AddHelper.html">AddHelper</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-SubHelper.html">SubHelper</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-MulHelper.html">MulHelper</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-DivRemHelper.html">DivRemHelper</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-ConstrainHelper.html">ConstrainHelper</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-TrimHelper.html">TrimHelper</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-NegateHelper.html">NegateHelper</a></p>
</li>
</ul>
<h2 id="extern-types-20"><a class="header" href="#extern-types-20">Extern types</a></h2>
<ul>
<li><a href="./core-internal-bounded_int-BoundedInt.html">BoundedInt</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero_based"><a class="header" href="#zero_based">zero_based</a></h1>
<p>Provides an implementation of the <code>Zeroable</code> trait for types that implement <code>Zero</code>.</p>
<p>Fully qualified path: <code>core::zeroable::zero_based</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants-4"><a class="header" href="#constants-4">Constants</a></h1>
<ul>
<li>
<p><a href="./core-ec-stark_curve-ALPHA.html">ALPHA</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-BETA.html">BETA</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-ORDER.html">ORDER</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-GEN_X.html">GEN_X</a></p>
</li>
<li>
<p><a href="./core-ec-stark_curve-GEN_Y.html">GEN_Y</a></p>
</li>
<li>
<p><a href="./core-starknet-VALIDATED.html">VALIDATED</a></p>
</li>
<li>
<p><a href="./core-bytes_31-BYTES_IN_BYTES31.html">BYTES_IN_BYTES31</a></p>
</li>
<li>
<p><a href="./core-bytes_31-POW_2_128.html">POW_2_128</a></p>
</li>
<li>
<p><a href="./core-bytes_31-POW_2_8.html">POW_2_8</a></p>
</li>
<li>
<p><a href="./core-byte_array-BYTE_ARRAY_MAGIC.html">BYTE_ARRAY_MAGIC</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alpha"><a class="header" href="#alpha">ALPHA</a></h1>
<p>The STARK Curve is defined by the equation <code>y^2 = x^3 + ALPHA*x + BETA</code>.</p>
<p>Fully qualified path: <code>core::ec::stark_curve::ALPHA</code></p>
<pre><code class="language-rust">pub const ALPHA: felt252 = 1;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beta"><a class="header" href="#beta">BETA</a></h1>
<p>The STARK Curve is defined by the equation <code>y^2 = x^3 + ALPHA*x + BETA</code>.</p>
<p>Fully qualified path: <code>core::ec::stark_curve::BETA</code></p>
<pre><code class="language-rust">pub const BETA: felt252 = 0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="order"><a class="header" href="#order">ORDER</a></h1>
<p>The order (number of points) of the STARK Curve.</p>
<p>Fully qualified path: <code>core::ec::stark_curve::ORDER</code></p>
<pre><code class="language-rust">pub const ORDER: felt252 = 0x800000000000010ffffffffffffffffb781126dcae7b2321e66a241adc64d2f;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gen_x"><a class="header" href="#gen_x">GEN_X</a></h1>
<p>The x coordinate of the generator point used in the ECDSA signature.</p>
<p>Fully qualified path: <code>core::ec::stark_curve::GEN_X</code></p>
<pre><code class="language-rust">pub const GEN_X: felt252 = 0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gen_y"><a class="header" href="#gen_y">GEN_Y</a></h1>
<p>The y coordinate of the generator point used in the ECDSA signature.</p>
<p>Fully qualified path: <code>core::ec::stark_curve::GEN_Y</code></p>
<pre><code class="language-rust">pub const GEN_Y: felt252 = 0x5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validated"><a class="header" href="#validated">VALIDATED</a></h1>
<p>The expected return value of the <code>__validate*__</code> functions of an accounted contract.</p>
<p>Fully qualified path: <code>core::starknet::VALIDATED</code></p>
<pre><code class="language-rust">pub const VALIDATED: felt252 = 'VALID';</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes_in_bytes31"><a class="header" href="#bytes_in_bytes31">BYTES_IN_BYTES31</a></h1>
<p>Fully qualified path: <code>core::bytes_31::BYTES_IN_BYTES31</code></p>
<pre><code class="language-rust">pub(crate) const BYTES_IN_BYTES31: usize = 31;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pow_2_128"><a class="header" href="#pow_2_128">POW_2_128</a></h1>
<p>Fully qualified path: <code>core::bytes_31::POW_2_128</code></p>
<pre><code class="language-rust">pub(crate) const POW_2_128: felt252 = 0x100000000000000000000000000000000;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pow_2_8"><a class="header" href="#pow_2_8">POW_2_8</a></h1>
<p>Fully qualified path: <code>core::bytes_31::POW_2_8</code></p>
<pre><code class="language-rust">pub(crate) const POW_2_8: u128 = 0x100;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="byte_array_magic"><a class="header" href="#byte_array_magic">BYTE_ARRAY_MAGIC</a></h1>
<p>A magic constant for identifying serialization of <code>ByteArray</code> variables. An array of <code>felt252</code> with this magic value as one of the <code>felt252</code> indicates that you should expect right after it a serialized <code>ByteArray</code>. This is currently used mainly for prints and panics.</p>
<p>Fully qualified path: <code>core::byte_array::BYTE_ARRAY_MAGIC</code></p>
<pre><code class="language-rust">pub const BYTE_ARRAY_MAGIC: felt252 =
    0x46a6158a16a947e5916b2a2ca68501a45e93d7110e81aa2d6438b1c57c879a3;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="free-functions-16"><a class="header" href="#free-functions-16">Free functions</a></h1>
<ul>
<li>
<p><a href="./core-panic_with_felt252.html">panic_with_felt252</a></p>
</li>
<li>
<p><a href="./core-assert.html">assert</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_add.html">circuit_add</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_sub.html">circuit_sub</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_inverse.html">circuit_inverse</a></p>
</li>
<li>
<p><a href="./core-circuit-circuit_mul.html">circuit_mul</a></p>
</li>
<li>
<p><a href="./core-ecdsa-check_ecdsa_signature.html">check_ecdsa_signature</a></p>
</li>
<li>
<p><a href="./core-ecdsa-recover_public_key.html">ecdsa::recover_public_key</a></p>
</li>
<li>
<p><a href="./core-integer-u128_wrapping_add.html">u128_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u128_wrapping_sub.html">u128_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u128_wide_mul.html">u128_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u128_overflowing_mul.html">u128_overflowing_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u8_wrapping_add.html">u8_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u8_wrapping_sub.html">u8_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u16_wrapping_add.html">u16_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u16_wrapping_sub.html">u16_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u32_wrapping_add.html">u32_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u32_wrapping_sub.html">u32_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u64_wrapping_add.html">u64_wrapping_add</a></p>
</li>
<li>
<p><a href="./core-integer-u64_wrapping_sub.html">u64_wrapping_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflowing_add.html">u256_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflowing_sub.html">u256_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflow_sub.html">u256_overflow_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflowing_mul.html">u256_overflowing_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u256_overflow_mul.html">u256_overflow_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u256_wide_mul.html">u256_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u128_add_with_bounded_int_carry.html">u128_add_with_bounded_int_carry</a></p>
</li>
<li>
<p><a href="./core-integer-u512_safe_div_rem_by_u256.html">u512_safe_div_rem_by_u256</a></p>
</li>
<li>
<p><a href="./core-math-egcd.html">egcd</a></p>
</li>
<li>
<p><a href="./core-math-inv_mod.html">inv_mod</a></p>
</li>
<li>
<p><a href="./core-math-u256_inv_mod.html">u256_inv_mod</a></p>
</li>
<li>
<p><a href="./core-math-u256_div_mod_n.html">u256_div_mod_n</a></p>
</li>
<li>
<p><a href="./core-math-u256_mul_mod_n.html">u256_mul_mod_n</a></p>
</li>
<li>
<p><a href="./core-cmp-min.html">min</a></p>
</li>
<li>
<p><a href="./core-cmp-max.html">max</a></p>
</li>
<li>
<p><a href="./core-cmp-minmax.html">minmax</a></p>
</li>
<li>
<p><a href="./core-panics-panic_with_byte_array.html">panic_with_byte_array</a></p>
</li>
<li>
<p><a href="./core-keccak-keccak_u256s_le_inputs.html">keccak_u256s_le_inputs</a></p>
</li>
<li>
<p><a href="./core-keccak-keccak_u256s_be_inputs.html">keccak_u256s_be_inputs</a></p>
</li>
<li>
<p><a href="./core-keccak-cairo_keccak.html">cairo_keccak</a></p>
</li>
<li>
<p><a href="./core-keccak-compute_keccak_byte_array.html">compute_keccak_byte_array</a></p>
</li>
<li>
<p><a href="./core-sha256-compute_sha256_u32_array.html">compute_sha256_u32_array</a></p>
</li>
<li>
<p><a href="./core-sha256-compute_sha256_byte_array.html">compute_sha256_byte_array</a></p>
</li>
<li>
<p><a href="./core-poseidon-poseidon_hash_span.html">poseidon_hash_span</a></p>
</li>
<li>
<p><a href="./core-debug-print_byte_array_as_string.html">print_byte_array_as_string</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_execution_info.html">get_execution_info</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_caller_address.html">get_caller_address</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_contract_address.html">get_contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_block_info.html">get_block_info</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_tx_info.html">get_tx_info</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_block_timestamp.html">get_block_timestamp</a></p>
</li>
<li>
<p><a href="./core-starknet-info-get_block_number.html">get_block_number</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-signature_from_vrs.html">signature_from_vrs</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-is_signature_entry_valid.html">is_signature_entry_valid</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-is_valid_signature.html">is_valid_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-recover_public_key.html">starknet::secp256_trait::recover_public_key</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature-verify_eth_signature.html">verify_eth_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature-is_eth_signature_valid.html">is_eth_signature_valid</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_signature-public_key_point_to_eth_address.html">public_key_point_to_eth_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_block_number.html">set_block_number</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_caller_address.html">set_caller_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_contract_address.html">set_contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_sequencer_address.html">set_sequencer_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_block_timestamp.html">set_block_timestamp</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_version.html">set_version</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_account_contract_address.html">set_account_contract_address</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_max_fee.html">set_max_fee</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_transaction_hash.html">set_transaction_hash</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_chain_id.html">set_chain_id</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_nonce.html">set_nonce</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_signature.html">set_signature</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-set_block_hash.html">set_block_hash</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-pop_log_raw.html">pop_log_raw</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-pop_log.html">pop_log</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-pop_l2_to_l1_message.html">pop_l2_to_l1_message</a></p>
</li>
<li>
<p><a href="./core-bytes_31-split_bytes31.html">split_bytes31</a></p>
</li>
<li>
<p><a href="./core-bytes_31-one_shift_left_bytes_felt252.html">one_shift_left_bytes_felt252</a></p>
</li>
<li>
<p><a href="./core-bytes_31-one_shift_left_bytes_u128.html">one_shift_left_bytes_u128</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic_with_felt252"><a class="header" href="#panic_with_felt252">panic_with_felt252</a></h1>
<p>Fully qualified path: <code>core::panic_with_felt252</code></p>
<pre><code class="language-rust">pub fn panic_with_felt252(err_code: felt252) -&gt; never</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert"><a class="header" href="#assert">assert</a></h1>
<p>Fully qualified path: <code>core::assert</code></p>
<pre><code class="language-rust">pub fn assert(cond: bool, err_code: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit_add"><a class="header" href="#circuit_add">circuit_add</a></h1>
<p>Given two circuit elements, returns a new circuit element representing the circuit that applies the <code>addmod</code> operation to the two input circuits.</p>
<p>Fully qualified path: <code>core::circuit::circuit_add</code></p>
<pre><code class="language-rust">pub fn circuit_add&lt;Lhs, Rhs, +CircuitElementTrait&lt;Lhs&gt;, +CircuitElementTrait&lt;Rhs&gt;&gt;(
    lhs: CircuitElement&lt;Lhs&gt;, rhs: CircuitElement&lt;Rhs&gt;,
) -&gt; CircuitElement::&lt;AddModGate&lt;Lhs, Rhs&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit_sub"><a class="header" href="#circuit_sub">circuit_sub</a></h1>
<p>Given two circuit elements, returns a new circuit element representing the circuit that applies the <code>submod</code> operation to the two input circuits.</p>
<p>Fully qualified path: <code>core::circuit::circuit_sub</code></p>
<pre><code class="language-rust">pub fn circuit_sub&lt;Lhs, Rhs, +CircuitElementTrait&lt;Lhs&gt;, +CircuitElementTrait&lt;Rhs&gt;&gt;(
    lhs: CircuitElement&lt;Lhs&gt;, rhs: CircuitElement&lt;Rhs&gt;,
) -&gt; CircuitElement::&lt;SubModGate&lt;Lhs, Rhs&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit_inverse"><a class="header" href="#circuit_inverse">circuit_inverse</a></h1>
<p>Given a circuit element, returns a new circuit element representing the circuit that applies the inverse operation on the input circuit.</p>
<p>Fully qualified path: <code>core::circuit::circuit_inverse</code></p>
<pre><code class="language-rust">pub fn circuit_inverse&lt;Input, +CircuitElementTrait&lt;Input&gt;&gt;(
    input: CircuitElement&lt;Input&gt;,
) -&gt; CircuitElement::&lt;InverseGate&lt;Input&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit_mul"><a class="header" href="#circuit_mul">circuit_mul</a></h1>
<p>Given two circuit elements, returns a new circuit element representing the circuit that applies the <code>mul</code> operation to the two input circuits.</p>
<p>Fully qualified path: <code>core::circuit::circuit_mul</code></p>
<pre><code class="language-rust">pub fn circuit_mul&lt;Lhs, Rhs, +CircuitElementTrait&lt;Lhs&gt;, +CircuitElementTrait&lt;Rhs&gt;&gt;(
    lhs: CircuitElement&lt;Lhs&gt;, rhs: CircuitElement&lt;Rhs&gt;,
) -&gt; CircuitElement::&lt;MulModGate&lt;Lhs, Rhs&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="check_ecdsa_signature"><a class="header" href="#check_ecdsa_signature">check_ecdsa_signature</a></h1>
<p>Checks if (<code>signature_r</code>, <code>signature_s</code>) is a valid ECDSA signature for the given <code>public_key</code> on the given <code>message</code>.  Note: the verification algorithm implemented by this function slightly deviates from the standard ECDSA. While this does not allow to create valid signatures if one does not possess the private key, it means that the signature algorithm used should be modified accordingly. Namely, it should check that <code>r, s &lt; stark_curve::ORDER</code>.  Arguments: * <code>message_hash</code> - the signed message. * <code>public_key</code> - the public key corresponding to the key with which the message was signed. * <code>signature_r</code> - the <code>r</code> component of the ECDSA signature. * <code>signature_s</code> - the <code>s</code> component of the ECDSA signature.  Returns:   <code>true</code> if the signature is valid and <code>false</code> otherwise.</p>
<p>Fully qualified path: <code>core::ecdsa::check_ecdsa_signature</code></p>
<pre><code class="language-rust">pub fn check_ecdsa_signature(
    message_hash: felt252, public_key: felt252, signature_r: felt252, signature_s: felt252,
) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recover_public_key"><a class="header" href="#recover_public_key">recover_public_key</a></h1>
<p>Receives a signature and the signed message hash. Returns the public key associated with the signer.</p>
<p>Fully qualified path: <code>core::ecdsa::recover_public_key</code></p>
<pre><code class="language-rust">pub fn recover_public_key(
    message_hash: felt252, signature_r: felt252, signature_s: felt252, y_parity: bool,
) -&gt; Option&lt;felt252&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_wrapping_add"><a class="header" href="#u128_wrapping_add">u128_wrapping_add</a></h1>
<p>Fully qualified path: <code>core::integer::u128_wrapping_add</code></p>
<pre><code class="language-rust">pub fn u128_wrapping_add(lhs: u128, rhs: u128) -&gt; u128 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_wrapping_sub"><a class="header" href="#u128_wrapping_sub">u128_wrapping_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u128_wrapping_sub</code></p>
<pre><code class="language-rust">pub fn u128_wrapping_sub(a: u128, b: u128) -&gt; u128 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_wide_mul"><a class="header" href="#u128_wide_mul">u128_wide_mul</a></h1>
<p>Multiplies two u128s and returns <code>(high, low)</code> - the 128-bit parts of the result.</p>
<p>Fully qualified path: <code>core::integer::u128_wide_mul</code></p>
<pre><code class="language-rust">pub fn u128_wide_mul(a: u128, b: u128) -&gt; (u128, u128) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_overflowing_mul"><a class="header" href="#u128_overflowing_mul">u128_overflowing_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u128_overflowing_mul</code></p>
<pre><code class="language-rust">pub fn u128_overflowing_mul(lhs: u128, rhs: u128) -&gt; (u128, bool) implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_wrapping_add"><a class="header" href="#u8_wrapping_add">u8_wrapping_add</a></h1>
<p>Fully qualified path: <code>core::integer::u8_wrapping_add</code></p>
<pre><code class="language-rust">pub fn u8_wrapping_add(lhs: u8, rhs: u8) -&gt; u8 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_wrapping_sub"><a class="header" href="#u8_wrapping_sub">u8_wrapping_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u8_wrapping_sub</code></p>
<pre><code class="language-rust">pub fn u8_wrapping_sub(lhs: u8, rhs: u8) -&gt; u8 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_wrapping_add"><a class="header" href="#u16_wrapping_add">u16_wrapping_add</a></h1>
<p>Fully qualified path: <code>core::integer::u16_wrapping_add</code></p>
<pre><code class="language-rust">pub fn u16_wrapping_add(lhs: u16, rhs: u16) -&gt; u16 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_wrapping_sub"><a class="header" href="#u16_wrapping_sub">u16_wrapping_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u16_wrapping_sub</code></p>
<pre><code class="language-rust">pub fn u16_wrapping_sub(lhs: u16, rhs: u16) -&gt; u16 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_wrapping_add"><a class="header" href="#u32_wrapping_add">u32_wrapping_add</a></h1>
<p>Fully qualified path: <code>core::integer::u32_wrapping_add</code></p>
<pre><code class="language-rust">pub fn u32_wrapping_add(lhs: u32, rhs: u32) -&gt; u32 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_wrapping_sub"><a class="header" href="#u32_wrapping_sub">u32_wrapping_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u32_wrapping_sub</code></p>
<pre><code class="language-rust">pub fn u32_wrapping_sub(lhs: u32, rhs: u32) -&gt; u32 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_wrapping_add"><a class="header" href="#u64_wrapping_add">u64_wrapping_add</a></h1>
<p>Fully qualified path: <code>core::integer::u64_wrapping_add</code></p>
<pre><code class="language-rust">pub fn u64_wrapping_add(lhs: u64, rhs: u64) -&gt; u64 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_wrapping_sub"><a class="header" href="#u64_wrapping_sub">u64_wrapping_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u64_wrapping_sub</code></p>
<pre><code class="language-rust">pub fn u64_wrapping_sub(lhs: u64, rhs: u64) -&gt; u64 implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_overflowing_add"><a class="header" href="#u256_overflowing_add">u256_overflowing_add</a></h1>
<p>Fully qualified path: <code>core::integer::u256_overflowing_add</code></p>
<pre><code class="language-rust">pub fn u256_overflowing_add(lhs: u256, rhs: u256) -&gt; (u256, bool) implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_overflowing_sub"><a class="header" href="#u256_overflowing_sub">u256_overflowing_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u256_overflowing_sub</code></p>
<pre><code class="language-rust">pub fn u256_overflowing_sub(lhs: u256, rhs: u256) -&gt; (u256, bool) implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_overflow_sub"><a class="header" href="#u256_overflow_sub">u256_overflow_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u256_overflow_sub</code></p>
<pre><code class="language-rust">pub fn u256_overflow_sub(lhs: u256, rhs: u256) -&gt; (u256, bool) implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_overflowing_mul"><a class="header" href="#u256_overflowing_mul">u256_overflowing_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u256_overflowing_mul</code></p>
<pre><code class="language-rust">pub fn u256_overflowing_mul(lhs: u256, rhs: u256) -&gt; (u256, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_overflow_mul"><a class="header" href="#u256_overflow_mul">u256_overflow_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u256_overflow_mul</code></p>
<pre><code class="language-rust">pub fn u256_overflow_mul(lhs: u256, rhs: u256) -&gt; (u256, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_wide_mul"><a class="header" href="#u256_wide_mul">u256_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u256_wide_mul</code></p>
<pre><code class="language-rust">pub fn u256_wide_mul(a: u256, b: u256) -&gt; u512 nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_add_with_bounded_int_carry"><a class="header" href="#u128_add_with_bounded_int_carry">u128_add_with_bounded_int_carry</a></h1>
<p>Helper function for implementation of <code>u256_wide_mul</code>. Used for adding two u128s and receiving a BoundedInt for the carry result.</p>
<p>Fully qualified path: <code>core::integer::u128_add_with_bounded_int_carry</code></p>
<pre><code class="language-rust">pub(crate) fn u128_add_with_bounded_int_carry(
    a: u128, b: u128,
) -&gt; (u128, crate::internal::bounded_int::BoundedInt&lt;0, 1&gt;) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u512_safe_div_rem_by_u256"><a class="header" href="#u512_safe_div_rem_by_u256">u512_safe_div_rem_by_u256</a></h1>
<p>Calculates division with remainder of a u512 by a non-zero u256.</p>
<p>Fully qualified path: <code>core::integer::u512_safe_div_rem_by_u256</code></p>
<pre><code class="language-rust">pub fn u512_safe_div_rem_by_u256(
    lhs: u512, rhs: NonZero&lt;u256&gt;,
) -&gt; (u512, u256) implicits(RangeCheck) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="egcd"><a class="header" href="#egcd">egcd</a></h1>
<p>Computes the extended GCD and Bezout coefficients for two numbers.  Uses the Extended Euclidean algorithm to find (g, s, t, sub_direction) where <code>g = gcd(a, b)</code>. The relationship between inputs and outputs is: * If <code>sub_direction</code> is true:  <code>g = s * a - t * b</code> * If <code>sub_direction</code> is false: <code>g = t * b - s * a</code>  Returns a tuple (g, s, t, sub_direction) where g is the GCD and <code>(s, -t)</code> or <code>(-s, t)</code> are the Bezout coefficients (according to <code>sub_direction</code>).  # Examples</p>
<pre><code class="language-cairo">use core::math::egcd;

let (g, s, t, dir) = egcd::&lt;u32&gt;(12, 8);
assert!(g == 4);
</code></pre>
<p>Fully qualified path: <code>core::math::egcd</code></p>
<pre><code class="language-rust">pub fn egcd&lt;
    T,
    +Copy&lt;T&gt;,
    +Drop&lt;T&gt;,
    +Add&lt;T&gt;,
    +Mul&lt;T&gt;,
    +DivRem&lt;T&gt;,
    +core::num::traits::Zero&lt;T&gt;,
    +core::num::traits::One&lt;T&gt;,
    +TryInto&lt;T, NonZero&lt;T&gt;&gt;,
&gt;(
    a: NonZero&lt;T&gt;, b: NonZero&lt;T&gt;,
) -&gt; (T, T, T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inv_mod"><a class="header" href="#inv_mod">inv_mod</a></h1>
<p>Computes the modular multiplicative inverse of <code>a</code> modulo <code>n</code>.  Returns <code>s</code> such that <code>a*s â‰¡ 1 (mod n)</code> where <code>s</code> is between <code>1</code> and <code>n-1</code> inclusive, or <code>Option::None</code> if <code>gcd(a,n) &gt; 1</code> (inverse doesn't exist).  # Examples</p>
<pre><code class="language-cairo">use core::math::inv_mod;

let inv = inv_mod::&lt;u32&gt;(3, 7);
assert!(inv == Option::Some(5));
</code></pre>
<p>Fully qualified path: <code>core::math::inv_mod</code></p>
<pre><code class="language-rust">pub fn inv_mod&lt;
    T,
    +Copy&lt;T&gt;,
    +Drop&lt;T&gt;,
    +Add&lt;T&gt;,
    +Sub&lt;T&gt;,
    +Mul&lt;T&gt;,
    +DivRem&lt;T&gt;,
    +core::num::traits::Zero&lt;T&gt;,
    +core::num::traits::One&lt;T&gt;,
    +TryInto&lt;T, NonZero&lt;T&gt;&gt;,
&gt;(
    a: NonZero&lt;T&gt;, n: NonZero&lt;T&gt;,
) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_inv_mod"><a class="header" href="#u256_inv_mod">u256_inv_mod</a></h1>
<p>Returns the inverse of <code>a</code> modulo <code>n</code>, or <code>None</code> if <code>a</code> is not invertible modulo <code>n</code>.  All <code>a</code>s will be considered not invertible for <code>n == 1</code>.  # Examples</p>
<pre><code class="language-cairo">use core::math::u256_inv_mod;

let inv = u256_inv_mod(3, 17);
assert!(inv == Option::Some(6));
</code></pre>
<p>Fully qualified path: <code>core::math::u256_inv_mod</code></p>
<pre><code class="language-rust">pub fn u256_inv_mod(a: u256, n: NonZero&lt;u256&gt;) -&gt; Option&lt;NonZero&lt;u256&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_div_mod_n"><a class="header" href="#u256_div_mod_n">u256_div_mod_n</a></h1>
<p>Returns <code>a / b (mod n)</code>, or <code>None</code> if <code>b</code> is not invertible modulo <code>n</code>.  # Examples</p>
<pre><code class="language-cairo">use core::math::u256_inv_mod;

let result = u256_div_mod_n(17, 7, 29);
assert!(result == Option::Some(19));
</code></pre>
<p>Fully qualified path: <code>core::math::u256_div_mod_n</code></p>
<pre><code class="language-rust">pub fn u256_div_mod_n(a: u256, b: u256, n: NonZero&lt;u256&gt;) -&gt; Option&lt;u256&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_mul_mod_n"><a class="header" href="#u256_mul_mod_n">u256_mul_mod_n</a></h1>
<p>Returns <code>a * b (mod n)</code>.  # Examples</p>
<pre><code class="language-cairo">use core::math::u256_mul_mod_n;

let result = u256_mul_mod_n(17, 23, 29);
assert!(result == 14);
</code></pre>
<p>Fully qualified path: <code>core::math::u256_mul_mod_n</code></p>
<pre><code class="language-rust">pub fn u256_mul_mod_n(a: u256, b: u256, n: NonZero&lt;u256&gt;) -&gt; u256</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="min"><a class="header" href="#min">min</a></h1>
<p>Takes two comparable values <code>a</code> and <code>b</code> and returns the smallest of the two values.  # Examples</p>
<pre><code class="language-cairo">use core::cmp::min;

assert!(min(0, 1) == 0);
</code></pre>
<p>Fully qualified path: <code>core::cmp::min</code></p>
<pre><code class="language-rust">pub fn min&lt;T, +PartialOrd&lt;T&gt;, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt;(a: T, b: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="max"><a class="header" href="#max">max</a></h1>
<p>Takes two comparable values <code>a</code> and <code>b</code> and returns the greatest of the two values.  # Examples</p>
<pre><code class="language-cairo">use core::cmp::max;

assert!(max(0, 1) == 1);
</code></pre>
<p>Fully qualified path: <code>core::cmp::max</code></p>
<pre><code class="language-rust">pub fn max&lt;T, +PartialOrd&lt;T&gt;, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt;(a: T, b: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minmax"><a class="header" href="#minmax">minmax</a></h1>
<p>Takes two comparable values <code>a</code> and <code>b</code> and returns a tuple with the smallest value and the greatest value.  # Examples</p>
<pre><code class="language-cairo">use core::cmp::minmax;

assert!(minmax(0, 1) == (0, 1));
assert!(minmax(1, 0) == (0, 1));
</code></pre>
<p>Fully qualified path: <code>core::cmp::minmax</code></p>
<pre><code class="language-rust">pub fn minmax&lt;T, +PartialOrd&lt;T&gt;, +Drop&lt;T&gt;, +Copy&lt;T&gt;&gt;(a: T, b: T) -&gt; (T, T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic_with_byte_array"><a class="header" href="#panic_with_byte_array">panic_with_byte_array</a></h1>
<p>Panics with a <code>ByteArray</code> message.  Constructs a panic message by prepending the <code>BYTE_ARRAY_MAGIC</code> value and serializing the provided <code>ByteArray</code> into the panic data.  # Examples</p>
<pre><code class="language-cairo">use core::panics::panic_with_byte_array;

let error_msg = "An error occurred";
panic_with_byte_array(@error_msg);
</code></pre>
<p>Fully qualified path: <code>core::panics::panic_with_byte_array</code></p>
<pre><code class="language-rust">pub fn panic_with_byte_array(err: @ByteArray) -&gt; crate::never</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak_u256s_le_inputs"><a class="header" href="#keccak_u256s_le_inputs">keccak_u256s_le_inputs</a></h1>
<p>Computes the keccak256 of multiple u256 values. The input values are interpreted as little-endian. The 32-byte result is represented as a little-endian u256.</p>
<p>Fully qualified path: <code>core::keccak::keccak_u256s_le_inputs</code></p>
<pre><code class="language-rust">pub fn keccak_u256s_le_inputs(mut input: Span&lt;u256&gt;) -&gt; u256</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak_u256s_be_inputs"><a class="header" href="#keccak_u256s_be_inputs">keccak_u256s_be_inputs</a></h1>
<p>Computes the keccak256 of multiple u256 values. The input values are interpreted as big-endian. The 32-byte result is represented as a little-endian u256.</p>
<p>Fully qualified path: <code>core::keccak::keccak_u256s_be_inputs</code></p>
<pre><code class="language-rust">pub fn keccak_u256s_be_inputs(mut input: Span&lt;u256&gt;) -&gt; u256</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo_keccak"><a class="header" href="#cairo_keccak">cairo_keccak</a></h1>
<p>Computes the keccak of <code>input</code> + <code>last_input_num_bytes</code> LSB bytes of <code>last_input_word</code>. To use this function, split the input into words of 64 bits (little endian). For example, to compute keccak('Hello world!'), use:   inputs = [8031924123371070792, 560229490]([8031924123371070792, 560229490]) where:   8031924123371070792 == int.from_bytes(b'Hello wo', 'little')   560229490 == int.from_bytes(b'rld!', 'little')  Returns the hash as a little endian u256.</p>
<p>Fully qualified path: <code>core::keccak::cairo_keccak</code></p>
<pre><code class="language-rust">pub fn cairo_keccak(
    ref input: Array&lt;u64&gt;, last_input_word: u64, last_input_num_bytes: usize,
) -&gt; u256</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compute_keccak_byte_array"><a class="header" href="#compute_keccak_byte_array">compute_keccak_byte_array</a></h1>
<p>Computes the Keccak hash of the input ByteArray.  Returns the hash as a little endian u256.</p>
<p>Fully qualified path: <code>core::keccak::compute_keccak_byte_array</code></p>
<pre><code class="language-rust">pub fn compute_keccak_byte_array(arr: @ByteArray) -&gt; u256</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compute_sha256_u32_array"><a class="header" href="#compute_sha256_u32_array">compute_sha256_u32_array</a></h1>
<p>Computes the SHA-256 hash of an array of 32-bit words.  # Arguments  * <code>input</code> - An array of <code>u32</code> values to hash * <code>last_input_word</code> - The final word when input is not word-aligned * <code>last_input_num_bytes</code> - Number of bytes in the last input word (must be less than 4)  # Returns  * The SHA-256 hash of the <code>input array</code> + <code>last_input_word</code> as big endian  # Examples</p>
<pre><code class="language-cairo">use core::sha256::compute_sha256_u32_array;

let hash = compute_sha256_u32_array(array![0x68656c6c], 0x6f, 1);
assert!(hash == [0x2cf24dba, 0x5fb0a30e, 0x26e83b2a, 0xc5b9e29e, 0x1b161e5c, 0x1fa7425e,
0x73043362, 0x938b9824]);
</code></pre>
<p>Fully qualified path: <code>core::sha256::compute_sha256_u32_array</code></p>
<pre><code class="language-rust">pub fn compute_sha256_u32_array(
    mut input: Array&lt;u32&gt;, last_input_word: u32, last_input_num_bytes: u32,
) -&gt; [u32; 8]</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compute_sha256_byte_array"><a class="header" href="#compute_sha256_byte_array">compute_sha256_byte_array</a></h1>
<p>Computes the SHA-256 hash of the input <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">use core::sha256::compute_sha256_byte_array;

</code></pre>
<p>Fully qualified path: <code>core::sha256::compute_sha256_byte_array</code></p>
<pre><code class="language-rust">pub fn compute_sha256_byte_array(arr: @ByteArray) -&gt; [u32; 8]</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon_hash_span"><a class="header" href="#poseidon_hash_span">poseidon_hash_span</a></h1>
<p>Computes the Poseidon hash on the given span input. Applies the sponge construction to digest many elements. To distinguish between use cases, the capacity element is initialized to 0. To distinguish between different input sizes always pads with 1, and possibly with another 0 to complete to an even-sized input.  # Examples</p>
<pre><code class="language-cairo">let span = [1, 2].span();
let hash = poseidon_hash_span(span);

assert!(hash == 0x0371cb6995ea5e7effcd2e174de264b5b407027a75a231a70c2c8d196107f0e7);
</code></pre>
<p>Fully qualified path: <code>core::poseidon::poseidon_hash_span</code></p>
<pre><code class="language-rust">pub fn poseidon_hash_span(mut span: Span&lt;felt252&gt;) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="print_byte_array_as_string"><a class="header" href="#print_byte_array_as_string">print_byte_array_as_string</a></h1>
<p>Prints a <code>ByteArray</code> as a string.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "123";
print_byte_array_as_string(@ba);
</code></pre>
<p>Fully qualified path: <code>core::debug::print_byte_array_as_string</code></p>
<pre><code class="language-rust">pub fn print_byte_array_as_string(self: @ByteArray)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_execution_info"><a class="header" href="#get_execution_info">get_execution_info</a></h1>
<p>Returns the execution info for the current execution.</p>
<p>Fully qualified path: <code>core::starknet::info::get_execution_info</code></p>
<pre><code class="language-rust">pub fn get_execution_info() -&gt; Box&lt;v2::ExecutionInfo&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_caller_address"><a class="header" href="#get_caller_address">get_caller_address</a></h1>
<p>Returns the address of the caller contract.  See <code>ExecutionInfo.caller_address</code> for more information.</p>
<p>Fully qualified path: <code>core::starknet::info::get_caller_address</code></p>
<pre><code class="language-rust">pub fn get_caller_address() -&gt; ContractAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_contract_address"><a class="header" href="#get_contract_address">get_contract_address</a></h1>
<p>Returns the address of the contract being executed.  See <code>ExecutionInfo.contract_address</code> for more information.</p>
<p>Fully qualified path: <code>core::starknet::info::get_contract_address</code></p>
<pre><code class="language-rust">pub fn get_contract_address() -&gt; ContractAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_block_info"><a class="header" href="#get_block_info">get_block_info</a></h1>
<p>Returns the block info for the current block.</p>
<p>Fully qualified path: <code>core::starknet::info::get_block_info</code></p>
<pre><code class="language-rust">pub fn get_block_info() -&gt; Box&lt;BlockInfo&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_tx_info"><a class="header" href="#get_tx_info">get_tx_info</a></h1>
<p>Returns the transaction info for the current transaction.</p>
<p>Fully qualified path: <code>core::starknet::info::get_tx_info</code></p>
<pre><code class="language-rust">pub fn get_tx_info() -&gt; Box&lt;v2::TxInfo&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_block_timestamp"><a class="header" href="#get_block_timestamp">get_block_timestamp</a></h1>
<p>Returns the timestamp of the current block.</p>
<p>Fully qualified path: <code>core::starknet::info::get_block_timestamp</code></p>
<pre><code class="language-rust">pub fn get_block_timestamp() -&gt; u64</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_block_number"><a class="header" href="#get_block_number">get_block_number</a></h1>
<p>Returns the number of the current block.</p>
<p>Fully qualified path: <code>core::starknet::info::get_block_number</code></p>
<pre><code class="language-rust">pub fn get_block_number() -&gt; u64</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signature_from_vrs"><a class="header" href="#signature_from_vrs">signature_from_vrs</a></h1>
<p>Creates an ECDSA signature from the <code>v</code>, <code>r</code> and <code>s</code> values. <code>v</code> is the sum of an odd number and the parity of the y coordinate of the ec point whose x coordinate is <code>r</code>. See https://eips.ethereum.org/EIPS/eip-155 for more details.</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait::signature_from_vrs</code></p>
<pre><code class="language-rust">pub fn signature_from_vrs(v: u32, r: u256, s: u256) -&gt; Signature</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="is_signature_entry_valid"><a class="header" href="#is_signature_entry_valid">is_signature_entry_valid</a></h1>
<p>Checks whether <code>value</code> is in the range [1, N), where N is the size of the curve.</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait::is_signature_entry_valid</code></p>
<pre><code class="language-rust">pub fn is_signature_entry_valid&lt;
    Secp256Point, +Drop&lt;Secp256Point&gt;, impl Secp256Impl: Secp256Trait&lt;Secp256Point&gt;,
&gt;(
    value: u256,
) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="is_valid_signature"><a class="header" href="#is_valid_signature">is_valid_signature</a></h1>
<p>Fully qualified path: <code>core::starknet::secp256_trait::is_valid_signature</code></p>
<pre><code class="language-rust">pub fn is_valid_signature&lt;
    Secp256Point,
    +Drop&lt;Secp256Point&gt;,
    impl Secp256Impl: Secp256Trait&lt;Secp256Point&gt;,
    +Secp256PointTrait&lt;Secp256Point&gt;,
&gt;(
    msg_hash: u256, r: u256, s: u256, public_key: Secp256Point,
) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recover_public_key-1"><a class="header" href="#recover_public_key-1">recover_public_key</a></h1>
<p>Receives a signature and the signed message hash. Returns the public key associated with the signer, represented as a point on the curve.</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait::recover_public_key</code></p>
<pre><code class="language-rust">pub fn recover_public_key&lt;
    Secp256Point,
    +Drop&lt;Secp256Point&gt;,
    impl Secp256Impl: Secp256Trait&lt;Secp256Point&gt;,
    +Secp256PointTrait&lt;Secp256Point&gt;,
&gt;(
    msg_hash: u256, signature: Signature,
) -&gt; Option&lt;Secp256Point&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verify_eth_signature"><a class="header" href="#verify_eth_signature">verify_eth_signature</a></h1>
<p>Asserts that an Ethereum signature is valid w.r.t. a given Eth address Also verifies that r and s components of the signature are in the range (0, N), where N is the size of the curve.</p>
<p>Fully qualified path: <code>core::starknet::eth_signature::verify_eth_signature</code></p>
<pre><code class="language-rust">pub fn verify_eth_signature(msg_hash: u256, signature: Signature, eth_address: EthAddress)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="is_eth_signature_valid"><a class="header" href="#is_eth_signature_valid">is_eth_signature_valid</a></h1>
<p>Asserts that an Ethereum signature is valid w.r.t. a given Eth address Also verifies that r and s components of the signature are in the range (0, N), where N is the size of the curve. Returns a Result with an error string if the signature is invalid.</p>
<p>Fully qualified path: <code>core::starknet::eth_signature::is_eth_signature_valid</code></p>
<pre><code class="language-rust">pub fn is_eth_signature_valid(
    msg_hash: u256, signature: Signature, eth_address: EthAddress,
) -&gt; Result&lt;(), felt252&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="public_key_point_to_eth_address"><a class="header" href="#public_key_point_to_eth_address">public_key_point_to_eth_address</a></h1>
<p>Converts a public key point to the corresponding Ethereum address.</p>
<p>Fully qualified path: <code>core::starknet::eth_signature::public_key_point_to_eth_address</code></p>
<pre><code class="language-rust">pub fn public_key_point_to_eth_address&lt;
    Secp256Point,
    +Drop&lt;Secp256Point&gt;,
    +Secp256Trait&lt;Secp256Point&gt;,
    +Secp256PointTrait&lt;Secp256Point&gt;,
&gt;(
    public_key_point: Secp256Point,
) -&gt; EthAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_block_number"><a class="header" href="#set_block_number">set_block_number</a></h1>
<p>Sets the block number to the provided value.  # Arguments  <code>block_number</code> - The block number to set.  After a call to <code>set_block_number</code>, <code>starknet::get_execution_info().block_info.block_number</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_block_number</code></p>
<pre><code class="language-rust">pub fn set_block_number(block_number: u64)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_caller_address"><a class="header" href="#set_caller_address">set_caller_address</a></h1>
<p>Sets the caller address to the provided value.  # Arguments  <code>address</code> - The caller address to set.  After a call to <code>set_caller_address</code>, <code>starknet::get_execution_info().caller_address</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_caller_address</code></p>
<pre><code class="language-rust">pub fn set_caller_address(address: ContractAddress)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_contract_address"><a class="header" href="#set_contract_address">set_contract_address</a></h1>
<p>Sets the contract address to the provided value.  # Arguments  <code>address</code> - The contract address to set.  After a call to <code>set_contract_address</code>, <code>starknet::get_execution_info().contract_address</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_contract_address</code></p>
<pre><code class="language-rust">pub fn set_contract_address(address: ContractAddress)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_sequencer_address"><a class="header" href="#set_sequencer_address">set_sequencer_address</a></h1>
<p>Sets the sequencer address to the provided value.  # Arguments  <code>address</code> - The sequencer address to set.  After a call to <code>set_sequencer_address</code>, <code>starknet::get_execution_info().block_info.sequencer_address</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_sequencer_address</code></p>
<pre><code class="language-rust">pub fn set_sequencer_address(address: ContractAddress)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_block_timestamp"><a class="header" href="#set_block_timestamp">set_block_timestamp</a></h1>
<p>Sets the block timestamp to the provided value.  # Arguments  <code>block_timestamp</code> - The block timestamp to set.  After a call to <code>set_block_timestamp</code>, <code>starknet::get_execution_info().block_info.block_timestamp</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_block_timestamp</code></p>
<pre><code class="language-rust">pub fn set_block_timestamp(block_timestamp: u64)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_version"><a class="header" href="#set_version">set_version</a></h1>
<p>Sets the version to the provided value.  # Arguments  <code>version</code> - The version to set.  After a call to <code>set_version</code>, <code>starknet::get_execution_info().tx_info.version</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_version</code></p>
<pre><code class="language-rust">pub fn set_version(version: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_account_contract_address"><a class="header" href="#set_account_contract_address">set_account_contract_address</a></h1>
<p>Sets the account contract address.  # Arguments  <code>address</code> - The account contract to set.  After a call to <code>set_account_contract_address</code>, <code>starknet::get_execution_info().tx_info.account_contract_address</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_account_contract_address</code></p>
<pre><code class="language-rust">pub fn set_account_contract_address(address: ContractAddress)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_max_fee"><a class="header" href="#set_max_fee">set_max_fee</a></h1>
<p>Sets the transaction max fee.  # Arguments  <code>fee</code> - The max fee to set.  After a call to <code>set_max_fee</code>, <code>starknet::get_execution_info().tx_info.max_fee</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_max_fee</code></p>
<pre><code class="language-rust">pub fn set_max_fee(fee: u128)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_transaction_hash"><a class="header" href="#set_transaction_hash">set_transaction_hash</a></h1>
<p>Sets the transaction hash.  # Arguments  <code>hash</code> - The transaction hash to set.  After a call to <code>set_transaction_hash</code>, <code>starknet::get_execution_info().tx_info.transaction_hash</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_transaction_hash</code></p>
<pre><code class="language-rust">pub fn set_transaction_hash(hash: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_chain_id"><a class="header" href="#set_chain_id">set_chain_id</a></h1>
<p>Set the transaction chain id.  # Arguments  <code>chain_id</code> - The chain id to set.  After a call to <code>set_chain_id</code>, <code>starknet::get_execution_info().tx_info.chain_id</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_chain_id</code></p>
<pre><code class="language-rust">pub fn set_chain_id(chain_id: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_nonce"><a class="header" href="#set_nonce">set_nonce</a></h1>
<p>Set the transaction nonce.  # Arguments  <code>non</code> - The nonce to set.  After a call to <code>set_nonce</code>, <code>starknet::get_execution_info().tx_info.nonce</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_nonce</code></p>
<pre><code class="language-rust">pub fn set_nonce(nonce: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_signature"><a class="header" href="#set_signature">set_signature</a></h1>
<p>Set the transaction signature.  # Arguments  <code>signature</code> - The signature to set.  After a call to <code>set_signature</code>, <code>starknet::get_execution_info().tx_info.signature</code> will return the set value.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_signature</code></p>
<pre><code class="language-rust">pub fn set_signature(signature: Span&lt;felt252&gt;)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set_block_hash"><a class="header" href="#set_block_hash">set_block_hash</a></h1>
<p>Set the hash for a block.  # Arguments  <code>block_number</code> - The targeted block number. <code>value</code> - The block hash to set.  After a call to <code>set_block_hash</code>, <code>starknet::syscalls::get_block_hash_syscall</code> for the block_number will return the set value. Unset blocks values call would fail.</p>
<p>Fully qualified path: <code>core::starknet::testing::set_block_hash</code></p>
<pre><code class="language-rust">pub fn set_block_hash(block_number: u64, value: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pop_log_raw"><a class="header" href="#pop_log_raw">pop_log_raw</a></h1>
<p>Pop the earliest unpopped logged event for the contract.  # Arguments  <code>address</code> - The contract address from which to pop an event.  The value is returned as a tuple of two spans, the first for the keys and the second for the data. May be called multiple times to pop multiple events. If called until <code>None</code> is returned, all events have been popped.</p>
<p>Fully qualified path: <code>core::starknet::testing::pop_log_raw</code></p>
<pre><code class="language-rust">pub fn pop_log_raw(address: ContractAddress) -&gt; Option&lt;(Span&lt;felt252&gt;, Span&lt;felt252&gt;)&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pop_log"><a class="header" href="#pop_log">pop_log</a></h1>
<p>Pop the earliest unpopped logged event for the contract as the requested type.  # Arguments  <code>address</code> - The contract address from which to pop an event.  Should be used when the type of the event is known. Type of the event should be the event defined within the contract. Useful for testing the contract's event emission. May be called multiple times to pop multiple events. If called until <code>None</code> is returned, all events have been popped.  # Examples</p>
<pre><code class="language-cairo"><span class="boring">[starknet::contract]
</span>mod contract {
<span class="boring">   [event]
</span><span class="boring">   [derive(Copy, Drop, Debug, PartialEq, starknet::Event)]
</span>   pub enum Event {
      Event1: felt252,
      Event2: u128,
   }
   ...
}

<span class="boring">[test]
</span>fn test_event() {
    let contract_address = somehow_get_contract_address();
    call_code_causing_events(contract_address);
    assert_eq!(
        starknet::testing::pop_log(contract_address), Option::Some(contract::Event::Event1(42))
    );
    assert_eq!(
        starknet::testing::pop_log(contract_address), Option::Some(contract::Event::Event2(41))
    );
    assert_eq!(
        starknet::testing::pop_log(contract_address), Option::Some(contract::Event::Event1(40))
    );
    assert_eq!(starknet::testing::pop_log_raw(contract_address), Option::None);
}
</code></pre>
<p>Fully qualified path: <code>core::starknet::testing::pop_log</code></p>
<pre><code class="language-rust">pub fn pop_log&lt;T, +starknet::Event&lt;T&gt;&gt;(address: ContractAddress) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pop_l2_to_l1_message"><a class="header" href="#pop_l2_to_l1_message">pop_l2_to_l1_message</a></h1>
<p>Pop the earliest unpopped l2 to l1 message for the contract.  # Arguments  <code>address</code> - The contract address from which to pop a l2-L1 message.  The returned value is a tuple of the l1 address the message was sent to as a <code>felt252</code>, and the message data as a span. May be called multiple times to pop multiple messages. Useful for testing the contract's l2 to l1 message emission.</p>
<p>Fully qualified path: <code>core::starknet::testing::pop_l2_to_l1_message</code></p>
<pre><code class="language-rust">pub fn pop_l2_to_l1_message(address: ContractAddress) -&gt; Option&lt;(felt252, Span&lt;felt252&gt;)&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="split_bytes31"><a class="header" href="#split_bytes31">split_bytes31</a></h1>
<p>Splits a <code>bytes31</code> into two <code>bytes31</code>s at the given index (LSB's index is 0). The input <code>bytes31</code> and the output <code>bytes31</code>s are represented using <code>felt252</code>s to improve performance.  Note: this function assumes that: 1. <code>word</code> is validly convertible to a <code>bytes31`` which has no more than </code>len<code>bytes of data. 2.</code>index &lt;= len<code>. 3. </code>len &lt;= BYTES_IN_BYTES31<code>. If these assumptions are not met, it can corrupt the </code>byte31`s. Thus, this should be a private function. We could add masking/assertions but it would be more expansive.</p>
<p>Fully qualified path: <code>core::bytes_31::split_bytes31</code></p>
<pre><code class="language-rust">pub(crate) fn split_bytes31(word: felt252, len: usize, index: usize) -&gt; (felt252, felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="one_shift_left_bytes_felt252"><a class="header" href="#one_shift_left_bytes_felt252">one_shift_left_bytes_felt252</a></h1>
<p>Returns <code>1 &lt;&lt; (8 * n_bytes)</code> as <code>felt252</code>, assuming that <code>n_bytes &lt; BYTES_IN_BYTES31</code>.  Note: if <code>n_bytes &gt;= BYTES_IN_BYTES31</code>, the behavior is undefined. If one wants to assert that in the callsite, it's sufficient to assert that <code>n_bytes != BYTES_IN_BYTES31</code> because if <code>n_bytes &gt; 31</code> then <code>n_bytes - 16 &gt; 15</code> and <code>one_shift_left_bytes_u128</code> would panic.</p>
<p>Fully qualified path: <code>core::bytes_31::one_shift_left_bytes_felt252</code></p>
<pre><code class="language-rust">pub(crate) fn one_shift_left_bytes_felt252(n_bytes: usize) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="one_shift_left_bytes_u128"><a class="header" href="#one_shift_left_bytes_u128">one_shift_left_bytes_u128</a></h1>
<p>Returns <code>1 &lt;&lt; (8 * n_bytes)</code> as <code>u128</code>, where <code>n_bytes</code> must be &lt; <code>BYTES_IN_U128</code>.  Panics if <code>n_bytes &gt;= BYTES_IN_U128</code>.</p>
<p>Fully qualified path: <code>core::bytes_31::one_shift_left_bytes_u128</code></p>
<pre><code class="language-rust">pub(crate) fn one_shift_left_bytes_u128(n_bytes: usize) -&gt; u128</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-14"><a class="header" href="#structs-14">Structs</a></h1>
<ul>
<li>
<p><a href="./core-circuit-u384.html">u384</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitElement.html">CircuitElement</a></p>
</li>
<li>
<p><a href="./core-array-Span.html">Span</a></p>
</li>
<li>
<p><a href="./core-array-SpanIter.html">SpanIter</a></p>
</li>
<li>
<p><a href="./core-array-ArrayIter.html">ArrayIter</a></p>
</li>
<li>
<p><a href="./core-integer-u256.html">u256</a></p>
</li>
<li>
<p><a href="./core-integer-u512.html">u512</a></p>
</li>
<li>
<p><a href="./core-ops-range-Range.html">Range</a></p>
</li>
<li>
<p><a href="./core-panics-Panic.html">Panic</a></p>
</li>
<li>
<p><a href="./core-pedersen-HashState.html">pedersen::HashState</a></p>
</li>
<li>
<p><a href="./core-poseidon-HashState.html">poseidon::HashState</a></p>
</li>
<li>
<p><a href="./core-fmt-Error.html">Error</a></p>
</li>
<li>
<p><a href="./core-fmt-Formatter.html">Formatter</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-EthAddress.html">starknet::eth_address::EthAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-info-v2-ExecutionInfo.html">ExecutionInfo</a></p>
</li>
<li>
<p><a href="./core-starknet-info-BlockInfo.html">BlockInfo</a></p>
</li>
<li>
<p><a href="./core-starknet-info-v2-TxInfo.html">TxInfo</a></p>
</li>
<li>
<p><a href="./core-starknet-info-v2-ResourceBounds.html">ResourceBounds</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-Signature.html">Signature</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-EthAddress.html">starknet::eth_address::EthAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-account-Call.html">Call</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractDispatcher.html">AccountContractDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractLibraryDispatcher.html">AccountContractLibraryDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractSafeLibraryDispatcher.html">AccountContractSafeLibraryDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractSafeDispatcher.html">AccountContractSafeDispatcher</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointer.html">StoragePointer</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointer0Offset.html">StoragePointer0Offset</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePath.html">StoragePath</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-PendingStoragePath.html">PendingStoragePath</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-Mutable.html">Mutable</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-vec-Vec.html">Vec</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-StorageBase.html">StorageBase</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-FlattenedStorage.html">FlattenedStorage</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-Map.html">Map</a></p>
</li>
<li>
<p><a href="./core-byte_array-ByteArray.html">ByteArray</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u384"><a class="header" href="#u384">u384</a></h1>
<p>A 384-bit unsigned integer, used for circuit values.</p>
<p>Fully qualified path: <code>core::circuit::u384</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug, PartialEq)]
pub struct u384 {
    pub limb0: u96,
    pub limb1: u96,
    pub limb2: u96,
    pub limb3: u96,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitelement"><a class="header" href="#circuitelement">CircuitElement</a></h1>
<p>A wrapper for circuit elements, used to construct circuits..</p>
<p>Fully qualified path: <code>core::circuit::CircuitElement</code></p>
<pre><code class="language-rust">pub struct CircuitElement&lt;T&gt; {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="span"><a class="header" href="#span">Span</a></h1>
<p>A span is a view into a continuous collection of the same type - such as <code>Array</code>. It is a structure with a single field that holds a snapshot of an array. <code>Span</code> implements the <code>Copy</code> and the <code>Drop</code> traits.</p>
<p>Fully qualified path: <code>core::array::Span</code></p>
<pre><code class="language-rust">pub struct Span&lt;T&gt; {
    pub(crate) snapshot: @Array&lt;T&gt;,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spaniter"><a class="header" href="#spaniter">SpanIter</a></h1>
<p>An iterator struct over a span collection.</p>
<p>Fully qualified path: <code>core::array::SpanIter</code></p>
<pre><code class="language-rust">pub struct SpanIter&lt;T&gt; {
    span: Span&lt;T&gt;,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrayiter"><a class="header" href="#arrayiter">ArrayIter</a></h1>
<p>An iterator struct over an array collection.</p>
<p>Fully qualified path: <code>core::array::ArrayIter</code></p>
<pre><code class="language-rust">#[derive(Drop)]
pub struct ArrayIter&lt;T&gt; {
    array: Array&lt;T&gt;,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256"><a class="header" href="#u256">u256</a></h1>
<p>Fully qualified path: <code>core::integer::u256</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Hash, PartialEq, Serde)]
pub struct u256 {
    pub low: u128,
    pub high: u128,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u512"><a class="header" href="#u512">u512</a></h1>
<p>Fully qualified path: <code>core::integer::u512</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Hash, PartialEq, Serde)]
pub struct u512 {
    pub limb0: u128,
    pub limb1: u128,
    pub limb2: u128,
    pub limb3: u128,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="range"><a class="header" href="#range">Range</a></h1>
<p>Represents the range [start, end).</p>
<p>Fully qualified path: <code>core::ops::range::Range</code></p>
<pre><code class="language-rust">#[derive(Clone, Drop)]
pub struct Range&lt;T&gt; {
    pub start: T,
    pub end: T,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic">panic</a></h1>
<p>Triggers an immediate panic with the provided data and terminates execution.  # Examples</p>
<pre><code class="language-cairo">use core::panics::panic;

panic(array!['An error occurred']);
</code></pre>
<p>Fully qualified path: <code>core::panics::panic</code></p>
<pre><code class="language-rust">pub extern fn panic(data: Array&lt;felt252&gt;) -&gt; crate::never;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashstate"><a class="header" href="#hashstate">HashState</a></h1>
<p>Represents the current state of a Pedersen hash computation.  The state is maintained as a single <code>felt252</code> value, which is updated through the <a href="%5B%60HashStateTrait::finalize%60%5D"><code>HashStateTrait::finalize</code></a> method.</p>
<p>Fully qualified path: <code>core::pedersen::HashState</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug)]
pub struct HashState {
    pub state: felt252,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashstate-1"><a class="header" href="#hashstate-1">HashState</a></h1>
<p>State for Poseidon hash.</p>
<p>Fully qualified path: <code>core::poseidon::HashState</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug)]
pub struct HashState {
    pub s0: felt252,
    pub s1: felt252,
    pub s2: felt252,
    pub odd: bool,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error"><a class="header" href="#error">Error</a></h1>
<p>Dedicated type for representing formatting errors.</p>
<p>Fully qualified path: <code>core::fmt::Error</code></p>
<pre><code class="language-rust">#[derive(Drop)]
pub struct Error {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatter"><a class="header" href="#formatter">Formatter</a></h1>
<p>Configuration for formatting.</p>
<p>Fully qualified path: <code>core::fmt::Formatter</code></p>
<pre><code class="language-rust">#[derive(Default, Drop)]
pub struct Formatter {
    pub buffer: ByteArray,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethaddress"><a class="header" href="#ethaddress">EthAddress</a></h1>
<p>Fully qualified path: <code>core::starknet::eth_address::EthAddress</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Hash, PartialEq)]
pub struct EthAddress {
    address: felt252,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executioninfo"><a class="header" href="#executioninfo">ExecutionInfo</a></h1>
<p>The same as <code>ExecutionInfo</code>, but with the <code>TxInfo</code> field replaced with <code>v2::TxInfo</code>.</p>
<p>Fully qualified path: <code>core::starknet::info::v2::ExecutionInfo</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug)]
pub struct ExecutionInfo {
    pub block_info: Box&lt;BlockInfo&gt;,
    pub tx_info: Box&lt;TxInfo&gt;,
    pub caller_address: ContractAddress,
    pub contract_address: ContractAddress,
    pub entry_point_selector: felt252,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockinfo"><a class="header" href="#blockinfo">BlockInfo</a></h1>
<p>Information about the current block.</p>
<p>Fully qualified path: <code>core::starknet::info::BlockInfo</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug, Serde)]
pub struct BlockInfo {
    pub block_number: u64,
    pub block_timestamp: u64,
    pub sequencer_address: ContractAddress,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="txinfo"><a class="header" href="#txinfo">TxInfo</a></h1>
<p>Fully qualified path: <code>core::starknet::info::v2::TxInfo</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug, Serde)]
pub struct TxInfo {
    pub version: felt252,
    pub account_contract_address: ContractAddress,
    pub max_fee: u128,
    pub signature: Span&lt;felt252&gt;,
    pub transaction_hash: felt252,
    pub chain_id: felt252,
    pub nonce: felt252,
    pub resource_bounds: Span&lt;ResourceBounds&gt;,
    pub tip: u128,
    pub paymaster_data: Span&lt;felt252&gt;,
    pub nonce_data_availability_mode: u32,
    pub fee_data_availability_mode: u32,
    pub account_deployment_data: Span&lt;felt252&gt;,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resourcebounds"><a class="header" href="#resourcebounds">ResourceBounds</a></h1>
<p>Fully qualified path: <code>core::starknet::info::v2::ResourceBounds</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug, Serde)]
pub struct ResourceBounds {
    pub resource: felt252,
    pub max_amount: u64,
    pub max_price_per_unit: u128,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signature"><a class="header" href="#signature">Signature</a></h1>
<p>Secp256{k/r}1 ECDSA signature.</p>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Signature</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Debug, PartialEq, Serde, Hash)]
pub struct Signature {
    pub r: u256,
    pub s: u256,
    pub y_parity: bool,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethaddress-1"><a class="header" href="#ethaddress-1">EthAddress</a></h1>
<p>Fully qualified path: <code>core::starknet::eth_address::EthAddress</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Hash, PartialEq)]
pub struct EthAddress {
    address: felt252,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call"><a class="header" href="#call">Call</a></h1>
<p>A struct representing a call to a contract.</p>
<p>Fully qualified path: <code>core::starknet::account::Call</code></p>
<pre><code class="language-rust">#[derive(Drop, Copy, Serde, Debug)]
pub struct Call {
    pub to: ContractAddress,
    pub selector: felt252,
    pub calldata: Span&lt;felt252&gt;,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontractdispatcher"><a class="header" href="#accountcontractdispatcher">AccountContractDispatcher</a></h1>
<p>Fully qualified path: <code>core::starknet::account::AccountContractDispatcher</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct AccountContractDispatcher {
    pub contract_address: starknet::ContractAddress,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontractlibrarydispatcher"><a class="header" href="#accountcontractlibrarydispatcher">AccountContractLibraryDispatcher</a></h1>
<p>Fully qualified path: <code>core::starknet::account::AccountContractLibraryDispatcher</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct AccountContractLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontractsafelibrarydispatcher"><a class="header" href="#accountcontractsafelibrarydispatcher">AccountContractSafeLibraryDispatcher</a></h1>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeLibraryDispatcher</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct AccountContractSafeLibraryDispatcher {
    pub class_hash: starknet::ClassHash,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontractsafedispatcher"><a class="header" href="#accountcontractsafedispatcher">AccountContractSafeDispatcher</a></h1>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeDispatcher</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, starknet::Store, Serde)]
pub struct AccountContractSafeDispatcher {
    pub contract_address: starknet::ContractAddress,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagepointer"><a class="header" href="#storagepointer">StoragePointer</a></h1>
<p>A pointer to an address in storage, can be used to read and write values, if the generic type supports it (e.g. basic types like <code>felt252</code>).</p>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointer</code></p>
<pre><code class="language-rust">pub struct StoragePointer&lt;T&gt; {
    pub __storage_pointer_address__: StorageBaseAddress,
    pub __storage_pointer_offset__: u8,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagepointer0offset"><a class="header" href="#storagepointer0offset">StoragePointer0Offset</a></h1>
<p>Same as <code>StoragePointer</code>, but with <code>offset</code> 0, which allows for some optimizations.</p>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointer0Offset</code></p>
<pre><code class="language-rust">pub struct StoragePointer0Offset&lt;T&gt; {
    pub __storage_pointer_address__: StorageBaseAddress,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagepath"><a class="header" href="#storagepath">StoragePath</a></h1>
<p>An intermediate struct to store a hash state, in order to be able to hash multiple values and get the final address. Storage path should have two interfaces, if T is storable then it should implement <code>StorageAsPointer</code> in order to be able to get the address of the storage path. Otherwise, if T is not storable then it should implement some kind of updating trait, e.g. <code>StoragePathEntry</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::StoragePath</code></p>
<pre><code class="language-rust">pub struct StoragePath&lt;T&gt; {
    __hash_state__: StoragePathHashState,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pendingstoragepath"><a class="header" href="#pendingstoragepath">PendingStoragePath</a></h1>
<p>A struct for delaying the creation of a storage path, used for lazy evaluation in storage nodes.</p>
<p>Fully qualified path: <code>core::starknet::storage::PendingStoragePath</code></p>
<pre><code class="language-rust">pub struct PendingStoragePath&lt;T&gt; {
    __hash_state__: StoragePathHashState,
    __pending_key__: felt252,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable"><a class="header" href="#mutable">Mutable</a></h1>
<p>A wrapper around different storage related types, indicating that the instance is mutable, i.e. originally created from a <code>ref</code> contract state.</p>
<p>Fully qualified path: <code>core::starknet::storage::Mutable</code></p>
<pre><code class="language-rust">#[phantom]
pub struct Mutable&lt;T&gt; {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vec"><a class="header" href="#vec">Vec</a></h1>
<p>A type to represent a vec in storage. The length of the storage is stored in the storage base, while the elements are stored in hash(storage_base, index).</p>
<p>Fully qualified path: <code>core::starknet::storage::vec::Vec</code></p>
<pre><code class="language-rust">#[phantom]
pub struct Vec&lt;T&gt; {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagebase"><a class="header" href="#storagebase">StorageBase</a></h1>
<p>A struct for holding an address to initialize a storage path with. The members (not direct members, but accessible using deref) of a contract state are either <code>StorageBase</code> or <code>FlattenedStorage</code> instances, with the generic type representing the type of the stored member.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageBase</code></p>
<pre><code class="language-rust">pub struct StorageBase&lt;T&gt; {
    pub __base_address__: felt252,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flattenedstorage"><a class="header" href="#flattenedstorage">FlattenedStorage</a></h1>
<p>A type that represents a flattened storage, i.e. a storage object which does not have any effect on the path taken into consideration when computing the address of the storage object.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::FlattenedStorage</code></p>
<pre><code class="language-rust">pub struct FlattenedStorage&lt;T&gt; {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map"><a class="header" href="#map">Map</a></h1>
<p>A struct that represents a map in a contract storage.</p>
<p>Fully qualified path: <code>core::starknet::storage::map::Map</code></p>
<pre><code class="language-rust">#[phantom]
pub struct Map&lt;K, V&gt; {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytearray"><a class="header" href="#bytearray">ByteArray</a></h1>
<p>Byte array type.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArray</code></p>
<pre><code class="language-rust">#[derive(Drop, Clone, PartialEq, Serde, Default)]
pub struct ByteArray {
    pub(crate) data: Array&lt;bytes31&gt;,
    pub(crate) pending_word: felt252,
    pub(crate) pending_word_len: usize,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-8"><a class="header" href="#enums-8">Enums</a></h1>
<ul>
<li>
<p><a href="./core-bool.html">bool</a></p>
</li>
<li>
<p><a href="./core-never.html">never</a></p>
</li>
<li>
<p><a href="./core-circuit-AddInputResult.html">AddInputResult</a></p>
</li>
<li>
<p><a href="./core-nullable-FromNullableResult.html">FromNullableResult</a></p>
</li>
<li>
<p><a href="./core-result-Result.html">Result</a></p>
</li>
<li>
<p><a href="./core-option-Option.html">Option</a></p>
</li>
<li>
<p><a href="./core-panics-PanicResult.html">PanicResult</a></p>
</li>
<li>
<p><a href="./core-internal-OptionRev.html">OptionRev</a></p>
</li>
<li>
<p><a href="./core-zeroable-IsZeroResult.html">IsZeroResult</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool"><a class="header" href="#bool">bool</a></h1>
<p>Fully qualified path: <code>core::bool</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop, Default)]
pub enum bool {
    #[default]
    False,
    True,
}</code></pre>
<h2 id="variants"><a class="header" href="#variants">Variants</a></h2>
<h3 id="false"><a class="header" href="#false">False</a></h3>
<p>Fully qualified path: <code>core::bool::False</code></p>
<pre><code class="language-rust">#[default]
False</code></pre>
<h3 id="true"><a class="header" href="#true">True</a></h3>
<p>Fully qualified path: <code>core::bool::True</code></p>
<pre><code class="language-rust">True</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="never"><a class="header" href="#never">never</a></h1>
<p>Fully qualified path: <code>core::never</code></p>
<pre><code class="language-rust">pub enum never {}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addinputresult"><a class="header" href="#addinputresult">AddInputResult</a></h1>
<p>The result of filling an input in the circuit instance's data.</p>
<p>Fully qualified path: <code>core::circuit::AddInputResult</code></p>
<pre><code class="language-rust">pub enum AddInputResult&lt;C&gt; {
    Done: CircuitData&lt;C&gt;,
    More: CircuitInputAccumulator&lt;C&gt;,
}</code></pre>
<h2 id="variants-1"><a class="header" href="#variants-1">Variants</a></h2>
<h3 id="done"><a class="header" href="#done">Done</a></h3>
<p>All inputs have been filled.</p>
<p>Fully qualified path: <code>core::circuit::AddInputResult::Done</code></p>
<pre><code class="language-rust">Done : CircuitData &lt; C &gt;</code></pre>
<h3 id="more"><a class="header" href="#more">More</a></h3>
<p>More inputs are needed to fill the circuit instance's data.</p>
<p>Fully qualified path: <code>core::circuit::AddInputResult::More</code></p>
<pre><code class="language-rust">More : CircuitInputAccumulator &lt; C &gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fromnullableresult"><a class="header" href="#fromnullableresult">FromNullableResult</a></h1>
<p>Represents the result of matching a <code>Nullable</code> value.  Used to safely handle both null and non-null cases when using <code>match_nullable</code> on a <code>Nullable</code>.</p>
<p>Fully qualified path: <code>core::nullable::FromNullableResult</code></p>
<pre><code class="language-rust">pub enum FromNullableResult&lt;T&gt; {
    Null,
    NotNull: Box&lt;T&gt;,
}</code></pre>
<h2 id="variants-2"><a class="header" href="#variants-2">Variants</a></h2>
<h3 id="null"><a class="header" href="#null">Null</a></h3>
<p>Represents a null value</p>
<p>Fully qualified path: <code>core::nullable::FromNullableResult::Null</code></p>
<pre><code class="language-rust">Null</code></pre>
<h3 id="notnull"><a class="header" href="#notnull">NotNull</a></h3>
<p>The boxed value when not null</p>
<p>Fully qualified path: <code>core::nullable::FromNullableResult::NotNull</code></p>
<pre><code class="language-rust">NotNull : Box &lt; T &gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-1"><a class="header" href="#result-1">Result</a></h1>
<p>Fully qualified path: <code>core::result::Result</code></p>
<pre><code class="language-rust">#[must_use]
#[derive(Copy, Drop, Debug, Serde, PartialEq)]
pub enum Result&lt;T, E&gt; {
    Ok: T,
    Err: E,
}</code></pre>
<h2 id="variants-3"><a class="header" href="#variants-3">Variants</a></h2>
<h3 id="ok"><a class="header" href="#ok">Ok</a></h3>
<p>Fully qualified path: <code>core::result::Result::Ok</code></p>
<pre><code class="language-rust">Ok : T</code></pre>
<h3 id="err"><a class="header" href="#err">Err</a></h3>
<p>Fully qualified path: <code>core::result::Result::Err</code></p>
<pre><code class="language-rust">Err : E</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-1"><a class="header" href="#option-1">Option</a></h1>
<p>Fully qualified path: <code>core::option::Option</code></p>
<pre><code class="language-rust">#[must_use]
#[derive(Copy, Drop, Debug, Serde, PartialEq)]
pub enum Option&lt;T&gt; {
    Some: T,
    None,
}</code></pre>
<h2 id="variants-4"><a class="header" href="#variants-4">Variants</a></h2>
<h3 id="some"><a class="header" href="#some">Some</a></h3>
<p>Fully qualified path: <code>core::option::Option::Some</code></p>
<pre><code class="language-rust">Some : T</code></pre>
<h3 id="none"><a class="header" href="#none">None</a></h3>
<p>Fully qualified path: <code>core::option::Option::None</code></p>
<pre><code class="language-rust">None</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panicresult"><a class="header" href="#panicresult">PanicResult</a></h1>
<p>Result type for operations that can trigger a panic.</p>
<p>Fully qualified path: <code>core::panics::PanicResult</code></p>
<pre><code class="language-rust">pub enum PanicResult&lt;T&gt; {
    Ok: T,
    Err: (Panic, Array&lt;felt252&gt;),
}</code></pre>
<h2 id="variants-5"><a class="header" href="#variants-5">Variants</a></h2>
<h3 id="ok-1"><a class="header" href="#ok-1">Ok</a></h3>
<p>Fully qualified path: <code>core::panics::PanicResult::Ok</code></p>
<pre><code class="language-rust">Ok : T</code></pre>
<h3 id="err-1"><a class="header" href="#err-1">Err</a></h3>
<p>Fully qualified path: <code>core::panics::PanicResult::Err</code></p>
<pre><code class="language-rust">Err : ( Panic , Array &lt; felt252 &gt; )</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optionrev"><a class="header" href="#optionrev">OptionRev</a></h1>
<p>Same as <code>Option</code>, except that the order of the variants is reversed. This is used as the return type of some libfuncs for efficiency reasons.</p>
<p>Fully qualified path: <code>core::internal::OptionRev</code></p>
<pre><code class="language-rust">#[must_use]
#[derive(Copy, Drop, Debug, PartialEq)]
pub enum OptionRev&lt;T&gt; {
    None,
    Some: T,
}</code></pre>
<h2 id="variants-6"><a class="header" href="#variants-6">Variants</a></h2>
<h3 id="none-1"><a class="header" href="#none-1">None</a></h3>
<p>Fully qualified path: <code>core::internal::OptionRev::None</code></p>
<pre><code class="language-rust">None</code></pre>
<h3 id="some-1"><a class="header" href="#some-1">Some</a></h3>
<p>Fully qualified path: <code>core::internal::OptionRev::Some</code></p>
<pre><code class="language-rust">Some : T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iszeroresult"><a class="header" href="#iszeroresult">IsZeroResult</a></h1>
<p>Represents the result of checking whether a value is zero.</p>
<p>Fully qualified path: <code>core::zeroable::IsZeroResult</code></p>
<pre><code class="language-rust">pub(crate) enum IsZeroResult&lt;T&gt; {
    Zero,
    NonZero: NonZero&lt;T&gt;,
}</code></pre>
<h2 id="variants-7"><a class="header" href="#variants-7">Variants</a></h2>
<h3 id="zero-1"><a class="header" href="#zero-1">Zero</a></h3>
<p>Indicates that the value is zero.</p>
<p>Fully qualified path: <code>core::zeroable::IsZeroResult::Zero</code></p>
<pre><code class="language-rust">Zero</code></pre>
<h3 id="nonzero"><a class="header" href="#nonzero">NonZero</a></h3>
<p>Indicates that the value is non-zero, wrapping it in a <code>NonZero&lt;T&gt;</code>.</p>
<p>Fully qualified path: <code>core::zeroable::IsZeroResult::NonZero</code></p>
<pre><code class="language-rust">NonZero : NonZero &lt; T &gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-aliases-4"><a class="header" href="#type-aliases-4">Type aliases</a></h1>
<ul>
<li>
<p><a href="./core-usize.html">usize</a></p>
</li>
<li>
<p><a href="./core-circuit-u96.html">u96</a></p>
</li>
<li>
<p><a href="./core-circuit-ConstZero.html">ConstZero</a></p>
</li>
<li>
<p><a href="./core-circuit-ConstOne.html">ConstOne</a></p>
</li>
<li>
<p><a href="./core-ec-NonZeroEcPoint.html">NonZeroEcPoint</a></p>
</li>
<li>
<p><a href="./core-starknet-SyscallResult.html">SyscallResult</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usize"><a class="header" href="#usize">usize</a></h1>
<p>Fully qualified path: <code>core::usize</code></p>
<pre><code class="language-rust">pub type usize = u32;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u96"><a class="header" href="#u96">u96</a></h1>
<p>Fully qualified path: <code>core::circuit::u96</code></p>
<pre><code class="language-rust">pub type u96 = crate::internal::bounded_int::BoundedInt&lt;0, 79228162514264337593543950335&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constzero"><a class="header" href="#constzero">ConstZero</a></h1>
<p>Expose the const required by the libfunc to allow the compiler const reusage.</p>
<p>Fully qualified path: <code>core::circuit::ConstZero</code></p>
<pre><code class="language-rust">pub type ConstZero = crate::internal::bounded_int::BoundedInt&lt;0, 0&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constone"><a class="header" href="#constone">ConstOne</a></h1>
<p>Fully qualified path: <code>core::circuit::ConstOne</code></p>
<pre><code class="language-rust">pub type ConstOne = crate::internal::bounded_int::BoundedInt&lt;1, 1&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nonzeroecpoint"><a class="header" href="#nonzeroecpoint">NonZeroEcPoint</a></h1>
<p>Fully qualified path: <code>core::ec::NonZeroEcPoint</code></p>
<pre><code class="language-rust">pub type NonZeroEcPoint = NonZero&lt;EcPoint&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syscallresult"><a class="header" href="#syscallresult">SyscallResult</a></h1>
<p>The result type for a syscall.</p>
<p>Fully qualified path: <code>core::starknet::SyscallResult</code></p>
<pre><code class="language-rust">pub type SyscallResult&lt;T&gt; = Result&lt;T, Array&lt;felt252&gt;&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impl-aliases-5"><a class="header" href="#impl-aliases-5">Impl aliases</a></h1>
<ul>
<li>
<p><a href="./core-integer-U8Zeroable.html">U8Zeroable</a></p>
</li>
<li>
<p><a href="./core-integer-U16Zeroable.html">U16Zeroable</a></p>
</li>
<li>
<p><a href="./core-integer-U32Zeroable.html">U32Zeroable</a></p>
</li>
<li>
<p><a href="./core-integer-U64Zeroable.html">U64Zeroable</a></p>
</li>
<li>
<p><a href="./core-integer-U128Zeroable.html">U128Zeroable</a></p>
</li>
<li>
<p><a href="./core-integer-U256Zeroable.html">U256Zeroable</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-ContractAddressZeroable.html">ContractAddressZeroable</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-EthAddressZeroable.html">EthAddressZeroable</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-ClassHashZeroable.html">ClassHashZeroable</a></p>
</li>
<li>
<p><a href="./core-zeroable-Felt252Zeroable.html">Felt252Zeroable</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8zeroable"><a class="header" href="#u8zeroable">U8Zeroable</a></h1>
<p>Fully qualified path: <code>core::integer::U8Zeroable</code></p>
<pre><code class="language-rust">pub(crate) impl U8Zeroable = crate::zeroable::zero_based::ZeroableImpl&lt;u8, U8Zero&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16zeroable"><a class="header" href="#u16zeroable">U16Zeroable</a></h1>
<p>Fully qualified path: <code>core::integer::U16Zeroable</code></p>
<pre><code class="language-rust">pub(crate) impl U16Zeroable = crate::zeroable::zero_based::ZeroableImpl&lt;u16, U16Zero&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32zeroable"><a class="header" href="#u32zeroable">U32Zeroable</a></h1>
<p>Fully qualified path: <code>core::integer::U32Zeroable</code></p>
<pre><code class="language-rust">pub(crate) impl U32Zeroable = crate::zeroable::zero_based::ZeroableImpl&lt;u32, U32Zero&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64zeroable"><a class="header" href="#u64zeroable">U64Zeroable</a></h1>
<p>Fully qualified path: <code>core::integer::U64Zeroable</code></p>
<pre><code class="language-rust">pub(crate) impl U64Zeroable = crate::zeroable::zero_based::ZeroableImpl&lt;u64, U64Zero&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128zeroable"><a class="header" href="#u128zeroable">U128Zeroable</a></h1>
<p>Fully qualified path: <code>core::integer::U128Zeroable</code></p>
<pre><code class="language-rust">pub(crate) impl U128Zeroable = crate::zeroable::zero_based::ZeroableImpl&lt;u128, U128Zero&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256zeroable"><a class="header" href="#u256zeroable">U256Zeroable</a></h1>
<p>Fully qualified path: <code>core::integer::U256Zeroable</code></p>
<pre><code class="language-rust">pub(crate) impl U256Zeroable = crate::zeroable::zero_based::ZeroableImpl&lt;u256, U256Zero&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contractaddresszeroable"><a class="header" href="#contractaddresszeroable">ContractAddressZeroable</a></h1>
<p>Fully qualified path: <code>core::starknet::contract_address::ContractAddressZeroable</code></p>
<pre><code class="language-rust">pub(crate) impl ContractAddressZeroable =
    core::zeroable::zero_based::ZeroableImpl&lt;ContractAddress, ContractAddressZero&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethaddresszeroable"><a class="header" href="#ethaddresszeroable">EthAddressZeroable</a></h1>
<p>Fully qualified path: <code>core::starknet::eth_address::EthAddressZeroable</code></p>
<pre><code class="language-rust">pub(crate) impl EthAddressZeroable =
    core::zeroable::zero_based::ZeroableImpl&lt;EthAddress, EthAddressZero&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classhashzeroable"><a class="header" href="#classhashzeroable">ClassHashZeroable</a></h1>
<p>Fully qualified path: <code>core::starknet::class_hash::ClassHashZeroable</code></p>
<pre><code class="language-rust">pub(crate) impl ClassHashZeroable =
    core::zeroable::zero_based::ZeroableImpl&lt;ClassHash, ClassHashZero&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252zeroable"><a class="header" href="#felt252zeroable">Felt252Zeroable</a></h1>
<p>Fully qualified path: <code>core::zeroable::Felt252Zeroable</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252Zeroable = zero_based::ZeroableImpl&lt;felt252&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-48"><a class="header" href="#traits-48">Traits</a></h1>
<ul>
<li>
<p><a href="./core-traits-Copy.html">Copy</a></p>
</li>
<li>
<p><a href="./core-traits-Drop.html">Drop</a></p>
</li>
<li>
<p><a href="./core-traits-Add.html">Add</a></p>
</li>
<li>
<p><a href="./core-traits-AddEq.html">AddEq</a></p>
</li>
<li>
<p><a href="./core-traits-Sub.html">Sub</a></p>
</li>
<li>
<p><a href="./core-traits-SubEq.html">SubEq</a></p>
</li>
<li>
<p><a href="./core-traits-Mul.html">Mul</a></p>
</li>
<li>
<p><a href="./core-traits-MulEq.html">MulEq</a></p>
</li>
<li>
<p><a href="./core-traits-Div.html">Div</a></p>
</li>
<li>
<p><a href="./core-traits-DivEq.html">DivEq</a></p>
</li>
<li>
<p><a href="./core-traits-Rem.html">Rem</a></p>
</li>
<li>
<p><a href="./core-traits-RemEq.html">RemEq</a></p>
</li>
<li>
<p><a href="./core-traits-DivRem.html">DivRem</a></p>
</li>
<li>
<p><a href="./core-traits-PartialEq.html">PartialEq</a></p>
</li>
<li>
<p><a href="./core-traits-BitAnd.html">BitAnd</a></p>
</li>
<li>
<p><a href="./core-traits-BitOr.html">BitOr</a></p>
</li>
<li>
<p><a href="./core-traits-BitXor.html">BitXor</a></p>
</li>
<li>
<p><a href="./core-traits-BitNot.html">BitNot</a></p>
</li>
<li>
<p><a href="./core-traits-PartialOrd.html">PartialOrd</a></p>
</li>
<li>
<p><a href="./core-traits-Into.html">Into</a></p>
</li>
<li>
<p><a href="./core-traits-TryInto.html">TryInto</a></p>
</li>
<li>
<p><a href="./core-traits-Neg.html">Neg</a></p>
</li>
<li>
<p><a href="./core-traits-Not.html">Not</a></p>
</li>
<li>
<p><a href="./core-traits-IndexView.html">traits::IndexView</a></p>
</li>
<li>
<p><a href="./core-traits-Index.html">traits::Index</a></p>
</li>
<li>
<p><a href="./core-traits-Destruct.html">Destruct</a></p>
</li>
<li>
<p><a href="./core-traits-PanicDestruct.html">PanicDestruct</a></p>
</li>
<li>
<p><a href="./core-traits-Default.html">Default</a></p>
</li>
<li>
<p><a href="./core-traits-Felt252DictValue.html">Felt252DictValue</a></p>
</li>
<li>
<p><a href="./core-boolean-BoolTrait.html">BoolTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitElementTrait.html">CircuitElementTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitOutputsTrait.html">CircuitOutputsTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitInputs.html">CircuitInputs</a></p>
</li>
<li>
<p><a href="./core-circuit-AddInputResultTrait.html">AddInputResultTrait</a></p>
</li>
<li>
<p><a href="./core-circuit-EvalCircuitTrait.html">EvalCircuitTrait</a></p>
</li>
<li>
<p><a href="./core-box-BoxTrait.html">BoxTrait</a></p>
</li>
<li>
<p><a href="./core-nullable-NullableTrait.html">NullableTrait</a></p>
</li>
<li>
<p><a href="./core-array-ToSpanTrait.html">ToSpanTrait</a></p>
</li>
<li>
<p><a href="./core-array-ArrayTrait.html">ArrayTrait</a></p>
</li>
<li>
<p><a href="./core-array-SpanTrait.html">SpanTrait</a></p>
</li>
<li>
<p><a href="./core-dict-Felt252DictTrait.html">Felt252DictTrait</a></p>
</li>
<li>
<p><a href="./core-dict-Felt252DictEntryTrait.html">Felt252DictEntryTrait</a></p>
</li>
<li>
<p><a href="./core-result-ResultTrait.html">ResultTrait</a></p>
</li>
<li>
<p><a href="./core-option-OptionTrait.html">OptionTrait</a></p>
</li>
<li>
<p><a href="./core-clone-Clone.html">Clone</a></p>
</li>
<li>
<p><a href="./core-ec-EcStateTrait.html">EcStateTrait</a></p>
</li>
<li>
<p><a href="./core-ec-EcPointTrait.html">EcPointTrait</a></p>
</li>
<li>
<p><a href="./core-integer-NumericLiteral.html">NumericLiteral</a></p>
</li>
<li>
<p><a href="./core-integer-BoundedInt.html">BoundedInt</a></p>
</li>
<li>
<p><a href="./core-integer-AbsAndSign.html">AbsAndSign</a></p>
</li>
<li>
<p><a href="./core-num-traits-zero-Zero.html">num::traits::zero::Zero</a></p>
</li>
<li>
<p><a href="./core-num-traits-one-One.html">num::traits::one::One</a></p>
</li>
<li>
<p><a href="./core-num-traits-bit_size-BitSize.html">num::traits::bit_size::BitSize</a></p>
</li>
<li>
<p><a href="./core-num-traits-bounded-Bounded.html">Bounded</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingAdd.html">num::traits::ops::overflowing::OverflowingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingSub.html">num::traits::ops::overflowing::OverflowingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingMul.html">num::traits::ops::overflowing::OverflowingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingAdd.html">num::traits::ops::wrapping::WrappingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingSub.html">num::traits::ops::wrapping::WrappingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingMul.html">num::traits::ops::wrapping::WrappingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedAdd.html">num::traits::ops::checked::CheckedAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedSub.html">num::traits::ops::checked::CheckedSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedMul.html">num::traits::ops::checked::CheckedMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-pow-Pow.html">num::traits::ops::pow::Pow</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingAdd.html">num::traits::ops::saturating::SaturatingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingSub.html">num::traits::ops::saturating::SaturatingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingMul.html">num::traits::ops::saturating::SaturatingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widemul-WideMul.html">num::traits::ops::widemul::WideMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widesquare-WideSquare.html">num::traits::ops::widesquare::WideSquare</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-sqrt-Sqrt.html">num::traits::ops::sqrt::Sqrt</a></p>
</li>
<li>
<p><a href="./core-num-traits-zero-Zero.html">num::traits::zero::Zero</a></p>
</li>
<li>
<p><a href="./core-num-traits-one-One.html">num::traits::one::One</a></p>
</li>
<li>
<p><a href="./core-num-traits-bit_size-BitSize.html">num::traits::bit_size::BitSize</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingAdd.html">num::traits::ops::overflowing::OverflowingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingSub.html">num::traits::ops::overflowing::OverflowingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-overflowing-OverflowingMul.html">num::traits::ops::overflowing::OverflowingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingAdd.html">num::traits::ops::wrapping::WrappingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingSub.html">num::traits::ops::wrapping::WrappingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-wrapping-WrappingMul.html">num::traits::ops::wrapping::WrappingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedAdd.html">num::traits::ops::checked::CheckedAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedSub.html">num::traits::ops::checked::CheckedSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-checked-CheckedMul.html">num::traits::ops::checked::CheckedMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingAdd.html">num::traits::ops::saturating::SaturatingAdd</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingSub.html">num::traits::ops::saturating::SaturatingSub</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-saturating-SaturatingMul.html">num::traits::ops::saturating::SaturatingMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-pow-Pow.html">num::traits::ops::pow::Pow</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-sqrt-Sqrt.html">num::traits::ops::sqrt::Sqrt</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widemul-WideMul.html">num::traits::ops::widemul::WideMul</a></p>
</li>
<li>
<p><a href="./core-num-traits-ops-widesquare-WideSquare.html">num::traits::ops::widesquare::WideSquare</a></p>
</li>
<li>
<p><a href="./core-ops-index-Index.html">ops::index::Index</a></p>
</li>
<li>
<p><a href="./core-ops-index-IndexView.html">ops::index::IndexView</a></p>
</li>
<li>
<p><a href="./core-ops-arith-AddAssign.html">AddAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-SubAssign.html">SubAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-MulAssign.html">MulAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-DivAssign.html">DivAssign</a></p>
</li>
<li>
<p><a href="./core-ops-arith-RemAssign.html">RemAssign</a></p>
</li>
<li>
<p><a href="./core-ops-deref-Deref.html">Deref</a></p>
</li>
<li>
<p><a href="./core-ops-deref-SnapshotDeref.html">SnapshotDeref</a></p>
</li>
<li>
<p><a href="./core-ops-deref-DerefMut.html">DerefMut</a></p>
</li>
<li>
<p><a href="./core-ops-function-FnOnce.html">FnOnce</a></p>
</li>
<li>
<p><a href="./core-ops-function-Fn.html">Fn</a></p>
</li>
<li>
<p><a href="./core-ops-index-IndexView.html">ops::index::IndexView</a></p>
</li>
<li>
<p><a href="./core-ops-index-Index.html">ops::index::Index</a></p>
</li>
<li>
<p><a href="./core-serde-Serde.html">Serde</a></p>
</li>
<li>
<p><a href="./core-hash-HashStateTrait.html">HashStateTrait</a></p>
</li>
<li>
<p><a href="./core-hash-Hash.html">Hash</a></p>
</li>
<li>
<p><a href="./core-hash-LegacyHash.html">LegacyHash</a></p>
</li>
<li>
<p><a href="./core-hash-HashStateExTrait.html">HashStateExTrait</a></p>
</li>
<li>
<p><a href="./core-pedersen-PedersenTrait.html">PedersenTrait</a></p>
</li>
<li>
<p><a href="./core-poseidon-PoseidonTrait.html">PoseidonTrait</a></p>
</li>
<li>
<p><a href="./core-debug-PrintTrait.html">PrintTrait</a></p>
</li>
<li>
<p><a href="./core-fmt-Display.html">Display</a></p>
</li>
<li>
<p><a href="./core-fmt-Debug.html">Debug</a></p>
</li>
<li>
<p><a href="./core-fmt-LowerHex.html">LowerHex</a></p>
</li>
<li>
<p><a href="./core-starknet-SyscallResultTrait.html">SyscallResultTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-Store.html">starknet::storage_access::Store</a></p>
</li>
<li>
<p><a href="./core-starknet-event-Event.html">starknet::event::Event</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContract.html">starknet::account::AccountContract</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-Store.html">starknet::storage_access::Store</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorePacking.html">StorePacking</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-Secp256Trait.html">Secp256Trait</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256_trait-Secp256PointTrait.html">Secp256PointTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-event-Event.html">starknet::event::Event</a></p>
</li>
<li>
<p><a href="./core-starknet-event-EventEmitter.html">EventEmitter</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContract.html">starknet::account::AccountContract</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractDispatcherTrait.html">AccountContractDispatcherTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-account-AccountContractSafeDispatcherTrait.html">AccountContractSafeDispatcherTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StorageAsPointer.html">StorageAsPointer</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointerReadAccess.html">StoragePointerReadAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StoragePointerWriteAccess.html">StoragePointerWriteAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StorageAsPath.html">StorageAsPath</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-PendingStoragePathTrait.html">PendingStoragePathTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-vec-VecTrait.html">VecTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-vec-MutableVecTrait.html">MutableVecTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_node-StorageNode.html">StorageNode</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_node-StorageNodeMut.html">StorageNodeMut</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointers.html">SubPointers</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointersMut.html">SubPointersMut</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointersForward.html">SubPointersForward</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-sub_pointers-SubPointersMutForward.html">SubPointersMutForward</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-StorageTrait.html">StorageTrait</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-storage_base-StorageTraitMut.html">StorageTraitMut</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-StorageMapReadAccess.html">StorageMapReadAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-StorageMapWriteAccess.html">StorageMapWriteAccess</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-map-StoragePathEntry.html">StoragePathEntry</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-AddHelper.html">AddHelper</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-SubHelper.html">SubHelper</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-MulHelper.html">MulHelper</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-DivRemHelper.html">DivRemHelper</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-ConstrainHelper.html">ConstrainHelper</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-TrimHelper.html">TrimHelper</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-NegateHelper.html">NegateHelper</a></p>
</li>
<li>
<p><a href="./core-zeroable-Zeroable.html">Zeroable</a></p>
</li>
<li>
<p><a href="./core-bytes_31-Bytes31Trait.html">Bytes31Trait</a></p>
</li>
<li>
<p><a href="./core-byte_array-ByteArrayTrait.html">ByteArrayTrait</a></p>
</li>
<li>
<p><a href="./core-string-StringLiteral.html">StringLiteral</a></p>
</li>
<li>
<p><a href="./core-to_byte_array-AppendFormattedToByteArray.html">AppendFormattedToByteArray</a></p>
</li>
<li>
<p><a href="./core-to_byte_array-FormatAsByteArray.html">FormatAsByteArray</a></p>
</li>
<li>
<p><a href="./core-metaprogramming-TypeEqual.html">TypeEqual</a></p>
</li>
<li>
<p><a href="./core-metaprogramming-IsTuple.html">IsTuple</a></p>
</li>
<li>
<p><a href="./core-metaprogramming-TupleSplit.html">TupleSplit</a></p>
</li>
<li>
<p><a href="./core-metaprogramming-TupleExtendFront.html">TupleExtendFront</a></p>
</li>
<li>
<p><a href="./core-metaprogramming-TupleSnapForward.html">TupleSnapForward</a></p>
</li>
<li>
<p><a href="./core-metaprogramming-SnapRemove.html">SnapRemove</a></p>
</li>
<li>
<p><a href="./core-iter-traits-iterator-Iterator.html">Iterator</a></p>
</li>
<li>
<p><a href="./core-iter-traits-iterator-IntoIterator.html">IntoIterator</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy"><a class="header" href="#copy">Copy</a></h1>
<p>Fully qualified path: <code>core::traits::Copy</code></p>
<pre><code class="language-rust">pub trait Copy&lt;T&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop"><a class="header" href="#drop">Drop</a></h1>
<p>Fully qualified path: <code>core::traits::Drop</code></p>
<pre><code class="language-rust">pub trait Drop&lt;T&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add"><a class="header" href="#add">Add</a></h1>
<p>Fully qualified path: <code>core::traits::Add</code></p>
<pre><code class="language-rust">pub trait Add&lt;T&gt;</code></pre>
<h2 id="trait-functions"><a class="header" href="#trait-functions">Trait functions</a></h2>
<h3 id="add-1"><a class="header" href="#add-1">add</a></h3>
<p>Fully qualified path: <code>core::traits::Add::add</code></p>
<pre><code class="language-rust">fn add(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addeq"><a class="header" href="#addeq">AddEq</a></h1>
<p>Fully qualified path: <code>core::traits::AddEq</code></p>
<pre><code class="language-rust">pub trait AddEq&lt;T&gt;</code></pre>
<h2 id="trait-functions-1"><a class="header" href="#trait-functions-1">Trait functions</a></h2>
<h3 id="add_eq"><a class="header" href="#add_eq">add_eq</a></h3>
<p>Fully qualified path: <code>core::traits::AddEq::add_eq</code></p>
<pre><code class="language-rust">fn add_eq(ref self: T, other: T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sub"><a class="header" href="#sub">Sub</a></h1>
<p>Fully qualified path: <code>core::traits::Sub</code></p>
<pre><code class="language-rust">pub trait Sub&lt;T&gt;</code></pre>
<h2 id="trait-functions-2"><a class="header" href="#trait-functions-2">Trait functions</a></h2>
<h3 id="sub-1"><a class="header" href="#sub-1">sub</a></h3>
<p>Fully qualified path: <code>core::traits::Sub::sub</code></p>
<pre><code class="language-rust">fn sub(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subeq"><a class="header" href="#subeq">SubEq</a></h1>
<p>Fully qualified path: <code>core::traits::SubEq</code></p>
<pre><code class="language-rust">pub trait SubEq&lt;T&gt;</code></pre>
<h2 id="trait-functions-3"><a class="header" href="#trait-functions-3">Trait functions</a></h2>
<h3 id="sub_eq"><a class="header" href="#sub_eq">sub_eq</a></h3>
<p>Fully qualified path: <code>core::traits::SubEq::sub_eq</code></p>
<pre><code class="language-rust">fn sub_eq(ref self: T, other: T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mul"><a class="header" href="#mul">Mul</a></h1>
<p>Fully qualified path: <code>core::traits::Mul</code></p>
<pre><code class="language-rust">pub trait Mul&lt;T&gt;</code></pre>
<h2 id="trait-functions-4"><a class="header" href="#trait-functions-4">Trait functions</a></h2>
<h3 id="mul-1"><a class="header" href="#mul-1">mul</a></h3>
<p>Fully qualified path: <code>core::traits::Mul::mul</code></p>
<pre><code class="language-rust">fn mul(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="muleq"><a class="header" href="#muleq">MulEq</a></h1>
<p>Fully qualified path: <code>core::traits::MulEq</code></p>
<pre><code class="language-rust">pub trait MulEq&lt;T&gt;</code></pre>
<h2 id="trait-functions-5"><a class="header" href="#trait-functions-5">Trait functions</a></h2>
<h3 id="mul_eq"><a class="header" href="#mul_eq">mul_eq</a></h3>
<p>Fully qualified path: <code>core::traits::MulEq::mul_eq</code></p>
<pre><code class="language-rust">fn mul_eq(ref self: T, other: T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="div"><a class="header" href="#div">Div</a></h1>
<p>Fully qualified path: <code>core::traits::Div</code></p>
<pre><code class="language-rust">pub trait Div&lt;T&gt;</code></pre>
<h2 id="trait-functions-6"><a class="header" href="#trait-functions-6">Trait functions</a></h2>
<h3 id="div-1"><a class="header" href="#div-1">div</a></h3>
<p>Fully qualified path: <code>core::traits::Div::div</code></p>
<pre><code class="language-rust">fn div(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diveq"><a class="header" href="#diveq">DivEq</a></h1>
<p>Fully qualified path: <code>core::traits::DivEq</code></p>
<pre><code class="language-rust">pub trait DivEq&lt;T&gt;</code></pre>
<h2 id="trait-functions-7"><a class="header" href="#trait-functions-7">Trait functions</a></h2>
<h3 id="div_eq"><a class="header" href="#div_eq">div_eq</a></h3>
<p>Fully qualified path: <code>core::traits::DivEq::div_eq</code></p>
<pre><code class="language-rust">fn div_eq(ref self: T, other: T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rem"><a class="header" href="#rem">Rem</a></h1>
<p>Fully qualified path: <code>core::traits::Rem</code></p>
<pre><code class="language-rust">pub trait Rem&lt;T&gt;</code></pre>
<h2 id="trait-functions-8"><a class="header" href="#trait-functions-8">Trait functions</a></h2>
<h3 id="rem-1"><a class="header" href="#rem-1">rem</a></h3>
<p>Fully qualified path: <code>core::traits::Rem::rem</code></p>
<pre><code class="language-rust">fn rem(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remeq"><a class="header" href="#remeq">RemEq</a></h1>
<p>Fully qualified path: <code>core::traits::RemEq</code></p>
<pre><code class="language-rust">pub trait RemEq&lt;T&gt;</code></pre>
<h2 id="trait-functions-9"><a class="header" href="#trait-functions-9">Trait functions</a></h2>
<h3 id="rem_eq"><a class="header" href="#rem_eq">rem_eq</a></h3>
<p>Fully qualified path: <code>core::traits::RemEq::rem_eq</code></p>
<pre><code class="language-rust">fn rem_eq(ref self: T, other: T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="divrem"><a class="header" href="#divrem">DivRem</a></h1>
<p>Division with remainder.</p>
<p>Fully qualified path: <code>core::traits::DivRem</code></p>
<pre><code class="language-rust">pub trait DivRem&lt;T&gt;</code></pre>
<h2 id="trait-functions-10"><a class="header" href="#trait-functions-10">Trait functions</a></h2>
<h3 id="div_rem"><a class="header" href="#div_rem">div_rem</a></h3>
<p>Fully qualified path: <code>core::traits::DivRem::div_rem</code></p>
<pre><code class="language-rust">fn div_rem(lhs: T, rhs: NonZero&lt;T&gt;) -&gt; (T, T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="partialeq"><a class="header" href="#partialeq">PartialEq</a></h1>
<p>Fully qualified path: <code>core::traits::PartialEq</code></p>
<pre><code class="language-rust">pub trait PartialEq&lt;T&gt;</code></pre>
<h2 id="trait-functions-11"><a class="header" href="#trait-functions-11">Trait functions</a></h2>
<h3 id="eq"><a class="header" href="#eq">eq</a></h3>
<p>Fully qualified path: <code>core::traits::PartialEq::eq</code></p>
<pre><code class="language-rust">fn eq(lhs: @T, rhs: @T) -&gt; bool</code></pre>
<h3 id="ne"><a class="header" href="#ne">ne</a></h3>
<p>Fully qualified path: <code>core::traits::PartialEq::ne</code></p>
<pre><code class="language-rust">fn ne(lhs: @T, rhs: @T) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitand"><a class="header" href="#bitand">BitAnd</a></h1>
<p>Fully qualified path: <code>core::traits::BitAnd</code></p>
<pre><code class="language-rust">pub trait BitAnd&lt;T&gt;</code></pre>
<h2 id="trait-functions-12"><a class="header" href="#trait-functions-12">Trait functions</a></h2>
<h3 id="bitand-1"><a class="header" href="#bitand-1">bitand</a></h3>
<p>Fully qualified path: <code>core::traits::BitAnd::bitand</code></p>
<pre><code class="language-rust">fn bitand(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitor"><a class="header" href="#bitor">BitOr</a></h1>
<p>Fully qualified path: <code>core::traits::BitOr</code></p>
<pre><code class="language-rust">pub trait BitOr&lt;T&gt;</code></pre>
<h2 id="trait-functions-13"><a class="header" href="#trait-functions-13">Trait functions</a></h2>
<h3 id="bitor-1"><a class="header" href="#bitor-1">bitor</a></h3>
<p>Fully qualified path: <code>core::traits::BitOr::bitor</code></p>
<pre><code class="language-rust">fn bitor(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitxor"><a class="header" href="#bitxor">BitXor</a></h1>
<p>Fully qualified path: <code>core::traits::BitXor</code></p>
<pre><code class="language-rust">pub trait BitXor&lt;T&gt;</code></pre>
<h2 id="trait-functions-14"><a class="header" href="#trait-functions-14">Trait functions</a></h2>
<h3 id="bitxor-1"><a class="header" href="#bitxor-1">bitxor</a></h3>
<p>Fully qualified path: <code>core::traits::BitXor::bitxor</code></p>
<pre><code class="language-rust">fn bitxor(lhs: T, rhs: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitnot"><a class="header" href="#bitnot">BitNot</a></h1>
<p>Fully qualified path: <code>core::traits::BitNot</code></p>
<pre><code class="language-rust">pub trait BitNot&lt;T&gt;</code></pre>
<h2 id="trait-functions-15"><a class="header" href="#trait-functions-15">Trait functions</a></h2>
<h3 id="bitnot-1"><a class="header" href="#bitnot-1">bitnot</a></h3>
<p>Fully qualified path: <code>core::traits::BitNot::bitnot</code></p>
<pre><code class="language-rust">fn bitnot(a: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="partialord"><a class="header" href="#partialord">PartialOrd</a></h1>
<p>Fully qualified path: <code>core::traits::PartialOrd</code></p>
<pre><code class="language-rust">pub trait PartialOrd&lt;T&gt;</code></pre>
<h2 id="trait-functions-16"><a class="header" href="#trait-functions-16">Trait functions</a></h2>
<h3 id="lt"><a class="header" href="#lt">lt</a></h3>
<p>Fully qualified path: <code>core::traits::PartialOrd::lt</code></p>
<pre><code class="language-rust">fn lt(lhs: T, rhs: T) -&gt; bool</code></pre>
<h3 id="ge"><a class="header" href="#ge">ge</a></h3>
<p>Fully qualified path: <code>core::traits::PartialOrd::ge</code></p>
<pre><code class="language-rust">fn ge(lhs: T, rhs: T) -&gt; bool</code></pre>
<h3 id="gt"><a class="header" href="#gt">gt</a></h3>
<p>Fully qualified path: <code>core::traits::PartialOrd::gt</code></p>
<pre><code class="language-rust">fn gt(lhs: T, rhs: T) -&gt; bool</code></pre>
<h3 id="le"><a class="header" href="#le">le</a></h3>
<p>Fully qualified path: <code>core::traits::PartialOrd::le</code></p>
<pre><code class="language-rust">fn le(lhs: T, rhs: T) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="into"><a class="header" href="#into">Into</a></h1>
<p>Trait for conversion between types.</p>
<p>Fully qualified path: <code>core::traits::Into</code></p>
<pre><code class="language-rust">pub trait Into&lt;T, S&gt;</code></pre>
<h2 id="trait-functions-17"><a class="header" href="#trait-functions-17">Trait functions</a></h2>
<h3 id="into-1"><a class="header" href="#into-1">into</a></h3>
<p>Fully qualified path: <code>core::traits::Into::into</code></p>
<pre><code class="language-rust">fn into(self: T) -&gt; S</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tryinto"><a class="header" href="#tryinto">TryInto</a></h1>
<p>Trait for fallible conversion between types.</p>
<p>Fully qualified path: <code>core::traits::TryInto</code></p>
<pre><code class="language-rust">pub trait TryInto&lt;T, S&gt;</code></pre>
<h2 id="trait-functions-18"><a class="header" href="#trait-functions-18">Trait functions</a></h2>
<h3 id="try_into"><a class="header" href="#try_into">try_into</a></h3>
<p>Fully qualified path: <code>core::traits::TryInto::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: T) -&gt; Option&lt;S&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="neg"><a class="header" href="#neg">Neg</a></h1>
<p>Fully qualified path: <code>core::traits::Neg</code></p>
<pre><code class="language-rust">pub trait Neg&lt;T&gt;</code></pre>
<h2 id="trait-functions-19"><a class="header" href="#trait-functions-19">Trait functions</a></h2>
<h3 id="neg-1"><a class="header" href="#neg-1">neg</a></h3>
<p>Fully qualified path: <code>core::traits::Neg::neg</code></p>
<pre><code class="language-rust">fn neg(a: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="not"><a class="header" href="#not">Not</a></h1>
<p>Fully qualified path: <code>core::traits::Not</code></p>
<pre><code class="language-rust">pub trait Not&lt;T&gt;</code></pre>
<h2 id="trait-functions-20"><a class="header" href="#trait-functions-20">Trait functions</a></h2>
<h3 id="not-1"><a class="header" href="#not-1">not</a></h3>
<p>Fully qualified path: <code>core::traits::Not::not</code></p>
<pre><code class="language-rust">fn not(a: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexview"><a class="header" href="#indexview">IndexView</a></h1>
<p>The following two traits are for implementing the [] operator. Only one should be implemented for each type. Both are not consuming of self, the first gets a snapshot of the object and the second gets ref.</p>
<p>Fully qualified path: <code>core::traits::IndexView</code></p>
<pre><code class="language-rust">pub trait IndexView&lt;C, I, V&gt;</code></pre>
<h2 id="trait-functions-21"><a class="header" href="#trait-functions-21">Trait functions</a></h2>
<h3 id="index-1"><a class="header" href="#index-1">index</a></h3>
<p>Fully qualified path: <code>core::traits::IndexView::index</code></p>
<pre><code class="language-rust">fn index(self: @C, index: I) -&gt; V</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-2"><a class="header" href="#index-2">Index</a></h1>
<p>Fully qualified path: <code>core::traits::Index</code></p>
<pre><code class="language-rust">pub trait Index&lt;C, I, V&gt;</code></pre>
<h2 id="trait-functions-22"><a class="header" href="#trait-functions-22">Trait functions</a></h2>
<h3 id="index-3"><a class="header" href="#index-3">index</a></h3>
<p>Fully qualified path: <code>core::traits::Index::index</code></p>
<pre><code class="language-rust">fn index(ref self: C, index: I) -&gt; V</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destruct"><a class="header" href="#destruct">Destruct</a></h1>
<p>Fully qualified path: <code>core::traits::Destruct</code></p>
<pre><code class="language-rust">pub trait Destruct&lt;T&gt;</code></pre>
<h2 id="trait-functions-23"><a class="header" href="#trait-functions-23">Trait functions</a></h2>
<h3 id="destruct-1"><a class="header" href="#destruct-1">destruct</a></h3>
<p>Fully qualified path: <code>core::traits::Destruct::destruct</code></p>
<pre><code class="language-rust">fn destruct(self: T) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panicdestruct"><a class="header" href="#panicdestruct">PanicDestruct</a></h1>
<p>Fully qualified path: <code>core::traits::PanicDestruct</code></p>
<pre><code class="language-rust">pub trait PanicDestruct&lt;T&gt;</code></pre>
<h2 id="trait-functions-24"><a class="header" href="#trait-functions-24">Trait functions</a></h2>
<h3 id="panic_destruct"><a class="header" href="#panic_destruct">panic_destruct</a></h3>
<p>Fully qualified path: <code>core::traits::PanicDestruct::panic_destruct</code></p>
<pre><code class="language-rust">fn panic_destruct(self: T, ref panic: Panic) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default"><a class="header" href="#default">Default</a></h1>
<p>Fully qualified path: <code>core::traits::Default</code></p>
<pre><code class="language-rust">pub trait Default&lt;T&gt;</code></pre>
<h2 id="trait-functions-25"><a class="header" href="#trait-functions-25">Trait functions</a></h2>
<h3 id="default-1"><a class="header" href="#default-1">default</a></h3>
<p>Fully qualified path: <code>core::traits::Default::default</code></p>
<pre><code class="language-rust">fn default() -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252dictvalue"><a class="header" href="#felt252dictvalue">Felt252DictValue</a></h1>
<p>Trait for types allowed as values in a Felt252Dict.</p>
<p>Fully qualified path: <code>core::traits::Felt252DictValue</code></p>
<pre><code class="language-rust">pub trait Felt252DictValue&lt;T&gt;</code></pre>
<h2 id="trait-functions-26"><a class="header" href="#trait-functions-26">Trait functions</a></h2>
<h3 id="zero_default"><a class="header" href="#zero_default">zero_default</a></h3>
<p>Returns the default value for this type as a value in a Felt252Dict. Should be logically equivalent to 0.</p>
<p>Fully qualified path: <code>core::traits::Felt252DictValue::zero_default</code></p>
<pre><code class="language-rust">fn zero_default() -&gt; T nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="booltrait"><a class="header" href="#booltrait">BoolTrait</a></h1>
<p>Fully qualified path: <code>core::boolean::BoolTrait</code></p>
<pre><code class="language-rust">pub trait BoolTrait&lt;T, +Drop&lt;T&gt;&gt;</code></pre>
<h2 id="trait-functions-27"><a class="header" href="#trait-functions-27">Trait functions</a></h2>
<h3 id="then_some"><a class="header" href="#then_some">then_some</a></h3>
<p>Returns <code>Option::Some(t)</code> if the <code>bool</code> is <code>true</code>, <code>Option::None</code> otherwise.  # Examples</p>
<pre><code class="language-cairo">assert!(false.then_some(0) == Option::None);
assert!(true.then_some(0) == Option::Some(0));
</code></pre>
<p>Fully qualified path: <code>core::boolean::BoolTrait::then_some</code></p>
<pre><code class="language-rust">fn then_some(self: bool, t: T) -&gt; Option&lt;T&gt; nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitelementtrait"><a class="header" href="#circuitelementtrait">CircuitElementTrait</a></h1>
<p>A marker trait for keeping track of which types are circuit elements.</p>
<p>Fully qualified path: <code>core::circuit::CircuitElementTrait</code></p>
<pre><code class="language-rust">pub trait CircuitElementTrait&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitoutputstrait"><a class="header" href="#circuitoutputstrait">CircuitOutputsTrait</a></h1>
<p>A trait for evaluating a circuit.</p>
<p>Fully qualified path: <code>core::circuit::CircuitOutputsTrait</code></p>
<pre><code class="language-rust">pub trait CircuitOutputsTrait&lt;Outputs, OutputElement&gt;</code></pre>
<h2 id="trait-functions-28"><a class="header" href="#trait-functions-28">Trait functions</a></h2>
<h3 id="get_output"><a class="header" href="#get_output">get_output</a></h3>
<p>Evaluates the circuit with the given data and modulus.</p>
<p>Fully qualified path: <code>core::circuit::CircuitOutputsTrait::get_output</code></p>
<pre><code class="language-rust">fn get_output(self: Outputs, output: OutputElement) -&gt; u384</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitinputs"><a class="header" href="#circuitinputs">CircuitInputs</a></h1>
<p>Fully qualified path: <code>core::circuit::CircuitInputs</code></p>
<pre><code class="language-rust">pub trait CircuitInputs&lt;CES&gt;</code></pre>
<h2 id="trait-functions-29"><a class="header" href="#trait-functions-29">Trait functions</a></h2>
<h3 id="new_inputs"><a class="header" href="#new_inputs">new_inputs</a></h3>
<p>calls <code>init_circuit_data</code> for the given circuit.</p>
<p>Fully qualified path: <code>core::circuit::CircuitInputs::new_inputs</code></p>
<pre><code class="language-rust">fn new_inputs&lt;impl CD: CircuitDefinition&lt;CES&gt;, +Drop&lt;CES&gt;&gt;(
    self: CES,
) -&gt; AddInputResult&lt;CD::CircuitType&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addinputresulttrait"><a class="header" href="#addinputresulttrait">AddInputResultTrait</a></h1>
<p>Fully qualified path: <code>core::circuit::AddInputResultTrait</code></p>
<pre><code class="language-rust">pub trait AddInputResultTrait&lt;C&gt;</code></pre>
<h2 id="trait-functions-30"><a class="header" href="#trait-functions-30">Trait functions</a></h2>
<h3 id="next"><a class="header" href="#next">next</a></h3>
<p>Adds an input to the accumulator.</p>
<p>Fully qualified path: <code>core::circuit::AddInputResultTrait::next</code></p>
<pre><code class="language-rust">fn next&lt;Value, +IntoCircuitInputValue&lt;Value&gt;, +Drop&lt;Value&gt;&gt;(
    self: AddInputResult&lt;C&gt;, value: Value,
) -&gt; AddInputResult&lt;C&gt;</code></pre>
<h3 id="done-1"><a class="header" href="#done-1">done</a></h3>
<p>Fully qualified path: <code>core::circuit::AddInputResultTrait::done</code></p>
<pre><code class="language-rust">fn done(self: AddInputResult&lt;C&gt;) -&gt; CircuitData&lt;C&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evalcircuittrait"><a class="header" href="#evalcircuittrait">EvalCircuitTrait</a></h1>
<p>Fully qualified path: <code>core::circuit::EvalCircuitTrait</code></p>
<pre><code class="language-rust">pub trait EvalCircuitTrait&lt;C&gt;</code></pre>
<h2 id="trait-functions-31"><a class="header" href="#trait-functions-31">Trait functions</a></h2>
<h3 id="eval"><a class="header" href="#eval">eval</a></h3>
<p>Fully qualified path: <code>core::circuit::EvalCircuitTrait::eval</code></p>
<pre><code class="language-rust">fn eval(self: CircuitData&lt;C&gt;, modulus: CircuitModulus) -&gt; crate::circuit::EvalCircuitResult&lt;C&gt;</code></pre>
<h3 id="eval_ex"><a class="header" href="#eval_ex">eval_ex</a></h3>
<p>Fully qualified path: <code>core::circuit::EvalCircuitTrait::eval_ex</code></p>
<pre><code class="language-rust">fn eval_ex(
    self: CircuitData&lt;C&gt;, descriptor: CircuitDescriptor&lt;C&gt;, modulus: CircuitModulus,
) -&gt; crate::circuit::EvalCircuitResult&lt;C&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boxtrait"><a class="header" href="#boxtrait">BoxTrait</a></h1>
<p>Fully qualified path: <code>core::box::BoxTrait</code></p>
<pre><code class="language-rust">pub trait BoxTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-32"><a class="header" href="#trait-functions-32">Trait functions</a></h2>
<h3 id="new"><a class="header" href="#new">new</a></h3>
<p>Creates a new <code>Box</code> with the given value.  Allocates space in the boxed segment for the provided value and returns a <code>Box&lt;T&gt;</code> that points to it. # Examples</p>
<pre><code class="language-cairo">let x = 42;
let boxed_x = BoxTrait::new(x);
</code></pre>
<p>Fully qualified path: <code>core::box::BoxTrait::new</code></p>
<pre><code class="language-rust">fn new(value: T) -&gt; Box&lt;T&gt; nopanic</code></pre>
<h3 id="unbox"><a class="header" href="#unbox">unbox</a></h3>
<p>Unboxes the given <code>Box</code> and returns the wrapped value.  # Examples</p>
<pre><code class="language-cairo">let boxed = BoxTrait::new(42);
assert!(boxed.unbox() == 42);
</code></pre>
<p>Fully qualified path: <code>core::box::BoxTrait::unbox</code></p>
<pre><code class="language-rust">fn unbox(self: Box&lt;T&gt;) -&gt; T nopanic</code></pre>
<h3 id="as_snapshot"><a class="header" href="#as_snapshot">as_snapshot</a></h3>
<p>Converts the given snapshot of a <code>Box</code> into a <code>Box</code> of a snapshot. Useful for structures that aren't copyable.  # Examples</p>
<pre><code class="language-cairo">let snap_boxed_arr = @BoxTraits::new(array![1, 2, 3]);
let boxed_snap_arr = snap_boxed_arr.as_snapshot();
let snap_arr = boxed_snap_arr.unbox();
</code></pre>
<p>Fully qualified path: <code>core::box::BoxTrait::as_snapshot</code></p>
<pre><code class="language-rust">fn as_snapshot(self: @Box&lt;T&gt;) -&gt; Box&lt;@T&gt; nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullabletrait"><a class="header" href="#nullabletrait">NullableTrait</a></h1>
<p>Fully qualified path: <code>core::nullable::NullableTrait</code></p>
<pre><code class="language-rust">pub trait NullableTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-33"><a class="header" href="#trait-functions-33">Trait functions</a></h2>
<h3 id="deref"><a class="header" href="#deref">deref</a></h3>
<p>Wrapper for <code>Deref::deref</code>. Prefer using <code>Deref::deref</code> directly.  This function exists for backwards compatibility.  # Examples  Preferred way:</p>
<pre><code class="language-cairo">let value: Nullable&lt;u32&gt; = NullableTrait::new(42);
let unwrapped = value.deref();
</code></pre>
<p>This function method does the same thing:</p>
<pre><code class="language-cairo">use core::nullable::NullableTrait;
let also_unwrapped = NullableTrait::deref(value);
</code></pre>
<p>Fully qualified path: <code>core::nullable::NullableTrait::deref</code></p>
<pre><code class="language-rust">fn deref(nullable: Nullable&lt;T&gt;) -&gt; T</code></pre>
<h3 id="deref_or"><a class="header" href="#deref_or">deref_or</a></h3>
<p>Returns the contained value if not null, or returns the provided default value.  # Examples</p>
<pre><code class="language-cairo">let value: Nullable&lt;u32&gt; = NullableTrait::new(42);
assert!(value.deref_or(0) == 42);

let null_value: Nullable&lt;u32&gt; = Default::default();
assert!(null_value.deref_or(0) == 0);
</code></pre>
<p>Fully qualified path: <code>core::nullable::NullableTrait::deref_or</code></p>
<pre><code class="language-rust">fn deref_or&lt;+Drop&lt;T&gt;&gt;(self: Nullable&lt;T&gt;, default: T) -&gt; T</code></pre>
<h3 id="new-1"><a class="header" href="#new-1">new</a></h3>
<p>Creates a new non-null <code>Nullable</code> with the given value.  # Examples</p>
<pre><code class="language-cairo">let value: Nullable&lt;u32&gt; = NullableTrait::new(42);
assert!(!value.is_null());
</code></pre>
<p>Fully qualified path: <code>core::nullable::NullableTrait::new</code></p>
<pre><code class="language-rust">fn new(value: T) -&gt; Nullable&lt;T&gt;</code></pre>
<h3 id="is_null"><a class="header" href="#is_null">is_null</a></h3>
<p>Returns <code>true</code> if the value is null.  # Examples</p>
<pre><code class="language-cairo">let value: Nullable&lt;u32&gt; = NullableTrait::new(42);
assert!(!value.is_null());

let null_value: Nullable&lt;u32&gt; = Default::default();
assert!(null_value.is_null());
</code></pre>
<p>Fully qualified path: <code>core::nullable::NullableTrait::is_null</code></p>
<pre><code class="language-rust">fn is_null(self: @Nullable&lt;T&gt;) -&gt; bool</code></pre>
<h3 id="as_snapshot-1"><a class="header" href="#as_snapshot-1">as_snapshot</a></h3>
<p>Creates a new <code>Nullable</code> containing a snapshot of the value.  This is useful when working with non-copyable types inside a <code>Nullable</code>. This allows you to keep using the original value while also having access to a snapshot of it, preventing the original value from being moved.  # Examples</p>
<pre><code class="language-cairo">let value: Nullable&lt;Array&lt;u32&gt;&gt; = NullableTrait::new(array![1, 2, 3]);
let res = (@value).as_snapshot();
assert!(res.deref() == @array![1, 2, 3]);
assert!(value.deref() == array![1, 2, 3]);
</code></pre>
<p>Fully qualified path: <code>core::nullable::NullableTrait::as_snapshot</code></p>
<pre><code class="language-rust">fn as_snapshot(self: @Nullable&lt;T&gt;) -&gt; Nullable&lt;@T&gt; nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tospantrait"><a class="header" href="#tospantrait">ToSpanTrait</a></h1>
<p><code>ToSpanTrait</code> converts a data structure into a span of its data.</p>
<p>Fully qualified path: <code>core::array::ToSpanTrait</code></p>
<pre><code class="language-rust">pub trait ToSpanTrait&lt;C, T&gt;</code></pre>
<h2 id="trait-functions-34"><a class="header" href="#trait-functions-34">Trait functions</a></h2>
<h3 id="span-1"><a class="header" href="#span-1">span</a></h3>
<p>Returns a span pointing to the data in the input.</p>
<p>Fully qualified path: <code>core::array::ToSpanTrait::span</code></p>
<pre><code class="language-rust">fn span(self: @C) -&gt; Span&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arraytrait"><a class="header" href="#arraytrait">ArrayTrait</a></h1>
<p>Fully qualified path: <code>core::array::ArrayTrait</code></p>
<pre><code class="language-rust">pub trait ArrayTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-35"><a class="header" href="#trait-functions-35">Trait functions</a></h2>
<h3 id="new-2"><a class="header" href="#new-2">new</a></h3>
<p>Constructs a new, empty <code>Array&lt;T&gt;</code>.  # Examples</p>
<pre><code class="language-cairo">let arr: Array&lt;u32&gt; = ArrayTrait::new();

let arr = ArrayTrait::&lt;u128&gt;::new();
</code></pre>
<p>It is also possible to use the <code>array!</code> macro to create a new array.</p>
<pre><code class="language-cairo">let arr: Array&lt;bool&gt; = array![];
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::new</code></p>
<pre><code class="language-rust">fn new() -&gt; Array&lt;T&gt; nopanic</code></pre>
<h3 id="append"><a class="header" href="#append">append</a></h3>
<p>Adds a value of type <code>T</code> to the end of the array.  # Examples</p>
<pre><code class="language-cairo">let mut arr: Array&lt;u8&gt; = array![1, 2];
arr.append(3);
assert!(arr == array![1, 2, 3]);
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::append</code></p>
<pre><code class="language-rust">fn append(ref self: Array&lt;T&gt;, value: T) nopanic</code></pre>
<h3 id="append_span"><a class="header" href="#append_span">append_span</a></h3>
<p>Adds a span to the end of the array.  # Examples</p>
<pre><code class="language-cairo">let mut arr: Array&lt;u8&gt; = array![];
arr.append_span(array![1, 2, 3].span());
assert!(arr == array![1, 2, 3]);
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::append_span</code></p>
<pre><code class="language-rust">fn append_span&lt;+Clone&lt;T&gt;, +Drop&lt;T&gt;&gt;(ref self: Array&lt;T&gt;, span: Span&lt;T&gt;)</code></pre>
<h3 id="pop_front"><a class="header" href="#pop_front">pop_front</a></h3>
<p>Pops a value from the front of the array. Returns <code>Option::Some(value)</code> if the array is not empty, <code>Option::None</code> otherwise.  # Examples</p>
<pre><code class="language-cairo">let mut arr = array![2, 3, 4];
assert!(arr.pop_front() == Option::Some(2));
assert!(arr.pop_front() == Option::Some(3));
assert!(arr.pop_front() == Option::Some(4));
assert!(arr.pop_front().is_none());
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::pop_front</code></p>
<pre><code class="language-rust">fn pop_front(ref self: Array&lt;T&gt;) -&gt; Option&lt;T&gt; nopanic</code></pre>
<h3 id="pop_front_consume"><a class="header" href="#pop_front_consume">pop_front_consume</a></h3>
<p>Pops a value from the front of the array. Returns an option containing the remaining array and the value removed if the array is not empty, otherwise <code>Option::None</code> and drops the array.  # Examples</p>
<pre><code class="language-cairo">let arr = array![2, 3, 4];
assert!(arr.pop_front_consume() == Option::Some((array![3, 4], 2)));

let arr: Array&lt;u8&gt; = array![];
assert!(arr.pop_front_consume().is_none());
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::pop_front_consume</code></p>
<pre><code class="language-rust">fn pop_front_consume(self: Array&lt;T&gt;) -&gt; Option&lt;(Array&lt;T&gt;, T)&gt; nopanic</code></pre>
<h3 id="get"><a class="header" href="#get">get</a></h3>
<p>Returns an option containing a box of a snapshot of the element at the given 'index' if the array contains this index, 'Option::None' otherwise.  Element at index 0 is the front of the array.  # Examples</p>
<pre><code class="language-cairo">let arr = array![2, 3, 4];
assert!(arr.get(1).unwrap().unbox() == @3);
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::get</code></p>
<pre><code class="language-rust">fn get(self: @Array&lt;T&gt;, index: usize) -&gt; Option&lt;Box&lt;@T&gt;&gt;</code></pre>
<h3 id="at"><a class="header" href="#at">at</a></h3>
<p>Returns a snapshot of the element at the given index.  Element at index 0 is the front of the array.  # Panics  Panics if the index is out of bounds.  # Examples</p>
<pre><code class="language-cairo">let mut arr: Array&lt;usize&gt; = array![3,4,5,6];
assert!(arr.at(1) == @4);
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::at</code></p>
<pre><code class="language-rust">fn at(self: @Array&lt;T&gt;, index: usize) -&gt; @T</code></pre>
<h3 id="len"><a class="header" href="#len">len</a></h3>
<p>Returns the length of the array as a <code>usize</code> value.  # Examples</p>
<pre><code class="language-cairo">let arr = array![2, 3, 4];
assert!(arr.len() == 3);
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::len</code></p>
<pre><code class="language-rust">fn len(self: @Array&lt;T&gt;) -&gt; usize</code></pre>
<h3 id="is_empty"><a class="header" href="#is_empty">is_empty</a></h3>
<p>Returns whether the array is empty or not.  # Examples</p>
<pre><code class="language-cairo">let mut arr = array![];
assert!(arr.is_empty());
arr.append(1);
assert!(!arr.is_empty());
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::is_empty</code></p>
<pre><code class="language-rust">fn is_empty(self: @Array&lt;T&gt;) -&gt; bool</code></pre>
<h3 id="span-2"><a class="header" href="#span-2">span</a></h3>
<p>Returns a span of the array.  # Examples</p>
<pre><code class="language-cairo">let arr: Array&lt;u8&gt; = array![1, 2, 3];
let span: Span&lt;u8&gt; = arr.span();
</code></pre>
<p>Fully qualified path: <code>core::array::ArrayTrait::span</code></p>
<pre><code class="language-rust">fn span(snapshot: @Array&lt;T&gt;) -&gt; Span&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spantrait"><a class="header" href="#spantrait">SpanTrait</a></h1>
<p>Fully qualified path: <code>core::array::SpanTrait</code></p>
<pre><code class="language-rust">pub trait SpanTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-36"><a class="header" href="#trait-functions-36">Trait functions</a></h2>
<h3 id="pop_front-1"><a class="header" href="#pop_front-1">pop_front</a></h3>
<p>Pops a value from the front of the span. Returns <code>Option::Some(@value)</code> if the array is not empty, <code>Option::None</code> otherwise.  # Examples</p>
<pre><code class="language-cairo">let mut span = array![1, 2, 3].span();
assert!(span.pop_front() == Option::Some(@1));
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::pop_front</code></p>
<pre><code class="language-rust">fn pop_front(ref self: Span&lt;T&gt;) -&gt; Option&lt;@T&gt;</code></pre>
<h3 id="pop_back"><a class="header" href="#pop_back">pop_back</a></h3>
<p>Pops a value from the back of the span. Returns <code>Option::Some(@value)</code> if the array is not empty, <code>Option::None</code> otherwise.  # Examples</p>
<pre><code class="language-cairo">let mut span = array![1, 2, 3].span();
assert!(span.pop_back() == Option::Some(@3));
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::pop_back</code></p>
<pre><code class="language-rust">fn pop_back(ref self: Span&lt;T&gt;) -&gt; Option&lt;@T&gt;</code></pre>
<h3 id="multi_pop_front"><a class="header" href="#multi_pop_front">multi_pop_front</a></h3>
<p>Pops multiple values from the front of the span. Returns an option containing a snapshot of a box that contains the values as a fixed-size array if the action completed successfully, 'Option::None' otherwise.  # Examples</p>
<pre><code class="language-cairo">let mut span = array![1, 2, 3].span();
let result = *(span.multi_pop_front::&lt;2&gt;().unwrap());
let unboxed_result = result.unbox();
assert!(unboxed_result == [1, 2]);
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::multi_pop_front</code></p>
<pre><code class="language-rust">fn multi_pop_front&lt;const SIZE: usize&gt;(ref self: Span&lt;T&gt;) -&gt; Option&lt;@Box&lt;[T; SIZE]&gt;&gt;</code></pre>
<h3 id="multi_pop_back"><a class="header" href="#multi_pop_back">multi_pop_back</a></h3>
<p>Pops multiple values from the back of the span. Returns an option containing a snapshot of a box that contains the values as a fixed-size array if the action completed successfully, 'Option::None' otherwise.  # Examples</p>
<pre><code class="language-cairo">let mut span = array![1, 2, 3].span();
let result = *(span.multi_pop_back::&lt;2&gt;().unwrap());
let unboxed_result = result.unbox();
assert!(unboxed_result == [2, 3]);;
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::multi_pop_back</code></p>
<pre><code class="language-rust">fn multi_pop_back&lt;const SIZE: usize&gt;(ref self: Span&lt;T&gt;) -&gt; Option&lt;@Box&lt;[T; SIZE]&gt;&gt;</code></pre>
<h3 id="get-1"><a class="header" href="#get-1">get</a></h3>
<p>Returns an option containing a box of a snapshot of the element at the given 'index' if the span contains this index, 'Option::None' otherwise.  Element at index 0 is the front of the array.  # Examples</p>
<pre><code class="language-cairo">let span = array![2, 3, 4];
assert!(span.get(1).unwrap().unbox() == @3);
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::get</code></p>
<pre><code class="language-rust">fn get(self: Span&lt;T&gt;, index: usize) -&gt; Option&lt;Box&lt;@T&gt;&gt;</code></pre>
<h3 id="at-1"><a class="header" href="#at-1">at</a></h3>
<p>Returns a snapshot of the element at the given index.  Element at index 0 is the front of the array.  # Panics  Panics if the index is out of bounds.  # Examples</p>
<pre><code class="language-cairo">let span = array![2, 3, 4].span();
assert!(span.at(1) == @3);
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::at</code></p>
<pre><code class="language-rust">fn at(self: Span&lt;T&gt;, index: usize) -&gt; @T</code></pre>
<h3 id="slice"><a class="header" href="#slice">slice</a></h3>
<p>Returns a span containing values from the 'start' index, with amount equal to 'length'.  # Examples</p>
<pre><code class="language-cairo">let span = array![1, 2, 3].span();
assert!(span.slice(1, 2) == array![2, 3].span());
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::slice</code></p>
<pre><code class="language-rust">fn slice(self: Span&lt;T&gt;, start: usize, length: usize) -&gt; Span&lt;T&gt;</code></pre>
<h3 id="len-1"><a class="header" href="#len-1">len</a></h3>
<p>Returns the length of the span as a <code>usize</code> value.  # Examples</p>
<pre><code class="language-cairo">let span = array![2, 3, 4].span();
assert!(span.len() == 3);
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::len</code></p>
<pre><code class="language-rust">fn len(self: Span&lt;T&gt;) -&gt; usize</code></pre>
<h3 id="is_empty-1"><a class="header" href="#is_empty-1">is_empty</a></h3>
<p>Returns whether the span is empty or not.  # Examples</p>
<pre><code class="language-cairo">let span: Span&lt;felt252&gt; = array![].span();
assert!(span.is_empty());
let span = array![1, 2, 3].span();
assert!(!span.is_empty());
</code></pre>
<p>Fully qualified path: <code>core::array::SpanTrait::is_empty</code></p>
<pre><code class="language-rust">fn is_empty(self: Span&lt;T&gt;) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252dicttrait"><a class="header" href="#felt252dicttrait">Felt252DictTrait</a></h1>
<p>Basic trait for the <code>Felt252Dict</code> type.</p>
<p>Fully qualified path: <code>core::dict::Felt252DictTrait</code></p>
<pre><code class="language-rust">pub trait Felt252DictTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-37"><a class="header" href="#trait-functions-37">Trait functions</a></h2>
<h3 id="insert"><a class="header" href="#insert">insert</a></h3>
<p>Inserts the given value for the given key.  # Examples</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

let mut dict: Felt252Dict&lt;u8&gt; = Default::default();
dict.insert(0, 10);
</code></pre>
<p>Fully qualified path: <code>core::dict::Felt252DictTrait::insert</code></p>
<pre><code class="language-rust">fn insert&lt;+Destruct&lt;T&gt;&gt;(ref self: Felt252Dict&lt;T&gt;, key: felt252, value: T)</code></pre>
<h3 id="get-2"><a class="header" href="#get-2">get</a></h3>
<p>Returns the value stored at the given key. If no value was previously inserted at this key, returns the default value for type T.  # Examples</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

let mut dict: Felt252Dict&lt;u8&gt; = Default::default();
dict.insert(0, 10);
let value = dict.get(0);
assert!(value == 10);
</code></pre>
<p>Fully qualified path: <code>core::dict::Felt252DictTrait::get</code></p>
<pre><code class="language-rust">fn get&lt;+Copy&lt;T&gt;&gt;(ref self: Felt252Dict&lt;T&gt;, key: felt252) -&gt; T</code></pre>
<h3 id="squash"><a class="header" href="#squash">squash</a></h3>
<p>Squashes a dictionary and returns the associated <code>SquashedFelt252Dict</code>.  # Examples</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

let mut dict: Felt252Dict&lt;u8&gt; = Default::default();
dict.insert(0, 10);
let squashed_dict = dict.squash();
</code></pre>
<p>Fully qualified path: <code>core::dict::Felt252DictTrait::squash</code></p>
<pre><code class="language-rust">fn squash(self: Felt252Dict&lt;T&gt;) -&gt; SquashedFelt252Dict&lt;T&gt; nopanic</code></pre>
<h3 id="entry"><a class="header" href="#entry">entry</a></h3>
<p>Retrieves the last entry for a certain key. This method takes ownership of the dictionary and returns the entry to update, as well as the previous value at the given key.  # Examples</p>
<pre><code class="language-cairo">use core::dict::Felt252Dict;

let mut dict: Felt252Dict&lt;u8&gt; = Default::default();
dict.insert(0, 10);
let (entry, prev_value) = dict.entry(0);
assert!(prev_value == 10);
</code></pre>
<p>Fully qualified path: <code>core::dict::Felt252DictTrait::entry</code></p>
<pre><code class="language-rust">fn entry(self: Felt252Dict&lt;T&gt;, key: felt252) -&gt; (Felt252DictEntry&lt;T&gt;, T) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252dictentrytrait"><a class="header" href="#felt252dictentrytrait">Felt252DictEntryTrait</a></h1>
<p>Basic trait for the <code>Felt252DictEntryTrait</code> type.</p>
<p>Fully qualified path: <code>core::dict::Felt252DictEntryTrait</code></p>
<pre><code class="language-rust">pub trait Felt252DictEntryTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-38"><a class="header" href="#trait-functions-38">Trait functions</a></h2>
<h3 id="finalize"><a class="header" href="#finalize">finalize</a></h3>
<p>Finalizes the changes made to a dictionary entry and gives back the ownership of the dictionary.  # Examples</p>
<pre><code class="language-cairo">use core::dict::Felt252DictEntryTrait;

// Create a dictionary that stores arrays
let mut dict: Felt252Dict&lt;Nullable&lt;Array&lt;felt252&gt;&gt;&gt; = Default::default();

let a = array![1, 2, 3];
dict.insert(0, NullableTrait::new(a));

let (entry, prev_value) = dict.entry(0);
let new_value = NullableTrait::new(array![4, 5, 6]);
dict = entry.finalize(new_value);
assert!(prev_value == a);
assert!(dict.get(0) == new_value);
</code></pre>
<p>Fully qualified path: <code>core::dict::Felt252DictEntryTrait::finalize</code></p>
<pre><code class="language-rust">fn finalize(self: Felt252DictEntry&lt;T&gt;, new_value: T) -&gt; Felt252Dict&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resulttrait"><a class="header" href="#resulttrait">ResultTrait</a></h1>
<p>Fully qualified path: <code>core::result::ResultTrait</code></p>
<pre><code class="language-rust">pub trait ResultTrait&lt;T, E&gt;</code></pre>
<h2 id="trait-functions-39"><a class="header" href="#trait-functions-39">Trait functions</a></h2>
<h3 id="expect"><a class="header" href="#expect">expect</a></h3>
<p>If <code>val</code> is <code>Result::Ok(x)</code>, returns <code>x</code>. Otherwise, panics with <code>err</code>.</p>
<p>Fully qualified path: <code>core::result::ResultTrait::expect</code></p>
<pre><code class="language-rust">fn expect&lt;+PanicDestruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;, err: felt252) -&gt; T</code></pre>
<h3 id="unwrap"><a class="header" href="#unwrap">unwrap</a></h3>
<p>If <code>val</code> is <code>Result::Ok(x)</code>, returns <code>x</code>. Otherwise, panics.</p>
<p>Fully qualified path: <code>core::result::ResultTrait::unwrap</code></p>
<pre><code class="language-rust">fn unwrap&lt;+Destruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; T</code></pre>
<h3 id="unwrap_or"><a class="header" href="#unwrap_or">unwrap_or</a></h3>
<p>If <code>val</code> is <code>Result::Ok(x)</code>, returns <code>x</code>. Otherwise, returns <code>default</code>.</p>
<p>Fully qualified path: <code>core::result::ResultTrait::unwrap_or</code></p>
<pre><code class="language-rust">fn unwrap_or&lt;+Destruct&lt;T&gt;, +Destruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;, default: T) -&gt; T</code></pre>
<h3 id="unwrap_or_default"><a class="header" href="#unwrap_or_default">unwrap_or_default</a></h3>
<p>If <code>val</code> is <code>Result::Ok(x)</code>, returns <code>x</code>. Otherwise returns <code>Default::&lt;T&gt;::default()</code>.</p>
<p>Fully qualified path: <code>core::result::ResultTrait::unwrap_or_default</code></p>
<pre><code class="language-rust">fn unwrap_or_default&lt;+Destruct&lt;E&gt;, +Default&lt;T&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; T</code></pre>
<h3 id="expect_err"><a class="header" href="#expect_err">expect_err</a></h3>
<p>If <code>val</code> is <code>Result::Err(x)</code>, returns <code>x</code>. Otherwise, panics with <code>err</code>.</p>
<p>Fully qualified path: <code>core::result::ResultTrait::expect_err</code></p>
<pre><code class="language-rust">fn expect_err&lt;+PanicDestruct&lt;T&gt;&gt;(self: Result&lt;T, E&gt;, err: felt252) -&gt; E</code></pre>
<h3 id="unwrap_err"><a class="header" href="#unwrap_err">unwrap_err</a></h3>
<p>If <code>val</code> is <code>Result::Err(x)</code>, returns <code>x</code>. Otherwise, panics.</p>
<p>Fully qualified path: <code>core::result::ResultTrait::unwrap_err</code></p>
<pre><code class="language-rust">fn unwrap_err&lt;+PanicDestruct&lt;T&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; E</code></pre>
<h3 id="is_ok"><a class="header" href="#is_ok">is_ok</a></h3>
<p>Returns <code>true</code> if the <code>Result</code> is <code>Result::Ok</code>.</p>
<p>Fully qualified path: <code>core::result::ResultTrait::is_ok</code></p>
<pre><code class="language-rust">fn is_ok(self: @Result&lt;T, E&gt;) -&gt; bool</code></pre>
<h3 id="is_err"><a class="header" href="#is_err">is_err</a></h3>
<p>Returns <code>true</code> if the <code>Result</code> is <code>Result::Err</code>.</p>
<p>Fully qualified path: <code>core::result::ResultTrait::is_err</code></p>
<pre><code class="language-rust">fn is_err(self: @Result&lt;T, E&gt;) -&gt; bool</code></pre>
<h3 id="into_is_err"><a class="header" href="#into_is_err">into_is_err</a></h3>
<p>Returns <code>true</code> if the <code>Result</code> is <code>Result::Ok</code>, and consumes the value.</p>
<p>Fully qualified path: <code>core::result::ResultTrait::into_is_err</code></p>
<pre><code class="language-rust">fn into_is_err&lt;+Destruct&lt;T&gt;, +Destruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; bool</code></pre>
<h3 id="into_is_ok"><a class="header" href="#into_is_ok">into_is_ok</a></h3>
<p>Returns <code>true</code> if the <code>Result</code> is <code>Result::Err</code>, and consumes the value.</p>
<p>Fully qualified path: <code>core::result::ResultTrait::into_is_ok</code></p>
<pre><code class="language-rust">fn into_is_ok&lt;+Destruct&lt;T&gt;, +Destruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; bool</code></pre>
<h3 id="ok-2"><a class="header" href="#ok-2">ok</a></h3>
<p>Converts from <code>Result&lt;T, E&gt;</code> to <code>Option&lt;T&gt;</code>.  Converts <code>self</code> into an <code>Option&lt;T&gt;</code>, consuming <code>self</code>, and discarding the error, if any.  # Examples</p>
<pre><code class="language-cairo">let x: Result&lt;u32, ByteArray&gt; = Result::Ok(2);
assert_eq!(x.ok(), Option::Some(2));

let x: Result&lt;u32, ByteArray&gt; = Result::Err("Nothing here");
assert!(x.ok().is_none());
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::ok</code></p>
<pre><code class="language-rust">fn ok&lt;+Destruct&lt;T&gt;, +Destruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; Option&lt;T&gt;</code></pre>
<h3 id="err-2"><a class="header" href="#err-2">err</a></h3>
<p>Converts from <code>Result&lt;T, E&gt;</code> to <code>Option&lt;E&gt;</code>.  Converts <code>self</code> into an <code>Option&lt;E&gt;</code>, consuming <code>self</code>, and discarding the success value, if any.  # Examples</p>
<pre><code class="language-cairo">let x: Result&lt;u32, ByteArray&gt; = Result::Err("Nothing here");
assert_eq!(x.err(), Option::Some("Nothing here"));

let x: Result&lt;u32, ByteArray&gt; = Result::Ok(2);
assert!(x.err().is_none());
</code></pre>
<p>Fully qualified path: <code>core::result::ResultTrait::err</code></p>
<pre><code class="language-rust">fn err&lt;+Destruct&lt;T&gt;, +Destruct&lt;E&gt;&gt;(self: Result&lt;T, E&gt;) -&gt; Option&lt;E&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optiontrait"><a class="header" href="#optiontrait">OptionTrait</a></h1>
<p>Fully qualified path: <code>core::option::OptionTrait</code></p>
<pre><code class="language-rust">pub trait OptionTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-40"><a class="header" href="#trait-functions-40">Trait functions</a></h2>
<h3 id="expect-1"><a class="header" href="#expect-1">expect</a></h3>
<p>If <code>val</code> is <code>Option::Some(x)</code>, returns <code>x</code>. Otherwise, panics with <code>err</code>.</p>
<p>Fully qualified path: <code>core::option::OptionTrait::expect</code></p>
<pre><code class="language-rust">fn expect(self: Option&lt;T&gt;, err: felt252) -&gt; T</code></pre>
<h3 id="unwrap-1"><a class="header" href="#unwrap-1">unwrap</a></h3>
<p>If <code>val</code> is <code>Option::Some(x)</code>, returns <code>x</code>. Otherwise, panics.</p>
<p>Fully qualified path: <code>core::option::OptionTrait::unwrap</code></p>
<pre><code class="language-rust">fn unwrap(self: Option&lt;T&gt;) -&gt; T</code></pre>
<h3 id="ok_or"><a class="header" href="#ok_or">ok_or</a></h3>
<p>Transforms the <code>Option&lt;T&gt;</code> into a <code>Result&lt;T, E&gt;</code>, mapping <code>Option::Some(v)</code> to <code>Result::Ok(v)</code> and <code>Option::None</code> to <code>Result::Err(err)</code>.</p>
<p>Fully qualified path: <code>core::option::OptionTrait::ok_or</code></p>
<pre><code class="language-rust">fn ok_or&lt;E, +Destruct&lt;E&gt;&gt;(self: Option&lt;T&gt;, err: E) -&gt; Result&lt;T, E&gt;</code></pre>
<h3 id="is_some"><a class="header" href="#is_some">is_some</a></h3>
<p>Returns <code>true</code> if the <code>Option</code> is <code>Option::Some</code>.</p>
<p>Fully qualified path: <code>core::option::OptionTrait::is_some</code></p>
<pre><code class="language-rust">fn is_some(self: @Option&lt;T&gt;) -&gt; bool</code></pre>
<h3 id="is_none"><a class="header" href="#is_none">is_none</a></h3>
<p>Returns <code>true</code> if the <code>Option</code> is <code>Option::None</code>.</p>
<p>Fully qualified path: <code>core::option::OptionTrait::is_none</code></p>
<pre><code class="language-rust">fn is_none(self: @Option&lt;T&gt;) -&gt; bool</code></pre>
<h3 id="unwrap_or-1"><a class="header" href="#unwrap_or-1">unwrap_or</a></h3>
<p>If <code>self</code> is <code>Option::Some(x)</code>, returns <code>x</code>. Otherwise, returns the provided default.</p>
<p>Fully qualified path: <code>core::option::OptionTrait::unwrap_or</code></p>
<pre><code class="language-rust">fn unwrap_or&lt;+Destruct&lt;T&gt;&gt;(self: Option&lt;T&gt;, default: T) -&gt; T</code></pre>
<h3 id="unwrap_or_default-1"><a class="header" href="#unwrap_or_default-1">unwrap_or_default</a></h3>
<p>If <code>self</code> is <code>Option::Some(x)</code>, returns <code>x</code>. Otherwise, returns <code>Default::&lt;T&gt;::default()</code>.</p>
<p>Fully qualified path: <code>core::option::OptionTrait::unwrap_or_default</code></p>
<pre><code class="language-rust">fn unwrap_or_default&lt;+Default&lt;T&gt;&gt;(self: Option&lt;T&gt;) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clone-1"><a class="header" href="#clone-1">Clone</a></h1>
<p>A common trait for the ability to explicitly duplicate an object.  Differs from <code>Copy</code> in that <code>Copy</code> is implicit and inexpensive, while <code>Clone</code> is always explicit and may or may not be expensive.  Since <code>Clone</code> is more general than <code>Copy</code>, you can automatically make anything <code>Copy</code> be <code>Clone</code> as well.  ## Derivable  This trait can be used with <code>#[derive]</code> if all fields are <code>Clone</code>. The <code>derive</code>d implementation of <code>Clone</code> calls <code>clone</code> on each field.</p>
<p>Fully qualified path: <code>core::clone::Clone</code></p>
<pre><code class="language-rust">pub trait Clone&lt;T&gt;</code></pre>
<h2 id="trait-functions-41"><a class="header" href="#trait-functions-41">Trait functions</a></h2>
<h3 id="clone-2"><a class="header" href="#clone-2">clone</a></h3>
<p>Returns a copy of the value.  # Examples</p>
<pre><code class="language-cairo">let arr = array![1, 2, 3];
assert!(arr == arr.clone());
</code></pre>
<p>Fully qualified path: <code>core::clone::Clone::clone</code></p>
<pre><code class="language-rust">fn clone(self: @T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecstatetrait"><a class="header" href="#ecstatetrait">EcStateTrait</a></h1>
<p>Fully qualified path: <code>core::ec::EcStateTrait</code></p>
<pre><code class="language-rust">pub trait EcStateTrait</code></pre>
<h2 id="trait-functions-42"><a class="header" href="#trait-functions-42">Trait functions</a></h2>
<h3 id="init"><a class="header" href="#init">init</a></h3>
<p>Initializes an EC computation with the zero point.</p>
<p>Fully qualified path: <code>core::ec::EcStateTrait::init</code></p>
<pre><code class="language-rust">fn init() -&gt; EcState nopanic</code></pre>
<h3 id="add-2"><a class="header" href="#add-2">add</a></h3>
<p>Adds a point to the computation.</p>
<p>Fully qualified path: <code>core::ec::EcStateTrait::add</code></p>
<pre><code class="language-rust">fn add(ref self: EcState, p: NonZeroEcPoint) nopanic</code></pre>
<h3 id="sub-2"><a class="header" href="#sub-2">sub</a></h3>
<p>Subs a point to the computation.</p>
<p>Fully qualified path: <code>core::ec::EcStateTrait::sub</code></p>
<pre><code class="language-rust">fn sub(ref self: EcState, p: NonZeroEcPoint)</code></pre>
<h3 id="add_mul"><a class="header" href="#add_mul">add_mul</a></h3>
<p>Adds the product p * scalar to the state.</p>
<p>Fully qualified path: <code>core::ec::EcStateTrait::add_mul</code></p>
<pre><code class="language-rust">fn add_mul(ref self: EcState, scalar: felt252, p: NonZeroEcPoint) nopanic</code></pre>
<h3 id="finalize_nz"><a class="header" href="#finalize_nz">finalize_nz</a></h3>
<p>Finalizes the EC computation and returns the result (returns <code>None</code> if the result is the zero point).</p>
<p>Fully qualified path: <code>core::ec::EcStateTrait::finalize_nz</code></p>
<pre><code class="language-rust">fn finalize_nz(self: EcState) -&gt; Option&lt;NonZeroEcPoint&gt; nopanic</code></pre>
<h3 id="finalize-1"><a class="header" href="#finalize-1">finalize</a></h3>
<p>Finalizes the EC computation and returns the result.</p>
<p>Fully qualified path: <code>core::ec::EcStateTrait::finalize</code></p>
<pre><code class="language-rust">fn finalize(self: EcState) -&gt; EcPoint</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecpointtrait"><a class="header" href="#ecpointtrait">EcPointTrait</a></h1>
<p>Fully qualified path: <code>core::ec::EcPointTrait</code></p>
<pre><code class="language-rust">pub trait EcPointTrait</code></pre>
<h2 id="trait-functions-43"><a class="header" href="#trait-functions-43">Trait functions</a></h2>
<h3 id="new-3"><a class="header" href="#new-3">new</a></h3>
<p>Creates a new EC point from its (x, y) coordinates.</p>
<p>Fully qualified path: <code>core::ec::EcPointTrait::new</code></p>
<pre><code class="language-rust">fn new(x: felt252, y: felt252) -&gt; Option&lt;EcPoint&gt;</code></pre>
<h3 id="new_nz"><a class="header" href="#new_nz">new_nz</a></h3>
<p>Creates a new NonZero EC point from its (x, y) coordinates.</p>
<p>Fully qualified path: <code>core::ec::EcPointTrait::new_nz</code></p>
<pre><code class="language-rust">fn new_nz(x: felt252, y: felt252) -&gt; Option&lt;NonZeroEcPoint&gt;</code></pre>
<h3 id="new_from_x"><a class="header" href="#new_from_x">new_from_x</a></h3>
<p>Creates a new EC point from its x coordinate.</p>
<p>Fully qualified path: <code>core::ec::EcPointTrait::new_from_x</code></p>
<pre><code class="language-rust">fn new_from_x(x: felt252) -&gt; Option&lt;EcPoint&gt;</code></pre>
<h3 id="new_nz_from_x"><a class="header" href="#new_nz_from_x">new_nz_from_x</a></h3>
<p>Creates a new NonZero EC point from its x coordinate.</p>
<p>Fully qualified path: <code>core::ec::EcPointTrait::new_nz_from_x</code></p>
<pre><code class="language-rust">fn new_nz_from_x(x: felt252) -&gt; Option&lt;NonZeroEcPoint&gt;</code></pre>
<h3 id="coordinates"><a class="header" href="#coordinates">coordinates</a></h3>
<p>Returns the coordinates of the EC point.</p>
<p>Fully qualified path: <code>core::ec::EcPointTrait::coordinates</code></p>
<pre><code class="language-rust">fn coordinates(self: NonZeroEcPoint) -&gt; (felt252, felt252)</code></pre>
<h3 id="x"><a class="header" href="#x">x</a></h3>
<p>Returns the x coordinate of the EC point.</p>
<p>Fully qualified path: <code>core::ec::EcPointTrait::x</code></p>
<pre><code class="language-rust">fn x(self: NonZeroEcPoint) -&gt; felt252</code></pre>
<h3 id="y"><a class="header" href="#y">y</a></h3>
<p>Returns the y coordinate of the EC point.</p>
<p>Fully qualified path: <code>core::ec::EcPointTrait::y</code></p>
<pre><code class="language-rust">fn y(self: NonZeroEcPoint) -&gt; felt252</code></pre>
<h3 id="mul-2"><a class="header" href="#mul-2">mul</a></h3>
<p>Computes the product of an EC point <code>p</code> by the given scalar <code>scalar</code>.</p>
<p>Fully qualified path: <code>core::ec::EcPointTrait::mul</code></p>
<pre><code class="language-rust">fn mul(self: EcPoint, scalar: felt252) -&gt; EcPoint</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numericliteral"><a class="header" href="#numericliteral">NumericLiteral</a></h1>
<p>Fully qualified path: <code>core::integer::NumericLiteral</code></p>
<pre><code class="language-rust">pub trait NumericLiteral&lt;T&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boundedint"><a class="header" href="#boundedint">BoundedInt</a></h1>
<p>Trait for getting the maximal and minimal values of an integer type.</p>
<p>Fully qualified path: <code>core::integer::BoundedInt</code></p>
<pre><code class="language-rust">pub trait BoundedInt&lt;T&gt;</code></pre>
<h2 id="trait-functions-44"><a class="header" href="#trait-functions-44">Trait functions</a></h2>
<h3 id="min-1"><a class="header" href="#min-1">min</a></h3>
<p>Returns the minimal value of the type.</p>
<p>Fully qualified path: <code>core::integer::BoundedInt::min</code></p>
<pre><code class="language-rust">fn min() -&gt; T nopanic</code></pre>
<h3 id="max-1"><a class="header" href="#max-1">max</a></h3>
<p>Returns the maximal value of the type.</p>
<p>Fully qualified path: <code>core::integer::BoundedInt::max</code></p>
<pre><code class="language-rust">fn max() -&gt; T nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="absandsign"><a class="header" href="#absandsign">AbsAndSign</a></h1>
<p>Internal trait for easier finding of absolute values.</p>
<p>Fully qualified path: <code>core::integer::AbsAndSign</code></p>
<pre><code class="language-rust">pub(crate) trait AbsAndSign&lt;Signed, Unsigned&gt;</code></pre>
<h2 id="trait-functions-45"><a class="header" href="#trait-functions-45">Trait functions</a></h2>
<h3 id="abs_and_sign"><a class="header" href="#abs_and_sign">abs_and_sign</a></h3>
<p>Returns the absolute value of the <code>Signed</code> value as <code>Unsigned</code> and the original sign. Returns <code>true</code> for sign if the number was negative and <code>false</code> otherwise.</p>
<p>Fully qualified path: <code>core::integer::AbsAndSign::abs_and_sign</code></p>
<pre><code class="language-rust">fn abs_and_sign(self: Signed) -&gt; (Unsigned, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-2"><a class="header" href="#zero-2">Zero</a></h1>
<p>Defines an additive identity element for <code>T</code>.  # Laws</p>
<pre><code class="language-text">a + 0 = a       âˆ€ a âˆˆ T
0 + a = a       âˆ€ a âˆˆ T
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero</code></p>
<pre><code class="language-rust">pub trait Zero&lt;T&gt;</code></pre>
<h2 id="trait-functions-46"><a class="header" href="#trait-functions-46">Trait functions</a></h2>
<h3 id="zero-3"><a class="header" href="#zero-3">zero</a></h3>
<p>Returns the additive identity element of <code>T</code>, <code>0</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Zero;

assert!(Zero::&lt;u32&gt;::zero() == 0);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero::zero</code></p>
<pre><code class="language-rust">fn zero() -&gt; T</code></pre>
<h3 id="is_zero"><a class="header" href="#is_zero">is_zero</a></h3>
<p>Returns true if <code>self</code> is equal to the additive identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Zero;

assert!(0.is_zero());
assert!(!5.is_zero());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero::is_zero</code></p>
<pre><code class="language-rust">fn is_zero(self: @T) -&gt; bool</code></pre>
<h3 id="is_non_zero"><a class="header" href="#is_non_zero">is_non_zero</a></h3>
<p>Returns false if <code>self</code> is equal to the additive identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Zero;

assert!(5.is_non_zero());
assert!(!0.is_non_zero());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero::is_non_zero</code></p>
<pre><code class="language-rust">fn is_non_zero(self: @T) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="one-1"><a class="header" href="#one-1">One</a></h1>
<p>Defines a multiplicative identity element for <code>T</code>.  # Laws</p>
<pre><code class="language-text">a * 1 = a       âˆ€ a âˆˆ T
1 * a = a       âˆ€ a âˆˆ T
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One</code></p>
<pre><code class="language-rust">pub trait One&lt;T&gt;</code></pre>
<h2 id="trait-functions-47"><a class="header" href="#trait-functions-47">Trait functions</a></h2>
<h3 id="one-2"><a class="header" href="#one-2">one</a></h3>
<p>Returns the multiplicative identity element of <code>T</code>, <code>1</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::One;

assert!(One::&lt;u32&gt;::one() == 1);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One::one</code></p>
<pre><code class="language-rust">fn one() -&gt; T</code></pre>
<h3 id="is_one"><a class="header" href="#is_one">is_one</a></h3>
<p>Returns true if <code>self</code> is equal to the multiplicative identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::One;

assert!(1.is_one());
assert!(!0.is_one());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One::is_one</code></p>
<pre><code class="language-rust">fn is_one(self: @T) -&gt; bool</code></pre>
<h3 id="is_non_one"><a class="header" href="#is_non_one">is_non_one</a></h3>
<p>Returns false if <code>self</code> is equal to the multiplicative identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::One;

assert!(0.is_non_one());
assert!(!1.is_non_one());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One::is_non_one</code></p>
<pre><code class="language-rust">fn is_non_one(self: @T) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitsize"><a class="header" href="#bitsize">BitSize</a></h1>
<p>A trait used to retrieve the size of a type in bits.</p>
<p>Fully qualified path: <code>core::num::traits::bit_size::BitSize</code></p>
<pre><code class="language-rust">pub trait BitSize&lt;T&gt;</code></pre>
<h2 id="trait-functions-48"><a class="header" href="#trait-functions-48">Trait functions</a></h2>
<h3 id="bits"><a class="header" href="#bits">bits</a></h3>
<p>Returns the bit size of <code>T</code> as a <code>usize</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::BitSize;

let bits = BitSize::&lt;u8&gt;::bits();
assert(bits == 8);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::bit_size::BitSize::bits</code></p>
<pre><code class="language-rust">fn bits() -&gt; usize</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bounded"><a class="header" href="#bounded">Bounded</a></h1>
<p>A trait defining minimum and maximum bounds for numeric types.  This trait only supports types that can have constant values.</p>
<p>Fully qualified path: <code>core::num::traits::bounded::Bounded</code></p>
<pre><code class="language-rust">pub trait Bounded&lt;T&gt;</code></pre>
<h2 id="trait-constants"><a class="header" href="#trait-constants">Trait constants</a></h2>
<h3 id="min-2"><a class="header" href="#min-2">MIN</a></h3>
<p>Returns the minimum value for type <code>T</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Bounded;

let min = Bounded::&lt;u8&gt;::MIN;
assert!(min == 0);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::bounded::Bounded::MIN</code></p>
<pre><code class="language-rust">const MIN: T;</code></pre>
<h3 id="max-2"><a class="header" href="#max-2">MAX</a></h3>
<p>Returns the maximum value for type <code>T</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Bounded;

let max = Bounded::&lt;u8&gt;::MAX;
assert!(max == 255);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::bounded::Bounded::MAX</code></p>
<pre><code class="language-rust">const MAX: T;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowingadd"><a class="header" href="#overflowingadd">OverflowingAdd</a></h1>
<p>Performs addition with a flag for overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::OverflowingAdd;

let (result, is_overflow) = 1_u8.overflowing_add(255_u8);
assert!(result == 0);
assert!(is_overflow);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingAdd</code></p>
<pre><code class="language-rust">pub trait OverflowingAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-49"><a class="header" href="#trait-functions-49">Trait functions</a></h2>
<h3 id="overflowing_add"><a class="header" href="#overflowing_add">overflowing_add</a></h3>
<p>Returns a tuple of the sum along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingAdd::overflowing_add</code></p>
<pre><code class="language-rust">fn overflowing_add(self: T, v: T) -&gt; (T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowingsub"><a class="header" href="#overflowingsub">OverflowingSub</a></h1>
<p>Performs subtraction with a flag for overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::OverflowingSub;

let (result, is_underflow) = 1_u8.overflowing_sub(2_u8);
assert!(result == 255);
assert!(is_underflow);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingSub</code></p>
<pre><code class="language-rust">pub trait OverflowingSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-50"><a class="header" href="#trait-functions-50">Trait functions</a></h2>
<h3 id="overflowing_sub"><a class="header" href="#overflowing_sub">overflowing_sub</a></h3>
<p>Returns a tuple of the difference along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingSub::overflowing_sub</code></p>
<pre><code class="language-rust">fn overflowing_sub(self: T, v: T) -&gt; (T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowingmul"><a class="header" href="#overflowingmul">OverflowingMul</a></h1>
<p>Performs multiplication with a flag for overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::OverflowingMul;

let (result, is_overflow) = 1_u8.overflowing_mul(2_u8);
assert!(result == 2);
assert!(!is_overflow);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingMul</code></p>
<pre><code class="language-rust">pub trait OverflowingMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-51"><a class="header" href="#trait-functions-51">Trait functions</a></h2>
<h3 id="overflowing_mul"><a class="header" href="#overflowing_mul">overflowing_mul</a></h3>
<p>Returns a tuple of the product along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingMul::overflowing_mul</code></p>
<pre><code class="language-rust">fn overflowing_mul(self: T, v: T) -&gt; (T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrappingadd"><a class="header" href="#wrappingadd">WrappingAdd</a></h1>
<p>Performs addition that wraps around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WrappingAdd;

let result = 255_u8.wrapping_add(1);
assert!(result == 0);

let result = 100_u8.wrapping_add(200);
assert!(result == 44); // (100 + 200) % 256 = 44
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingAdd</code></p>
<pre><code class="language-rust">pub trait WrappingAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-52"><a class="header" href="#trait-functions-52">Trait functions</a></h2>
<h3 id="wrapping_add"><a class="header" href="#wrapping_add">wrapping_add</a></h3>
<p>Wrapping (modular) addition. Computes <code>self + other</code>, wrapping around at the boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingAdd::wrapping_add</code></p>
<pre><code class="language-rust">fn wrapping_add(self: T, v: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrappingsub"><a class="header" href="#wrappingsub">WrappingSub</a></h1>
<p>Performs subtraction that wraps around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WrappingSub;

let result = 0_u8.wrapping_sub(1);
assert!(result == 255);

let result = 100_u8.wrapping_sub(150);
assert!(result == 206);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingSub</code></p>
<pre><code class="language-rust">pub trait WrappingSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-53"><a class="header" href="#trait-functions-53">Trait functions</a></h2>
<h3 id="wrapping_sub"><a class="header" href="#wrapping_sub">wrapping_sub</a></h3>
<p>Wrapping (modular) subtraction. Computes <code>self - other</code>, wrapping around at the boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingSub::wrapping_sub</code></p>
<pre><code class="language-rust">fn wrapping_sub(self: T, v: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrappingmul"><a class="header" href="#wrappingmul">WrappingMul</a></h1>
<p>Performs multiplication that wraps around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WrappingMul;

let result = 10_u8.wrapping_mul(30);
assert!(result == 44); // (10 * 30) % 256 = 44

let result = 200_u8.wrapping_mul(2);
assert!(result == 144); // (200 * 2) % 256 = 144
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingMul</code></p>
<pre><code class="language-rust">pub trait WrappingMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-54"><a class="header" href="#trait-functions-54">Trait functions</a></h2>
<h3 id="wrapping_mul"><a class="header" href="#wrapping_mul">wrapping_mul</a></h3>
<p>Wrapping (modular) multiplication. Computes <code>self * other</code>, wrapping around at the boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingMul::wrapping_mul</code></p>
<pre><code class="language-rust">fn wrapping_mul(self: T, v: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkedadd"><a class="header" href="#checkedadd">CheckedAdd</a></h1>
<p>Performs addition that returns <code>None</code> instead of wrapping around on overflow.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedAdd</code></p>
<pre><code class="language-rust">pub trait CheckedAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-55"><a class="header" href="#trait-functions-55">Trait functions</a></h2>
<h3 id="checked_add"><a class="header" href="#checked_add">checked_add</a></h3>
<p>Adds two numbers, checking for overflow. If overflow happens, <code>None</code> is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedAdd::checked_add</code></p>
<pre><code class="language-rust">fn checked_add(self: T, v: T) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkedsub"><a class="header" href="#checkedsub">CheckedSub</a></h1>
<p>Performs subtraction that returns <code>None</code> instead of wrapping around on underflow.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedSub</code></p>
<pre><code class="language-rust">pub trait CheckedSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-56"><a class="header" href="#trait-functions-56">Trait functions</a></h2>
<h3 id="checked_sub"><a class="header" href="#checked_sub">checked_sub</a></h3>
<p>Subtracts two numbers, checking for underflow. If underflow happens, <code>None</code> is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedSub::checked_sub</code></p>
<pre><code class="language-rust">fn checked_sub(self: T, v: T) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkedmul"><a class="header" href="#checkedmul">CheckedMul</a></h1>
<p>Performs multiplication that returns <code>None</code> instead of wrapping around on underflow or overflow.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedMul</code></p>
<pre><code class="language-rust">pub trait CheckedMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-57"><a class="header" href="#trait-functions-57">Trait functions</a></h2>
<h3 id="checked_mul"><a class="header" href="#checked_mul">checked_mul</a></h3>
<p>Multiplies two numbers, checking for underflow or overflow. If underflow or overflow happens, <code>None</code> is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedMul::checked_mul</code></p>
<pre><code class="language-rust">fn checked_mul(self: T, v: T) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pow-1"><a class="header" href="#pow-1">Pow</a></h1>
<p>Raises a value to the power of <code>exp</code>.  Note that <code>0â°</code> (<code>pow(0, 0)</code>) returns <code>1</code>. Mathematically this is undefined.  # Panics  Panics if the result of the exponentiation operation overflows the output type.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Pow;

assert!(2_i8.pow(4_usize) == 16_i8);
assert!(6_u8.pow(3_usize) == 216_u8);
assert!(0_u8.pow(0_usize) == 1_u8);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::pow::Pow</code></p>
<pre><code class="language-rust">pub trait Pow&lt;Base, Exp&gt;</code></pre>
<h2 id="trait-functions-58"><a class="header" href="#trait-functions-58">Trait functions</a></h2>
<h3 id="pow-2"><a class="header" href="#pow-2">pow</a></h3>
<p>Returns <code>self</code> to the power <code>exp</code>.</p>
<p>Fully qualified path: <code>core::num::traits::ops::pow::Pow::pow</code></p>
<pre><code class="language-rust">fn pow(self: Base, exp: Exp) -&gt; Self::Output</code></pre>
<h2 id="trait-types"><a class="header" href="#trait-types">Trait types</a></h2>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<p>The type of the result of the power calculation.</p>
<p>Fully qualified path: <code>core::num::traits::ops::pow::Pow::Output</code></p>
<pre><code class="language-rust">type Output;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturatingadd"><a class="header" href="#saturatingadd">SaturatingAdd</a></h1>
<p>Performs addition that saturates at the numeric bounds instead of overflowing.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::SaturatingAdd;

assert!(255_u8.saturating_add(1_u8) == 255);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingAdd</code></p>
<pre><code class="language-rust">pub trait SaturatingAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-59"><a class="header" href="#trait-functions-59">Trait functions</a></h2>
<h3 id="saturating_add"><a class="header" href="#saturating_add">saturating_add</a></h3>
<p>Saturating addition. Computes <code>self + other</code>, saturating at the relevant high or low boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingAdd::saturating_add</code></p>
<pre><code class="language-rust">fn saturating_add(self: T, other: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturatingsub"><a class="header" href="#saturatingsub">SaturatingSub</a></h1>
<p>Performs subtraction that saturates at the numeric bounds instead of overflowing.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::SaturatingSub;

assert!(1_u8.saturating_sub(2_u8) == 0);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingSub</code></p>
<pre><code class="language-rust">pub trait SaturatingSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-60"><a class="header" href="#trait-functions-60">Trait functions</a></h2>
<h3 id="saturating_sub"><a class="header" href="#saturating_sub">saturating_sub</a></h3>
<p>Saturating subtraction. Computes <code>self - other</code>, saturating at the relevant high or low boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingSub::saturating_sub</code></p>
<pre><code class="language-rust">fn saturating_sub(self: T, other: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturatingmul"><a class="header" href="#saturatingmul">SaturatingMul</a></h1>
<p>Performs multiplication that saturates at the numeric bounds instead of overflowing.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::SaturatingMul;

assert!(100_u8.saturating_mul(3_u8) == 255);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingMul</code></p>
<pre><code class="language-rust">pub trait SaturatingMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-61"><a class="header" href="#trait-functions-61">Trait functions</a></h2>
<h3 id="saturating_mul"><a class="header" href="#saturating_mul">saturating_mul</a></h3>
<p>Saturating multiplication. Computes <code>self * other</code>, saturating at the relevant high or low boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingMul::saturating_mul</code></p>
<pre><code class="language-rust">fn saturating_mul(self: T, other: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widemul-1"><a class="header" href="#widemul-1">WideMul</a></h1>
<p>A trait for types that can be multiplied together to produce a wider type.  This trait enables multiplication operations where the result type has double the bit width of the input types, preventing overflow in cases where the result would exceed the input type's maximum value.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WideMul;

let a: u8 = 255; // maximum value for u8
let b: u8 = 255;
let result: u16 = a.wide_mul(b);
assert!(result == 65025);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::widemul::WideMul</code></p>
<pre><code class="language-rust">pub trait WideMul&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-functions-62"><a class="header" href="#trait-functions-62">Trait functions</a></h2>
<h3 id="wide_mul"><a class="header" href="#wide_mul">wide_mul</a></h3>
<p>Multiply two values together, producing a wider type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::widemul::WideMul::wide_mul</code></p>
<pre><code class="language-rust">fn wide_mul(self: Lhs, other: Rhs) -&gt; Self::Target</code></pre>
<h2 id="trait-types-1"><a class="header" href="#trait-types-1">Trait types</a></h2>
<h3 id="target"><a class="header" href="#target">Target</a></h3>
<p>The type of the result of the multiplication.</p>
<p>Fully qualified path: <code>core::num::traits::ops::widemul::WideMul::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widesquare-1"><a class="header" href="#widesquare-1">WideSquare</a></h1>
<p>A trait for a type that can be squared to produce a wider type.  This trait enables squaring operations where the result type has double the bit width of the input type, preventing overflow in cases where the result would exceed the input type's maximum value.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WideSquare;

let a: u8 = 16;
let result: u16 = a.wide_square();
assert!(result == 256);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::widesquare::WideSquare</code></p>
<pre><code class="language-rust">pub trait WideSquare&lt;T&gt;</code></pre>
<h2 id="trait-functions-63"><a class="header" href="#trait-functions-63">Trait functions</a></h2>
<h3 id="wide_square"><a class="header" href="#wide_square">wide_square</a></h3>
<p>Calculates the square, producing a wider type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::widesquare::WideSquare::wide_square</code></p>
<pre><code class="language-rust">fn wide_square(self: T) -&gt; Self::Target</code></pre>
<h2 id="trait-types-2"><a class="header" href="#trait-types-2">Trait types</a></h2>
<h3 id="target-1"><a class="header" href="#target-1">Target</a></h3>
<p>The type of the result of the square.</p>
<p>Fully qualified path: <code>core::num::traits::ops::widesquare::WideSquare::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sqrt-1"><a class="header" href="#sqrt-1">Sqrt</a></h1>
<p>A trait for computing the square root of a number.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Sqrt;

assert!(9_u8.sqrt() == 3);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::sqrt::Sqrt</code></p>
<pre><code class="language-rust">pub trait Sqrt&lt;T&gt;</code></pre>
<h2 id="trait-functions-64"><a class="header" href="#trait-functions-64">Trait functions</a></h2>
<h3 id="sqrt-2"><a class="header" href="#sqrt-2">sqrt</a></h3>
<p>Computes the square root of a number.</p>
<p>Fully qualified path: <code>core::num::traits::ops::sqrt::Sqrt::sqrt</code></p>
<pre><code class="language-rust">fn sqrt(self: T) -&gt; Self::Target</code></pre>
<h2 id="trait-types-3"><a class="header" href="#trait-types-3">Trait types</a></h2>
<h3 id="target-2"><a class="header" href="#target-2">Target</a></h3>
<p>The type of the result of the square root operation.</p>
<p>Fully qualified path: <code>core::num::traits::ops::sqrt::Sqrt::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-4"><a class="header" href="#zero-4">Zero</a></h1>
<p>Defines an additive identity element for <code>T</code>.  # Laws</p>
<pre><code class="language-text">a + 0 = a       âˆ€ a âˆˆ T
0 + a = a       âˆ€ a âˆˆ T
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero</code></p>
<pre><code class="language-rust">pub trait Zero&lt;T&gt;</code></pre>
<h2 id="trait-functions-65"><a class="header" href="#trait-functions-65">Trait functions</a></h2>
<h3 id="zero-5"><a class="header" href="#zero-5">zero</a></h3>
<p>Returns the additive identity element of <code>T</code>, <code>0</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Zero;

assert!(Zero::&lt;u32&gt;::zero() == 0);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero::zero</code></p>
<pre><code class="language-rust">fn zero() -&gt; T</code></pre>
<h3 id="is_zero-1"><a class="header" href="#is_zero-1">is_zero</a></h3>
<p>Returns true if <code>self</code> is equal to the additive identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Zero;

assert!(0.is_zero());
assert!(!5.is_zero());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero::is_zero</code></p>
<pre><code class="language-rust">fn is_zero(self: @T) -&gt; bool</code></pre>
<h3 id="is_non_zero-1"><a class="header" href="#is_non_zero-1">is_non_zero</a></h3>
<p>Returns false if <code>self</code> is equal to the additive identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Zero;

assert!(5.is_non_zero());
assert!(!0.is_non_zero());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::zero::Zero::is_non_zero</code></p>
<pre><code class="language-rust">fn is_non_zero(self: @T) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="one-3"><a class="header" href="#one-3">One</a></h1>
<p>Defines a multiplicative identity element for <code>T</code>.  # Laws</p>
<pre><code class="language-text">a * 1 = a       âˆ€ a âˆˆ T
1 * a = a       âˆ€ a âˆˆ T
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One</code></p>
<pre><code class="language-rust">pub trait One&lt;T&gt;</code></pre>
<h2 id="trait-functions-66"><a class="header" href="#trait-functions-66">Trait functions</a></h2>
<h3 id="one-4"><a class="header" href="#one-4">one</a></h3>
<p>Returns the multiplicative identity element of <code>T</code>, <code>1</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::One;

assert!(One::&lt;u32&gt;::one() == 1);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One::one</code></p>
<pre><code class="language-rust">fn one() -&gt; T</code></pre>
<h3 id="is_one-1"><a class="header" href="#is_one-1">is_one</a></h3>
<p>Returns true if <code>self</code> is equal to the multiplicative identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::One;

assert!(1.is_one());
assert!(!0.is_one());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One::is_one</code></p>
<pre><code class="language-rust">fn is_one(self: @T) -&gt; bool</code></pre>
<h3 id="is_non_one-1"><a class="header" href="#is_non_one-1">is_non_one</a></h3>
<p>Returns false if <code>self</code> is equal to the multiplicative identity.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::One;

assert!(0.is_non_one());
assert!(!1.is_non_one());
</code></pre>
<p>Fully qualified path: <code>core::num::traits::one::One::is_non_one</code></p>
<pre><code class="language-rust">fn is_non_one(self: @T) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitsize-1"><a class="header" href="#bitsize-1">BitSize</a></h1>
<p>A trait used to retrieve the size of a type in bits.</p>
<p>Fully qualified path: <code>core::num::traits::bit_size::BitSize</code></p>
<pre><code class="language-rust">pub trait BitSize&lt;T&gt;</code></pre>
<h2 id="trait-functions-67"><a class="header" href="#trait-functions-67">Trait functions</a></h2>
<h3 id="bits-1"><a class="header" href="#bits-1">bits</a></h3>
<p>Returns the bit size of <code>T</code> as a <code>usize</code>.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::BitSize;

let bits = BitSize::&lt;u8&gt;::bits();
assert(bits == 8);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::bit_size::BitSize::bits</code></p>
<pre><code class="language-rust">fn bits() -&gt; usize</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowingadd-1"><a class="header" href="#overflowingadd-1">OverflowingAdd</a></h1>
<p>Performs addition with a flag for overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::OverflowingAdd;

let (result, is_overflow) = 1_u8.overflowing_add(255_u8);
assert!(result == 0);
assert!(is_overflow);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingAdd</code></p>
<pre><code class="language-rust">pub trait OverflowingAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-68"><a class="header" href="#trait-functions-68">Trait functions</a></h2>
<h3 id="overflowing_add-1"><a class="header" href="#overflowing_add-1">overflowing_add</a></h3>
<p>Returns a tuple of the sum along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingAdd::overflowing_add</code></p>
<pre><code class="language-rust">fn overflowing_add(self: T, v: T) -&gt; (T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowingsub-1"><a class="header" href="#overflowingsub-1">OverflowingSub</a></h1>
<p>Performs subtraction with a flag for overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::OverflowingSub;

let (result, is_underflow) = 1_u8.overflowing_sub(2_u8);
assert!(result == 255);
assert!(is_underflow);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingSub</code></p>
<pre><code class="language-rust">pub trait OverflowingSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-69"><a class="header" href="#trait-functions-69">Trait functions</a></h2>
<h3 id="overflowing_sub-1"><a class="header" href="#overflowing_sub-1">overflowing_sub</a></h3>
<p>Returns a tuple of the difference along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingSub::overflowing_sub</code></p>
<pre><code class="language-rust">fn overflowing_sub(self: T, v: T) -&gt; (T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overflowingmul-1"><a class="header" href="#overflowingmul-1">OverflowingMul</a></h1>
<p>Performs multiplication with a flag for overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::OverflowingMul;

let (result, is_overflow) = 1_u8.overflowing_mul(2_u8);
assert!(result == 2);
assert!(!is_overflow);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingMul</code></p>
<pre><code class="language-rust">pub trait OverflowingMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-70"><a class="header" href="#trait-functions-70">Trait functions</a></h2>
<h3 id="overflowing_mul-1"><a class="header" href="#overflowing_mul-1">overflowing_mul</a></h3>
<p>Returns a tuple of the product along with a boolean indicating whether an arithmetic overflow would occur. If an overflow would have occurred then the wrapped value is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::overflowing::OverflowingMul::overflowing_mul</code></p>
<pre><code class="language-rust">fn overflowing_mul(self: T, v: T) -&gt; (T, bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrappingadd-1"><a class="header" href="#wrappingadd-1">WrappingAdd</a></h1>
<p>Performs addition that wraps around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WrappingAdd;

let result = 255_u8.wrapping_add(1);
assert!(result == 0);

let result = 100_u8.wrapping_add(200);
assert!(result == 44); // (100 + 200) % 256 = 44
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingAdd</code></p>
<pre><code class="language-rust">pub trait WrappingAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-71"><a class="header" href="#trait-functions-71">Trait functions</a></h2>
<h3 id="wrapping_add-1"><a class="header" href="#wrapping_add-1">wrapping_add</a></h3>
<p>Wrapping (modular) addition. Computes <code>self + other</code>, wrapping around at the boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingAdd::wrapping_add</code></p>
<pre><code class="language-rust">fn wrapping_add(self: T, v: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrappingsub-1"><a class="header" href="#wrappingsub-1">WrappingSub</a></h1>
<p>Performs subtraction that wraps around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WrappingSub;

let result = 0_u8.wrapping_sub(1);
assert!(result == 255);

let result = 100_u8.wrapping_sub(150);
assert!(result == 206);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingSub</code></p>
<pre><code class="language-rust">pub trait WrappingSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-72"><a class="header" href="#trait-functions-72">Trait functions</a></h2>
<h3 id="wrapping_sub-1"><a class="header" href="#wrapping_sub-1">wrapping_sub</a></h3>
<p>Wrapping (modular) subtraction. Computes <code>self - other</code>, wrapping around at the boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingSub::wrapping_sub</code></p>
<pre><code class="language-rust">fn wrapping_sub(self: T, v: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrappingmul-1"><a class="header" href="#wrappingmul-1">WrappingMul</a></h1>
<p>Performs multiplication that wraps around on overflow.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WrappingMul;

let result = 10_u8.wrapping_mul(30);
assert!(result == 44); // (10 * 30) % 256 = 44

let result = 200_u8.wrapping_mul(2);
assert!(result == 144); // (200 * 2) % 256 = 144
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingMul</code></p>
<pre><code class="language-rust">pub trait WrappingMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-73"><a class="header" href="#trait-functions-73">Trait functions</a></h2>
<h3 id="wrapping_mul-1"><a class="header" href="#wrapping_mul-1">wrapping_mul</a></h3>
<p>Wrapping (modular) multiplication. Computes <code>self * other</code>, wrapping around at the boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::wrapping::WrappingMul::wrapping_mul</code></p>
<pre><code class="language-rust">fn wrapping_mul(self: T, v: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkedadd-1"><a class="header" href="#checkedadd-1">CheckedAdd</a></h1>
<p>Performs addition that returns <code>None</code> instead of wrapping around on overflow.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedAdd</code></p>
<pre><code class="language-rust">pub trait CheckedAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-74"><a class="header" href="#trait-functions-74">Trait functions</a></h2>
<h3 id="checked_add-1"><a class="header" href="#checked_add-1">checked_add</a></h3>
<p>Adds two numbers, checking for overflow. If overflow happens, <code>None</code> is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedAdd::checked_add</code></p>
<pre><code class="language-rust">fn checked_add(self: T, v: T) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkedsub-1"><a class="header" href="#checkedsub-1">CheckedSub</a></h1>
<p>Performs subtraction that returns <code>None</code> instead of wrapping around on underflow.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedSub</code></p>
<pre><code class="language-rust">pub trait CheckedSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-75"><a class="header" href="#trait-functions-75">Trait functions</a></h2>
<h3 id="checked_sub-1"><a class="header" href="#checked_sub-1">checked_sub</a></h3>
<p>Subtracts two numbers, checking for underflow. If underflow happens, <code>None</code> is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedSub::checked_sub</code></p>
<pre><code class="language-rust">fn checked_sub(self: T, v: T) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checkedmul-1"><a class="header" href="#checkedmul-1">CheckedMul</a></h1>
<p>Performs multiplication that returns <code>None</code> instead of wrapping around on underflow or overflow.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedMul</code></p>
<pre><code class="language-rust">pub trait CheckedMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-76"><a class="header" href="#trait-functions-76">Trait functions</a></h2>
<h3 id="checked_mul-1"><a class="header" href="#checked_mul-1">checked_mul</a></h3>
<p>Multiplies two numbers, checking for underflow or overflow. If underflow or overflow happens, <code>None</code> is returned.</p>
<p>Fully qualified path: <code>core::num::traits::ops::checked::CheckedMul::checked_mul</code></p>
<pre><code class="language-rust">fn checked_mul(self: T, v: T) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturatingadd-1"><a class="header" href="#saturatingadd-1">SaturatingAdd</a></h1>
<p>Performs addition that saturates at the numeric bounds instead of overflowing.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::SaturatingAdd;

assert!(255_u8.saturating_add(1_u8) == 255);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingAdd</code></p>
<pre><code class="language-rust">pub trait SaturatingAdd&lt;T&gt;</code></pre>
<h2 id="trait-functions-77"><a class="header" href="#trait-functions-77">Trait functions</a></h2>
<h3 id="saturating_add-1"><a class="header" href="#saturating_add-1">saturating_add</a></h3>
<p>Saturating addition. Computes <code>self + other</code>, saturating at the relevant high or low boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingAdd::saturating_add</code></p>
<pre><code class="language-rust">fn saturating_add(self: T, other: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturatingsub-1"><a class="header" href="#saturatingsub-1">SaturatingSub</a></h1>
<p>Performs subtraction that saturates at the numeric bounds instead of overflowing.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::SaturatingSub;

assert!(1_u8.saturating_sub(2_u8) == 0);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingSub</code></p>
<pre><code class="language-rust">pub trait SaturatingSub&lt;T&gt;</code></pre>
<h2 id="trait-functions-78"><a class="header" href="#trait-functions-78">Trait functions</a></h2>
<h3 id="saturating_sub-1"><a class="header" href="#saturating_sub-1">saturating_sub</a></h3>
<p>Saturating subtraction. Computes <code>self - other</code>, saturating at the relevant high or low boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingSub::saturating_sub</code></p>
<pre><code class="language-rust">fn saturating_sub(self: T, other: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saturatingmul-1"><a class="header" href="#saturatingmul-1">SaturatingMul</a></h1>
<p>Performs multiplication that saturates at the numeric bounds instead of overflowing.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::SaturatingMul;

assert!(100_u8.saturating_mul(3_u8) == 255);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingMul</code></p>
<pre><code class="language-rust">pub trait SaturatingMul&lt;T&gt;</code></pre>
<h2 id="trait-functions-79"><a class="header" href="#trait-functions-79">Trait functions</a></h2>
<h3 id="saturating_mul-1"><a class="header" href="#saturating_mul-1">saturating_mul</a></h3>
<p>Saturating multiplication. Computes <code>self * other</code>, saturating at the relevant high or low boundary of the type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::saturating::SaturatingMul::saturating_mul</code></p>
<pre><code class="language-rust">fn saturating_mul(self: T, other: T) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pow-3"><a class="header" href="#pow-3">Pow</a></h1>
<p>Raises a value to the power of <code>exp</code>.  Note that <code>0â°</code> (<code>pow(0, 0)</code>) returns <code>1</code>. Mathematically this is undefined.  # Panics  Panics if the result of the exponentiation operation overflows the output type.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Pow;

assert!(2_i8.pow(4_usize) == 16_i8);
assert!(6_u8.pow(3_usize) == 216_u8);
assert!(0_u8.pow(0_usize) == 1_u8);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::pow::Pow</code></p>
<pre><code class="language-rust">pub trait Pow&lt;Base, Exp&gt;</code></pre>
<h2 id="trait-functions-80"><a class="header" href="#trait-functions-80">Trait functions</a></h2>
<h3 id="pow-4"><a class="header" href="#pow-4">pow</a></h3>
<p>Returns <code>self</code> to the power <code>exp</code>.</p>
<p>Fully qualified path: <code>core::num::traits::ops::pow::Pow::pow</code></p>
<pre><code class="language-rust">fn pow(self: Base, exp: Exp) -&gt; Self::Output</code></pre>
<h2 id="trait-types-4"><a class="header" href="#trait-types-4">Trait types</a></h2>
<h3 id="output-1"><a class="header" href="#output-1">Output</a></h3>
<p>The type of the result of the power calculation.</p>
<p>Fully qualified path: <code>core::num::traits::ops::pow::Pow::Output</code></p>
<pre><code class="language-rust">type Output;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sqrt-3"><a class="header" href="#sqrt-3">Sqrt</a></h1>
<p>A trait for computing the square root of a number.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::Sqrt;

assert!(9_u8.sqrt() == 3);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::sqrt::Sqrt</code></p>
<pre><code class="language-rust">pub trait Sqrt&lt;T&gt;</code></pre>
<h2 id="trait-functions-81"><a class="header" href="#trait-functions-81">Trait functions</a></h2>
<h3 id="sqrt-4"><a class="header" href="#sqrt-4">sqrt</a></h3>
<p>Computes the square root of a number.</p>
<p>Fully qualified path: <code>core::num::traits::ops::sqrt::Sqrt::sqrt</code></p>
<pre><code class="language-rust">fn sqrt(self: T) -&gt; Self::Target</code></pre>
<h2 id="trait-types-5"><a class="header" href="#trait-types-5">Trait types</a></h2>
<h3 id="target-3"><a class="header" href="#target-3">Target</a></h3>
<p>The type of the result of the square root operation.</p>
<p>Fully qualified path: <code>core::num::traits::ops::sqrt::Sqrt::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widemul-2"><a class="header" href="#widemul-2">WideMul</a></h1>
<p>A trait for types that can be multiplied together to produce a wider type.  This trait enables multiplication operations where the result type has double the bit width of the input types, preventing overflow in cases where the result would exceed the input type's maximum value.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WideMul;

let a: u8 = 255; // maximum value for u8
let b: u8 = 255;
let result: u16 = a.wide_mul(b);
assert!(result == 65025);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::widemul::WideMul</code></p>
<pre><code class="language-rust">pub trait WideMul&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-functions-82"><a class="header" href="#trait-functions-82">Trait functions</a></h2>
<h3 id="wide_mul-1"><a class="header" href="#wide_mul-1">wide_mul</a></h3>
<p>Multiply two values together, producing a wider type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::widemul::WideMul::wide_mul</code></p>
<pre><code class="language-rust">fn wide_mul(self: Lhs, other: Rhs) -&gt; Self::Target</code></pre>
<h2 id="trait-types-6"><a class="header" href="#trait-types-6">Trait types</a></h2>
<h3 id="target-4"><a class="header" href="#target-4">Target</a></h3>
<p>The type of the result of the multiplication.</p>
<p>Fully qualified path: <code>core::num::traits::ops::widemul::WideMul::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widesquare-2"><a class="header" href="#widesquare-2">WideSquare</a></h1>
<p>A trait for a type that can be squared to produce a wider type.  This trait enables squaring operations where the result type has double the bit width of the input type, preventing overflow in cases where the result would exceed the input type's maximum value.  # Examples</p>
<pre><code class="language-cairo">use core::num::traits::WideSquare;

let a: u8 = 16;
let result: u16 = a.wide_square();
assert!(result == 256);
</code></pre>
<p>Fully qualified path: <code>core::num::traits::ops::widesquare::WideSquare</code></p>
<pre><code class="language-rust">pub trait WideSquare&lt;T&gt;</code></pre>
<h2 id="trait-functions-83"><a class="header" href="#trait-functions-83">Trait functions</a></h2>
<h3 id="wide_square-1"><a class="header" href="#wide_square-1">wide_square</a></h3>
<p>Calculates the square, producing a wider type.</p>
<p>Fully qualified path: <code>core::num::traits::ops::widesquare::WideSquare::wide_square</code></p>
<pre><code class="language-rust">fn wide_square(self: T) -&gt; Self::Target</code></pre>
<h2 id="trait-types-7"><a class="header" href="#trait-types-7">Trait types</a></h2>
<h3 id="target-5"><a class="header" href="#target-5">Target</a></h3>
<p>The type of the result of the square.</p>
<p>Fully qualified path: <code>core::num::traits::ops::widesquare::WideSquare::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-4"><a class="header" href="#index-4">Index</a></h1>
<p>Trait for accessing an item contained in type <code>C</code> with an index of type <code>I</code>.</p>
<p>Fully qualified path: <code>core::ops::index::Index</code></p>
<pre><code class="language-rust">pub trait Index&lt;C, I&gt;</code></pre>
<h2 id="trait-functions-84"><a class="header" href="#trait-functions-84">Trait functions</a></h2>
<h3 id="index-5"><a class="header" href="#index-5">index</a></h3>
<p>Returns the item at the given index.</p>
<p>Fully qualified path: <code>core::ops::index::Index::index</code></p>
<pre><code class="language-rust">fn index(ref self: C, index: I) -&gt; Self::Target</code></pre>
<h2 id="trait-types-8"><a class="header" href="#trait-types-8">Trait types</a></h2>
<h3 id="target-6"><a class="header" href="#target-6">Target</a></h3>
<p>The type of the item.</p>
<p>Fully qualified path: <code>core::ops::index::Index::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexview-1"><a class="header" href="#indexview-1">IndexView</a></h1>
<p>The following two traits are for implementing the [] operator. Only one should be implemented for each type. Both are not consuming of self, the first gets a snapshot of the object and the second gets ref. Trait for a view of an item contained in type <code>C</code> with an index of type <code>I</code>.</p>
<p>Fully qualified path: <code>core::ops::index::IndexView</code></p>
<pre><code class="language-rust">pub trait IndexView&lt;C, I&gt;</code></pre>
<h2 id="trait-functions-85"><a class="header" href="#trait-functions-85">Trait functions</a></h2>
<h3 id="index-6"><a class="header" href="#index-6">index</a></h3>
<p>Returns the item at the given index.</p>
<p>Fully qualified path: <code>core::ops::index::IndexView::index</code></p>
<pre><code class="language-rust">fn index(self: @C, index: I) -&gt; Self::Target</code></pre>
<h2 id="trait-types-9"><a class="header" href="#trait-types-9">Trait types</a></h2>
<h3 id="target-7"><a class="header" href="#target-7">Target</a></h3>
<p>The type of the item.</p>
<p>Fully qualified path: <code>core::ops::index::IndexView::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addassign"><a class="header" href="#addassign">AddAssign</a></h1>
<p>The addition assignment operator <code>+=</code>.</p>
<p>Fully qualified path: <code>core::ops::arith::AddAssign</code></p>
<pre><code class="language-rust">pub trait AddAssign&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-functions-86"><a class="header" href="#trait-functions-86">Trait functions</a></h2>
<h3 id="add_assign"><a class="header" href="#add_assign">add_assign</a></h3>
<p>Performs the <code>+=</code> operation.</p>
<p>Fully qualified path: <code>core::ops::arith::AddAssign::add_assign</code></p>
<pre><code class="language-rust">fn add_assign(ref self: Lhs, rhs: Rhs)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subassign"><a class="header" href="#subassign">SubAssign</a></h1>
<p>The subtraction assignment operator <code>-=</code>.</p>
<p>Fully qualified path: <code>core::ops::arith::SubAssign</code></p>
<pre><code class="language-rust">pub trait SubAssign&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-functions-87"><a class="header" href="#trait-functions-87">Trait functions</a></h2>
<h3 id="sub_assign"><a class="header" href="#sub_assign">sub_assign</a></h3>
<p>Performs the <code>-=</code> operation.</p>
<p>Fully qualified path: <code>core::ops::arith::SubAssign::sub_assign</code></p>
<pre><code class="language-rust">fn sub_assign(ref self: Lhs, rhs: Rhs)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mulassign"><a class="header" href="#mulassign">MulAssign</a></h1>
<p>The multiplication assignment operator <code>*=</code>.</p>
<p>Fully qualified path: <code>core::ops::arith::MulAssign</code></p>
<pre><code class="language-rust">pub trait MulAssign&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-functions-88"><a class="header" href="#trait-functions-88">Trait functions</a></h2>
<h3 id="mul_assign"><a class="header" href="#mul_assign">mul_assign</a></h3>
<p>Performs the <code>*=</code> operation.</p>
<p>Fully qualified path: <code>core::ops::arith::MulAssign::mul_assign</code></p>
<pre><code class="language-rust">fn mul_assign(ref self: Lhs, rhs: Rhs)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="divassign"><a class="header" href="#divassign">DivAssign</a></h1>
<p>The division assignment operator <code>/=</code>.</p>
<p>Fully qualified path: <code>core::ops::arith::DivAssign</code></p>
<pre><code class="language-rust">pub trait DivAssign&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-functions-89"><a class="header" href="#trait-functions-89">Trait functions</a></h2>
<h3 id="div_assign"><a class="header" href="#div_assign">div_assign</a></h3>
<p>Performs the <code>/=</code> operation.</p>
<p>Fully qualified path: <code>core::ops::arith::DivAssign::div_assign</code></p>
<pre><code class="language-rust">fn div_assign(ref self: Lhs, rhs: Rhs)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remassign"><a class="header" href="#remassign">RemAssign</a></h1>
<p>The remainder assignment operator <code>%=</code>.</p>
<p>Fully qualified path: <code>core::ops::arith::RemAssign</code></p>
<pre><code class="language-rust">pub trait RemAssign&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-functions-90"><a class="header" href="#trait-functions-90">Trait functions</a></h2>
<h3 id="rem_assign"><a class="header" href="#rem_assign">rem_assign</a></h3>
<p>Performs the <code>%=</code> operation.</p>
<p>Fully qualified path: <code>core::ops::arith::RemAssign::rem_assign</code></p>
<pre><code class="language-rust">fn rem_assign(ref self: Lhs, rhs: Rhs)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref-1"><a class="header" href="#deref-1">Deref</a></h1>
<p>A trait for dereferencing a value. This is used in order to directly access members of the dereferenced value.</p>
<p>Fully qualified path: <code>core::ops::deref::Deref</code></p>
<pre><code class="language-rust">pub trait Deref&lt;T&gt;</code></pre>
<h2 id="trait-functions-91"><a class="header" href="#trait-functions-91">Trait functions</a></h2>
<h3 id="deref-2"><a class="header" href="#deref-2">deref</a></h3>
<p>Returns the dereferenced value.</p>
<p>Fully qualified path: <code>core::ops::deref::Deref::deref</code></p>
<pre><code class="language-rust">fn deref(self: T) -&gt; Self::Target</code></pre>
<h2 id="trait-types-10"><a class="header" href="#trait-types-10">Trait types</a></h2>
<h3 id="target-8"><a class="header" href="#target-8">Target</a></h3>
<p>The type of the dereferenced value.</p>
<p>Fully qualified path: <code>core::ops::deref::Deref::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snapshotderef"><a class="header" href="#snapshotderef">SnapshotDeref</a></h1>
<p>A helper trait for dereferencing a snapshot of a type. Should not be implemented for copyable types.</p>
<p>Fully qualified path: <code>core::ops::deref::SnapshotDeref</code></p>
<pre><code class="language-rust">pub trait SnapshotDeref&lt;T&gt;</code></pre>
<h2 id="trait-functions-92"><a class="header" href="#trait-functions-92">Trait functions</a></h2>
<h3 id="snapshot_deref"><a class="header" href="#snapshot_deref">snapshot_deref</a></h3>
<p>Returns the dereferenced value.</p>
<p>Fully qualified path: <code>core::ops::deref::SnapshotDeref::snapshot_deref</code></p>
<pre><code class="language-rust">fn snapshot_deref(self: @T) -&gt; Self::Target</code></pre>
<h2 id="trait-types-11"><a class="header" href="#trait-types-11">Trait types</a></h2>
<h3 id="target-9"><a class="header" href="#target-9">Target</a></h3>
<p>The type of the dereferenced value.</p>
<p>Fully qualified path: <code>core::ops::deref::SnapshotDeref::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derefmut"><a class="header" href="#derefmut">DerefMut</a></h1>
<p>A trait for dereferencing a value. This is used in order to handle the case where the value is a reference.</p>
<p>Fully qualified path: <code>core::ops::deref::DerefMut</code></p>
<pre><code class="language-rust">pub trait DerefMut&lt;T&gt;</code></pre>
<h2 id="trait-functions-93"><a class="header" href="#trait-functions-93">Trait functions</a></h2>
<h3 id="deref_mut"><a class="header" href="#deref_mut">deref_mut</a></h3>
<p>Returns the dereferenced value.</p>
<p>Fully qualified path: <code>core::ops::deref::DerefMut::deref_mut</code></p>
<pre><code class="language-rust">fn deref_mut(ref self: T) -&gt; Self::Target</code></pre>
<h2 id="trait-types-12"><a class="header" href="#trait-types-12">Trait types</a></h2>
<h3 id="target-10"><a class="header" href="#target-10">Target</a></h3>
<p>The type of the dereferenced value.</p>
<p>Fully qualified path: <code>core::ops::deref::DerefMut::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fnonce"><a class="header" href="#fnonce">FnOnce</a></h1>
<p>The version of the call operator that takes a by-value receiver.  Instances of <code>FnOnce</code> can be called, but might not be callable multiple times. Because of this, if the only thing known about a type is that it implements <code>FnOnce</code>, it can only be called once.  <code>FnOnce</code> is implemented automatically by closures that might consume captured variables.</p>
<pre><code class="language-cairo"></code></pre>
<p>Fully qualified path: <code>core::ops::function::FnOnce</code></p>
<pre><code class="language-rust">pub trait FnOnce&lt;T, Args&gt;</code></pre>
<h2 id="trait-functions-94"><a class="header" href="#trait-functions-94">Trait functions</a></h2>
<h3 id="call-1"><a class="header" href="#call-1">call</a></h3>
<p>Performs the call operation.</p>
<p>Fully qualified path: <code>core::ops::function::FnOnce::call</code></p>
<pre><code class="language-rust">fn call(self: T, args: Args) -&gt; Self::Output</code></pre>
<h2 id="trait-types-13"><a class="header" href="#trait-types-13">Trait types</a></h2>
<h3 id="output-2"><a class="header" href="#output-2">Output</a></h3>
<p>The returned type after the call operator is used.</p>
<p>Fully qualified path: <code>core::ops::function::FnOnce::Output</code></p>
<pre><code class="language-rust">type Output;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fn"><a class="header" href="#fn">Fn</a></h1>
<p>The version of the call operator that takes a by-snapshot receiver.  Instances of <code>Fn</code> can be called multiple times.  <code>Fn</code> is implemented automatically by closures that capture only copyable variables.</p>
<p>Fully qualified path: <code>core::ops::function::Fn</code></p>
<pre><code class="language-rust">pub trait Fn&lt;T, Args&gt;</code></pre>
<h2 id="trait-functions-95"><a class="header" href="#trait-functions-95">Trait functions</a></h2>
<h3 id="call-2"><a class="header" href="#call-2">call</a></h3>
<p>Performs the call operation.</p>
<p>Fully qualified path: <code>core::ops::function::Fn::call</code></p>
<pre><code class="language-rust">fn call(self: @T, args: Args) -&gt; Self::Output</code></pre>
<h2 id="trait-types-14"><a class="header" href="#trait-types-14">Trait types</a></h2>
<h3 id="output-3"><a class="header" href="#output-3">Output</a></h3>
<p>The returned type after the call operator is used.</p>
<p>Fully qualified path: <code>core::ops::function::Fn::Output</code></p>
<pre><code class="language-rust">type Output;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexview-2"><a class="header" href="#indexview-2">IndexView</a></h1>
<p>The following two traits are for implementing the [] operator. Only one should be implemented for each type. Both are not consuming of self, the first gets a snapshot of the object and the second gets ref. Trait for a view of an item contained in type <code>C</code> with an index of type <code>I</code>.</p>
<p>Fully qualified path: <code>core::ops::index::IndexView</code></p>
<pre><code class="language-rust">pub trait IndexView&lt;C, I&gt;</code></pre>
<h2 id="trait-functions-96"><a class="header" href="#trait-functions-96">Trait functions</a></h2>
<h3 id="index-7"><a class="header" href="#index-7">index</a></h3>
<p>Returns the item at the given index.</p>
<p>Fully qualified path: <code>core::ops::index::IndexView::index</code></p>
<pre><code class="language-rust">fn index(self: @C, index: I) -&gt; Self::Target</code></pre>
<h2 id="trait-types-15"><a class="header" href="#trait-types-15">Trait types</a></h2>
<h3 id="target-11"><a class="header" href="#target-11">Target</a></h3>
<p>The type of the item.</p>
<p>Fully qualified path: <code>core::ops::index::IndexView::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index-8"><a class="header" href="#index-8">Index</a></h1>
<p>Trait for accessing an item contained in type <code>C</code> with an index of type <code>I</code>.</p>
<p>Fully qualified path: <code>core::ops::index::Index</code></p>
<pre><code class="language-rust">pub trait Index&lt;C, I&gt;</code></pre>
<h2 id="trait-functions-97"><a class="header" href="#trait-functions-97">Trait functions</a></h2>
<h3 id="index-9"><a class="header" href="#index-9">index</a></h3>
<p>Returns the item at the given index.</p>
<p>Fully qualified path: <code>core::ops::index::Index::index</code></p>
<pre><code class="language-rust">fn index(ref self: C, index: I) -&gt; Self::Target</code></pre>
<h2 id="trait-types-16"><a class="header" href="#trait-types-16">Trait types</a></h2>
<h3 id="target-12"><a class="header" href="#target-12">Target</a></h3>
<p>The type of the item.</p>
<p>Fully qualified path: <code>core::ops::index::Index::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serde-1"><a class="header" href="#serde-1">Serde</a></h1>
<p>A trait that allows for serializing and deserializing values of any type.  The <code>Serde&lt;T&gt;</code> trait defines two core operations: - <code>serialize</code>: Converts a value into a sequence of <code>felt252</code>s - <code>deserialize</code>: Reconstructs a value from a sequence of <code>felt252</code>s  # Examples  ## Simple Types (u8, u16, u32, u64, u128)  Simple types are serialized into a single <code>felt252</code>:</p>
<pre><code class="language-cairo">let value: u8 = 42;
let mut output: Array&lt;felt252&gt; = array![];
value.serialize(ref output);
assert!(output == array![42]); // Single value
</code></pre>
<p>Compound Types (u256)  Compound types may be serialized into multiple <code>felt252</code> values:</p>
<pre><code class="language-cairo">let value: u256 = u256 { low: 1, high: 2 };
let mut output: Array&lt;felt252&gt; = array![];
value.serialize(ref output);
assert!(output == array![1, 2]); // Two `felt252`s: low and high
</code></pre>
<p>Implementing <code>Serde</code>  ## Using the <code>Derive</code> Macro  In most cases, you can use the <code>#[derive(Serde)]</code> attribute to automatically generate the implementation for your type:</p>
<pre><code class="language-cairo"><span class="boring">[derive(Serde)]
</span>struct Point {
    x: u32,
    y: u32
}
</code></pre>
<p>Manual Implementation  Should you need to customize the serialization behavior for a type in a way that derive does not support, you can implement the <code>Serde</code> yourself:</p>
<pre><code class="language-cairo">impl PointSerde of Serde&lt;Point&gt; {
    fn serialize(self: @Point, ref output: Array&lt;felt252&gt;) {
        output.append((*self.x).into());
        output.append((*self.y).into());
    }

    fn deserialize(ref serialized: Span&lt;felt252&gt;) -&gt; Option&lt;Point&gt; {
        let x = (*serialized.pop_front()?).try_into()?;
        let y = (*serialized.pop_front()?).try_into()?;

        Option::Some(Point { x, y })
    }
}
</code></pre>
<p>Fully qualified path: <code>core::serde::Serde</code></p>
<pre><code class="language-rust">pub trait Serde&lt;T&gt;</code></pre>
<h2 id="trait-functions-98"><a class="header" href="#trait-functions-98">Trait functions</a></h2>
<h3 id="serialize"><a class="header" href="#serialize">serialize</a></h3>
<p>Serializes a value into a sequence of <code>felt252</code>s.  # Examples</p>
<pre><code class="language-cairo">let value: u256 = 1;
let mut serialized: Array&lt;felt252&gt; = array![];
value.serialize(ref serialized);
assert!(serialized == array![1, 0]) // `serialized` contains the [low, high] parts of the
`u256` value ```
</code></pre>
<p>Fully qualified path: <code>core::serde::Serde::serialize</code></p>
<pre><code class="language-rust">fn serialize(self: @T, ref output: Array&lt;felt252&gt;)</code></pre>
<h3 id="deserialize"><a class="header" href="#deserialize">deserialize</a></h3>
<p>Deserializes a value from a sequence of <code>felt252</code>s. If the value cannot be deserialized, returns <code>Option::None</code>.  # Examples</p>
<pre><code class="language-cairo">let mut serialized: Span&lt;felt252&gt; = array![1, 0].span();
let value: u256 = Serde::deserialize(ref serialized).unwrap();
assert!(value == 1);
</code></pre>
<p>Fully qualified path: <code>core::serde::Serde::deserialize</code></p>
<pre><code class="language-rust">fn deserialize(ref serialized: Span&lt;felt252&gt;) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashstatetrait"><a class="header" href="#hashstatetrait">HashStateTrait</a></h1>
<p>A trait for hash state accumulators.</p>
<p>Fully qualified path: <code>core::hash::HashStateTrait</code></p>
<pre><code class="language-rust">pub trait HashStateTrait&lt;S&gt;</code></pre>
<h2 id="trait-functions-99"><a class="header" href="#trait-functions-99">Trait functions</a></h2>
<h3 id="update"><a class="header" href="#update">update</a></h3>
<p>Fully qualified path: <code>core::hash::HashStateTrait::update</code></p>
<pre><code class="language-rust">fn update(self: S, value: felt252) -&gt; S</code></pre>
<h3 id="finalize-2"><a class="header" href="#finalize-2">finalize</a></h3>
<p>Fully qualified path: <code>core::hash::HashStateTrait::finalize</code></p>
<pre><code class="language-rust">fn finalize(self: S) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash-1"><a class="header" href="#hash-1">Hash</a></h1>
<p>A trait for values that can be hashed.</p>
<p>Fully qualified path: <code>core::hash::Hash</code></p>
<pre><code class="language-rust">pub trait Hash&lt;T, S, +HashStateTrait&lt;S&gt;&gt;</code></pre>
<h2 id="trait-functions-100"><a class="header" href="#trait-functions-100">Trait functions</a></h2>
<h3 id="update_state"><a class="header" href="#update_state">update_state</a></h3>
<p>Updates the hash state with the given value.</p>
<p>Fully qualified path: <code>core::hash::Hash::update_state</code></p>
<pre><code class="language-rust">fn update_state(state: S, value: T) -&gt; S</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legacyhash"><a class="header" href="#legacyhash">LegacyHash</a></h1>
<p>Trait for hashing values. Used for backwards compatibility. NOTE: Implement <code>Hash</code> instead of this trait if possible.</p>
<p>Fully qualified path: <code>core::hash::LegacyHash</code></p>
<pre><code class="language-rust">pub trait LegacyHash&lt;T&gt;</code></pre>
<h2 id="trait-functions-101"><a class="header" href="#trait-functions-101">Trait functions</a></h2>
<h3 id="hash-2"><a class="header" href="#hash-2">hash</a></h3>
<p>Fully qualified path: <code>core::hash::LegacyHash::hash</code></p>
<pre><code class="language-rust">fn hash(state: felt252, value: T) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashstateextrait"><a class="header" href="#hashstateextrait">HashStateExTrait</a></h1>
<p>Extension trait for hash state accumulators.</p>
<p>Fully qualified path: <code>core::hash::HashStateExTrait</code></p>
<pre><code class="language-rust">pub trait HashStateExTrait&lt;S, T&gt;</code></pre>
<h2 id="trait-functions-102"><a class="header" href="#trait-functions-102">Trait functions</a></h2>
<h3 id="update_with"><a class="header" href="#update_with">update_with</a></h3>
<p>Updates the hash state with the given value.</p>
<p>Fully qualified path: <code>core::hash::HashStateExTrait::update_with</code></p>
<pre><code class="language-rust">fn update_with(self: S, value: T) -&gt; S</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersentrait"><a class="header" href="#pedersentrait">PedersenTrait</a></h1>
<p>Fully qualified path: <code>core::pedersen::PedersenTrait</code></p>
<pre><code class="language-rust">pub trait PedersenTrait</code></pre>
<h2 id="trait-functions-103"><a class="header" href="#trait-functions-103">Trait functions</a></h2>
<h3 id="new-4"><a class="header" href="#new-4">new</a></h3>
<p>Creates a new Pedersen hash state with the given base value.  # Examples</p>
<pre><code class="language-cairo">use core::pedersen::PedersenTrait;

let mut state = PedersenTrait::new(0);
assert!(state.state == 0);
</code></pre>
<p>Fully qualified path: <code>core::pedersen::PedersenTrait::new</code></p>
<pre><code class="language-rust">fn new(base: felt252) -&gt; HashState</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidontrait"><a class="header" href="#poseidontrait">PoseidonTrait</a></h1>
<p>Fully qualified path: <code>core::poseidon::PoseidonTrait</code></p>
<pre><code class="language-rust">pub trait PoseidonTrait</code></pre>
<h2 id="trait-functions-104"><a class="header" href="#trait-functions-104">Trait functions</a></h2>
<h3 id="new-5"><a class="header" href="#new-5">new</a></h3>
<p>Creates an initial state with all fields set to 0.  # Examples</p>
<pre><code class="language-cairo">use core::poseidon::PoseidonTrait;

let mut state = PoseidonTrait::new();
</code></pre>
<p>Fully qualified path: <code>core::poseidon::PoseidonTrait::new</code></p>
<pre><code class="language-rust">fn new() -&gt; HashState</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="printtrait"><a class="header" href="#printtrait">PrintTrait</a></h1>
<p>A trait for printing values for debugging purposes. Accessible with prelude editions prior to <code>2024_07</code>.  # Examples</p>
<pre><code class="language-cairo">use core::debug::PrintTrait;

1.print();
(1 == 2).print();

let mut arr = array![];
arr.append('1234567890123456789012345678901');
arr.append('Sca');
arr.append('SomeVeryLongMessage');
arr.print();
</code></pre>
<p>Fully qualified path: <code>core::debug::PrintTrait</code></p>
<pre><code class="language-rust">pub(crate) trait PrintTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-105"><a class="header" href="#trait-functions-105">Trait functions</a></h2>
<h3 id="print"><a class="header" href="#print">print</a></h3>
<p>Fully qualified path: <code>core::debug::PrintTrait::print</code></p>
<pre><code class="language-rust">fn print(self: T)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="display"><a class="header" href="#display">Display</a></h1>
<p>A trait for standard formatting, using the empty format ("{}").  # Examples</p>
<pre><code class="language-cairo">let word: ByteArray = "123";
println!("{}", word);
</code></pre>
<p>Fully qualified path: <code>core::fmt::Display</code></p>
<pre><code class="language-rust">pub trait Display&lt;T&gt;</code></pre>
<h2 id="trait-functions-106"><a class="header" href="#trait-functions-106">Trait functions</a></h2>
<h3 id="fmt-1"><a class="header" href="#fmt-1">fmt</a></h3>
<p>Fully qualified path: <code>core::fmt::Display::fmt</code></p>
<pre><code class="language-rust">fn fmt(self: @T, ref f: Formatter) -&gt; Result&lt;(), Error&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug-1"><a class="header" href="#debug-1">Debug</a></h1>
<p>A trait for debug formatting, using the empty format ("{:?}").  # Examples</p>
<pre><code class="language-cairo">let word: ByteArray = "123";
println!("{:?}", word);
</code></pre>
<p>Fully qualified path: <code>core::fmt::Debug</code></p>
<pre><code class="language-rust">pub trait Debug&lt;T&gt;</code></pre>
<h2 id="trait-functions-107"><a class="header" href="#trait-functions-107">Trait functions</a></h2>
<h3 id="fmt-2"><a class="header" href="#fmt-2">fmt</a></h3>
<p>Fully qualified path: <code>core::fmt::Debug::fmt</code></p>
<pre><code class="language-rust">fn fmt(self: @T, ref f: Formatter) -&gt; Result&lt;(), Error&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lowerhex"><a class="header" href="#lowerhex">LowerHex</a></h1>
<p>A trait for hex formatting in lower case, using the empty format ("{:x}").</p>
<p>Fully qualified path: <code>core::fmt::LowerHex</code></p>
<pre><code class="language-rust">pub trait LowerHex&lt;T&gt;</code></pre>
<h2 id="trait-functions-108"><a class="header" href="#trait-functions-108">Trait functions</a></h2>
<h3 id="fmt-3"><a class="header" href="#fmt-3">fmt</a></h3>
<p>Fully qualified path: <code>core::fmt::LowerHex::fmt</code></p>
<pre><code class="language-rust">fn fmt(self: @T, ref f: Formatter) -&gt; Result&lt;(), Error&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syscallresulttrait"><a class="header" href="#syscallresulttrait">SyscallResultTrait</a></h1>
<p>Fully qualified path: <code>core::starknet::SyscallResultTrait</code></p>
<pre><code class="language-rust">pub trait SyscallResultTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-109"><a class="header" href="#trait-functions-109">Trait functions</a></h2>
<h3 id="unwrap_syscall"><a class="header" href="#unwrap_syscall">unwrap_syscall</a></h3>
<p>If <code>val</code> is <code>Result::Ok(x)</code>, returns <code>x</code>. Otherwise, panics with the revert reason.</p>
<p>Fully qualified path: <code>core::starknet::SyscallResultTrait::unwrap_syscall</code></p>
<pre><code class="language-rust">fn unwrap_syscall(self: SyscallResult&lt;T&gt;) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store"><a class="header" href="#store">Store</a></h1>
<p>Trait for types that can be used as a value in Starknet storage variables.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store</code></p>
<pre><code class="language-rust">pub trait Store&lt;T&gt;</code></pre>
<h2 id="trait-functions-110"><a class="header" href="#trait-functions-110">Trait functions</a></h2>
<h3 id="read"><a class="header" href="#read">read</a></h3>
<p>Reads a value from storage from domain <code>address_domain</code> and base address <code>base</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::read</code></p>
<pre><code class="language-rust">fn read(address_domain: u32, base: StorageBaseAddress) -&gt; SyscallResult&lt;T&gt;</code></pre>
<h3 id="write"><a class="header" href="#write">write</a></h3>
<p>Writes a value to storage to domain <code>address_domain</code> and base address <code>base</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::write</code></p>
<pre><code class="language-rust">fn write(address_domain: u32, base: StorageBaseAddress, value: T) -&gt; SyscallResult&lt;()&gt;</code></pre>
<h3 id="read_at_offset"><a class="header" href="#read_at_offset">read_at_offset</a></h3>
<p>Reads a value from storage from domain <code>address_domain</code> and base address <code>base</code> at offset <code>offset</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::read_at_offset</code></p>
<pre><code class="language-rust">fn read_at_offset(address_domain: u32, base: StorageBaseAddress, offset: u8) -&gt; SyscallResult&lt;T&gt;</code></pre>
<h3 id="write_at_offset"><a class="header" href="#write_at_offset">write_at_offset</a></h3>
<p>Writes a value to storage to domain <code>address_domain</code> and base address <code>base</code> at offset <code>offset</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::write_at_offset</code></p>
<pre><code class="language-rust">fn write_at_offset(
    address_domain: u32, base: StorageBaseAddress, offset: u8, value: T,
) -&gt; SyscallResult&lt;()&gt;</code></pre>
<h3 id="size"><a class="header" href="#size">size</a></h3>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::size</code></p>
<pre><code class="language-rust">fn size() -&gt; u8</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-1"><a class="header" href="#event-1">Event</a></h1>
<p>Fully qualified path: <code>core::starknet::event::Event</code></p>
<pre><code class="language-rust">pub trait Event&lt;T&gt;</code></pre>
<h2 id="trait-functions-111"><a class="header" href="#trait-functions-111">Trait functions</a></h2>
<h3 id="append_keys_and_data"><a class="header" href="#append_keys_and_data">append_keys_and_data</a></h3>
<p>Fully qualified path: <code>core::starknet::event::Event::append_keys_and_data</code></p>
<pre><code class="language-rust">fn append_keys_and_data(self: @T, ref keys: Array&lt;felt252&gt;, ref data: Array&lt;felt252&gt;)</code></pre>
<h3 id="deserialize-1"><a class="header" href="#deserialize-1">deserialize</a></h3>
<p>Fully qualified path: <code>core::starknet::event::Event::deserialize</code></p>
<pre><code class="language-rust">fn deserialize(ref keys: Span&lt;felt252&gt;, ref data: Span&lt;felt252&gt;) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontract"><a class="header" href="#accountcontract">AccountContract</a></h1>
<p>A trait for account contracts that support class declarations (only <code>__validate__</code> and <code>__execute__</code> are mandatory for an account).  This trait assumes that the calldata for invoke transactions is <code>Array&lt;Call&gt;</code>. This is the network standard following SNIP6. It is not enforced by StarkNet, but deviating from the standard interface may lead to incompatibility with standard tooling.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract</code></p>
<pre><code class="language-rust">pub trait AccountContract&lt;TContractState&gt;</code></pre>
<h2 id="trait-functions-112"><a class="header" href="#trait-functions-112">Trait functions</a></h2>
<h3 id="validate_declare"><a class="header" href="#validate_declare"><strong>validate_declare</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for the declaration of the class with the given hash. The entry point should return <code>core::starknet::VALIDATED</code> if the account is willing to pay for the declaration.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract::__validate_declare__</code></p>
<pre><code class="language-rust">fn __validate_declare__(self: @TContractState, class_hash: felt252) -&gt; felt252</code></pre>
<h3 id="validate"><a class="header" href="#validate"><strong>validate</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for executing a given set of calls. The entry point should return <code>core::starknet::VALIDATED</code> if the account is willing to pay for the execution, in which case <code>__execute__</code> will be called on the same set of calls.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract::__validate__</code></p>
<pre><code class="language-rust">fn __validate__(ref self: TContractState, calls: Array&lt;Call&gt;) -&gt; felt252</code></pre>
<h3 id="execute"><a class="header" href="#execute"><strong>execute</strong></a></h3>
<p>An entry point that is called to execute a given set of calls. This entry point should block the deprecated v0 invoke transactions as they do not go through the <code>__validate__</code> entry point.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract::__execute__</code></p>
<pre><code class="language-rust">fn __execute__(ref self: TContractState, calls: Array&lt;Call&gt;) -&gt; Array&lt;Span&lt;felt252&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store-1"><a class="header" href="#store-1">Store</a></h1>
<p>Trait for types that can be used as a value in Starknet storage variables.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store</code></p>
<pre><code class="language-rust">pub trait Store&lt;T&gt;</code></pre>
<h2 id="trait-functions-113"><a class="header" href="#trait-functions-113">Trait functions</a></h2>
<h3 id="read-1"><a class="header" href="#read-1">read</a></h3>
<p>Reads a value from storage from domain <code>address_domain</code> and base address <code>base</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::read</code></p>
<pre><code class="language-rust">fn read(address_domain: u32, base: StorageBaseAddress) -&gt; SyscallResult&lt;T&gt;</code></pre>
<h3 id="write-1"><a class="header" href="#write-1">write</a></h3>
<p>Writes a value to storage to domain <code>address_domain</code> and base address <code>base</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::write</code></p>
<pre><code class="language-rust">fn write(address_domain: u32, base: StorageBaseAddress, value: T) -&gt; SyscallResult&lt;()&gt;</code></pre>
<h3 id="read_at_offset-1"><a class="header" href="#read_at_offset-1">read_at_offset</a></h3>
<p>Reads a value from storage from domain <code>address_domain</code> and base address <code>base</code> at offset <code>offset</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::read_at_offset</code></p>
<pre><code class="language-rust">fn read_at_offset(address_domain: u32, base: StorageBaseAddress, offset: u8) -&gt; SyscallResult&lt;T&gt;</code></pre>
<h3 id="write_at_offset-1"><a class="header" href="#write_at_offset-1">write_at_offset</a></h3>
<p>Writes a value to storage to domain <code>address_domain</code> and base address <code>base</code> at offset <code>offset</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::write_at_offset</code></p>
<pre><code class="language-rust">fn write_at_offset(
    address_domain: u32, base: StorageBaseAddress, offset: u8, value: T,
) -&gt; SyscallResult&lt;()&gt;</code></pre>
<h3 id="size-1"><a class="header" href="#size-1">size</a></h3>
<p>Fully qualified path: <code>core::starknet::storage_access::Store::size</code></p>
<pre><code class="language-rust">fn size() -&gt; u8</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storepacking"><a class="header" href="#storepacking">StorePacking</a></h1>
<p>Trait for easier implementation of <code>Store</code> used for packing and unpacking values into values that already implement <code>Store</code>, and having <code>Store</code> implemented using this conversion.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::StorePacking</code></p>
<pre><code class="language-rust">pub trait StorePacking&lt;T, PackedT&gt;</code></pre>
<h2 id="trait-functions-114"><a class="header" href="#trait-functions-114">Trait functions</a></h2>
<h3 id="pack"><a class="header" href="#pack">pack</a></h3>
<p>Packs a value of type <code>T</code> into a value of type <code>PackedT</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::StorePacking::pack</code></p>
<pre><code class="language-rust">fn pack(value: T) -&gt; PackedT</code></pre>
<h3 id="unpack"><a class="header" href="#unpack">unpack</a></h3>
<p>Unpacks a value of type <code>PackedT</code> into a value of type <code>T</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::StorePacking::unpack</code></p>
<pre><code class="language-rust">fn unpack(value: PackedT) -&gt; T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256trait"><a class="header" href="#secp256trait">Secp256Trait</a></h1>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256Trait</code></p>
<pre><code class="language-rust">pub trait Secp256Trait&lt;Secp256Point&gt;</code></pre>
<h2 id="trait-functions-115"><a class="header" href="#trait-functions-115">Trait functions</a></h2>
<h3 id="get_curve_size"><a class="header" href="#get_curve_size">get_curve_size</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256Trait::get_curve_size</code></p>
<pre><code class="language-rust">fn get_curve_size() -&gt; u256</code></pre>
<h3 id="get_generator_point"><a class="header" href="#get_generator_point">get_generator_point</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256Trait::get_generator_point</code></p>
<pre><code class="language-rust">fn get_generator_point() -&gt; Secp256Point</code></pre>
<h3 id="secp256_ec_new_syscall"><a class="header" href="#secp256_ec_new_syscall">secp256_ec_new_syscall</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256Trait::secp256_ec_new_syscall</code></p>
<pre><code class="language-rust">fn secp256_ec_new_syscall(x: u256, y: u256) -&gt; SyscallResult&lt;Option&lt;Secp256Point&gt;&gt;</code></pre>
<h3 id="secp256_ec_get_point_from_x_syscall"><a class="header" href="#secp256_ec_get_point_from_x_syscall">secp256_ec_get_point_from_x_syscall</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256Trait::secp256_ec_get_point_from_x_syscall</code></p>
<pre><code class="language-rust">fn secp256_ec_get_point_from_x_syscall(
    x: u256, y_parity: bool,
) -&gt; SyscallResult&lt;Option&lt;Secp256Point&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256pointtrait"><a class="header" href="#secp256pointtrait">Secp256PointTrait</a></h1>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256PointTrait</code></p>
<pre><code class="language-rust">pub trait Secp256PointTrait&lt;Secp256Point&gt;</code></pre>
<h2 id="trait-functions-116"><a class="header" href="#trait-functions-116">Trait functions</a></h2>
<h3 id="get_coordinates"><a class="header" href="#get_coordinates">get_coordinates</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256PointTrait::get_coordinates</code></p>
<pre><code class="language-rust">fn get_coordinates(self: Secp256Point) -&gt; SyscallResult&lt;(u256, u256)&gt;</code></pre>
<h3 id="add-3"><a class="header" href="#add-3">add</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256PointTrait::add</code></p>
<pre><code class="language-rust">fn add(self: Secp256Point, other: Secp256Point) -&gt; SyscallResult&lt;Secp256Point&gt;</code></pre>
<h3 id="mul-3"><a class="header" href="#mul-3">mul</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256_trait::Secp256PointTrait::mul</code></p>
<pre><code class="language-rust">fn mul(self: Secp256Point, scalar: u256) -&gt; SyscallResult&lt;Secp256Point&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-2"><a class="header" href="#event-2">Event</a></h1>
<p>Fully qualified path: <code>core::starknet::event::Event</code></p>
<pre><code class="language-rust">pub trait Event&lt;T&gt;</code></pre>
<h2 id="trait-functions-117"><a class="header" href="#trait-functions-117">Trait functions</a></h2>
<h3 id="append_keys_and_data-1"><a class="header" href="#append_keys_and_data-1">append_keys_and_data</a></h3>
<p>Fully qualified path: <code>core::starknet::event::Event::append_keys_and_data</code></p>
<pre><code class="language-rust">fn append_keys_and_data(self: @T, ref keys: Array&lt;felt252&gt;, ref data: Array&lt;felt252&gt;)</code></pre>
<h3 id="deserialize-2"><a class="header" href="#deserialize-2">deserialize</a></h3>
<p>Fully qualified path: <code>core::starknet::event::Event::deserialize</code></p>
<pre><code class="language-rust">fn deserialize(ref keys: Span&lt;felt252&gt;, ref data: Span&lt;felt252&gt;) -&gt; Option&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eventemitter"><a class="header" href="#eventemitter">EventEmitter</a></h1>
<p>Fully qualified path: <code>core::starknet::event::EventEmitter</code></p>
<pre><code class="language-rust">pub trait EventEmitter&lt;T, TEvent&gt;</code></pre>
<h2 id="trait-functions-118"><a class="header" href="#trait-functions-118">Trait functions</a></h2>
<h3 id="emit"><a class="header" href="#emit">emit</a></h3>
<p>Fully qualified path: <code>core::starknet::event::EventEmitter::emit</code></p>
<pre><code class="language-rust">fn emit&lt;S, +Into&lt;S, TEvent&gt;&gt;(ref self: T, event: S)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontract-1"><a class="header" href="#accountcontract-1">AccountContract</a></h1>
<p>A trait for account contracts that support class declarations (only <code>__validate__</code> and <code>__execute__</code> are mandatory for an account).  This trait assumes that the calldata for invoke transactions is <code>Array&lt;Call&gt;</code>. This is the network standard following SNIP6. It is not enforced by StarkNet, but deviating from the standard interface may lead to incompatibility with standard tooling.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract</code></p>
<pre><code class="language-rust">pub trait AccountContract&lt;TContractState&gt;</code></pre>
<h2 id="trait-functions-119"><a class="header" href="#trait-functions-119">Trait functions</a></h2>
<h3 id="validate_declare-1"><a class="header" href="#validate_declare-1"><strong>validate_declare</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for the declaration of the class with the given hash. The entry point should return <code>core::starknet::VALIDATED</code> if the account is willing to pay for the declaration.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract::__validate_declare__</code></p>
<pre><code class="language-rust">fn __validate_declare__(self: @TContractState, class_hash: felt252) -&gt; felt252</code></pre>
<h3 id="validate-1"><a class="header" href="#validate-1"><strong>validate</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for executing a given set of calls. The entry point should return <code>core::starknet::VALIDATED</code> if the account is willing to pay for the execution, in which case <code>__execute__</code> will be called on the same set of calls.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract::__validate__</code></p>
<pre><code class="language-rust">fn __validate__(ref self: TContractState, calls: Array&lt;Call&gt;) -&gt; felt252</code></pre>
<h3 id="execute-1"><a class="header" href="#execute-1"><strong>execute</strong></a></h3>
<p>An entry point that is called to execute a given set of calls. This entry point should block the deprecated v0 invoke transactions as they do not go through the <code>__validate__</code> entry point.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContract::__execute__</code></p>
<pre><code class="language-rust">fn __execute__(ref self: TContractState, calls: Array&lt;Call&gt;) -&gt; Array&lt;Span&lt;felt252&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontractdispatchertrait"><a class="header" href="#accountcontractdispatchertrait">AccountContractDispatcherTrait</a></h1>
<p>Fully qualified path: <code>core::starknet::account::AccountContractDispatcherTrait</code></p>
<pre><code class="language-rust">pub trait AccountContractDispatcherTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-120"><a class="header" href="#trait-functions-120">Trait functions</a></h2>
<h3 id="validate_declare-2"><a class="header" href="#validate_declare-2"><strong>validate_declare</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for the declaration of the class with the given hash. The entry point should return <code>core::starknet::VALIDATED</code> if the account is willing to pay for the declaration.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContractDispatcherTrait::__validate_declare__</code></p>
<pre><code class="language-rust">fn __validate_declare__(self: T, class_hash: felt252) -&gt; felt252</code></pre>
<h3 id="validate-2"><a class="header" href="#validate-2"><strong>validate</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for executing a given set of calls. The entry point should return <code>core::starknet::VALIDATED</code> if the account is willing to pay for the execution, in which case <code>__execute__</code> will be called on the same set of calls.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContractDispatcherTrait::__validate__</code></p>
<pre><code class="language-rust">fn __validate__(self: T, calls: Array&lt;Call&gt;) -&gt; felt252</code></pre>
<h3 id="execute-2"><a class="header" href="#execute-2"><strong>execute</strong></a></h3>
<p>An entry point that is called to execute a given set of calls. This entry point should block the deprecated v0 invoke transactions as they do not go through the <code>__validate__</code> entry point.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContractDispatcherTrait::__execute__</code></p>
<pre><code class="language-rust">fn __execute__(self: T, calls: Array&lt;Call&gt;) -&gt; Array&lt;Span&lt;felt252&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accountcontractsafedispatchertrait"><a class="header" href="#accountcontractsafedispatchertrait">AccountContractSafeDispatcherTrait</a></h1>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeDispatcherTrait</code></p>
<pre><code class="language-rust">pub trait AccountContractSafeDispatcherTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-121"><a class="header" href="#trait-functions-121">Trait functions</a></h2>
<h3 id="validate_declare-3"><a class="header" href="#validate_declare-3"><strong>validate_declare</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for the declaration of the class with the given hash. The entry point should return <code>core::starknet::VALIDATED</code> if the account is willing to pay for the declaration.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeDispatcherTrait::__validate_declare__</code></p>
<pre><code class="language-rust">fn __validate_declare__(self: T, class_hash: felt252) -&gt; starknet::SyscallResult&lt;felt252&gt;</code></pre>
<h3 id="validate-3"><a class="header" href="#validate-3"><strong>validate</strong></a></h3>
<p>An entry point that is called to check if the account is willing to pay for executing a given set of calls. The entry point should return <code>core::starknet::VALIDATED</code> if the account is willing to pay for the execution, in which case <code>__execute__</code> will be called on the same set of calls.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeDispatcherTrait::__validate__</code></p>
<pre><code class="language-rust">fn __validate__(self: T, calls: Array&lt;Call&gt;) -&gt; starknet::SyscallResult&lt;felt252&gt;</code></pre>
<h3 id="execute-3"><a class="header" href="#execute-3"><strong>execute</strong></a></h3>
<p>An entry point that is called to execute a given set of calls. This entry point should block the deprecated v0 invoke transactions as they do not go through the <code>__validate__</code> entry point.</p>
<p>Fully qualified path: <code>core::starknet::account::AccountContractSafeDispatcherTrait::__execute__</code></p>
<pre><code class="language-rust">fn __execute__(self: T, calls: Array&lt;Call&gt;) -&gt; starknet::SyscallResult&lt;Array&lt;Span&lt;felt252&gt;&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storageaspointer"><a class="header" href="#storageaspointer">StorageAsPointer</a></h1>
<p>Trait for converting a storage member to a <code>StoragePointer0Offset</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::StorageAsPointer</code></p>
<pre><code class="language-rust">pub trait StorageAsPointer&lt;TMemberState&gt;</code></pre>
<h2 id="trait-functions-122"><a class="header" href="#trait-functions-122">Trait functions</a></h2>
<h3 id="as_ptr"><a class="header" href="#as_ptr">as_ptr</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorageAsPointer::as_ptr</code></p>
<pre><code class="language-rust">fn as_ptr(self: @TMemberState) -&gt; StoragePointer0Offset&lt;Self::Value&gt;</code></pre>
<h2 id="trait-types-17"><a class="header" href="#trait-types-17">Trait types</a></h2>
<h3 id="value"><a class="header" href="#value">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorageAsPointer::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagepointerreadaccess"><a class="header" href="#storagepointerreadaccess">StoragePointerReadAccess</a></h1>
<p>Trait for accessing the values in storage using a <code>StoragePointer</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointerReadAccess</code></p>
<pre><code class="language-rust">pub trait StoragePointerReadAccess&lt;T&gt;</code></pre>
<h2 id="trait-functions-123"><a class="header" href="#trait-functions-123">Trait functions</a></h2>
<h3 id="read-2"><a class="header" href="#read-2">read</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointerReadAccess::read</code></p>
<pre><code class="language-rust">fn read(self: @T) -&gt; Self::Value</code></pre>
<h2 id="trait-types-18"><a class="header" href="#trait-types-18">Trait types</a></h2>
<h3 id="value-1"><a class="header" href="#value-1">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointerReadAccess::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagepointerwriteaccess"><a class="header" href="#storagepointerwriteaccess">StoragePointerWriteAccess</a></h1>
<p>Trait for writing values to storage using a <code>StoragePointer</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointerWriteAccess</code></p>
<pre><code class="language-rust">pub trait StoragePointerWriteAccess&lt;T&gt;</code></pre>
<h2 id="trait-functions-124"><a class="header" href="#trait-functions-124">Trait functions</a></h2>
<h3 id="write-2"><a class="header" href="#write-2">write</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointerWriteAccess::write</code></p>
<pre><code class="language-rust">fn write(self: T, value: Self::Value)</code></pre>
<h2 id="trait-types-19"><a class="header" href="#trait-types-19">Trait types</a></h2>
<h3 id="value-2"><a class="header" href="#value-2">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StoragePointerWriteAccess::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storageaspath"><a class="header" href="#storageaspath">StorageAsPath</a></h1>
<p>Trait for creating a new <code>StoragePath</code> from a storage member.</p>
<p>Fully qualified path: <code>core::starknet::storage::StorageAsPath</code></p>
<pre><code class="language-rust">pub trait StorageAsPath&lt;TMemberState&gt;</code></pre>
<h2 id="trait-functions-125"><a class="header" href="#trait-functions-125">Trait functions</a></h2>
<h3 id="as_path"><a class="header" href="#as_path">as_path</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorageAsPath::as_path</code></p>
<pre><code class="language-rust">fn as_path(self: @TMemberState) -&gt; StoragePath&lt;Self::Value&gt;</code></pre>
<h2 id="trait-types-20"><a class="header" href="#trait-types-20">Trait types</a></h2>
<h3 id="value-3"><a class="header" href="#value-3">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorageAsPath::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pendingstoragepathtrait"><a class="header" href="#pendingstoragepathtrait">PendingStoragePathTrait</a></h1>
<p>A trait for creating a <code>PendingStoragePath</code> from a hash state and a key.</p>
<p>Fully qualified path: <code>core::starknet::storage::PendingStoragePathTrait</code></p>
<pre><code class="language-rust">pub trait PendingStoragePathTrait&lt;T, S&gt;</code></pre>
<h2 id="trait-functions-126"><a class="header" href="#trait-functions-126">Trait functions</a></h2>
<h3 id="new-6"><a class="header" href="#new-6">new</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::PendingStoragePathTrait::new</code></p>
<pre><code class="language-rust">fn new(storage_path: @StoragePath&lt;S&gt;, pending_key: felt252) -&gt; PendingStoragePath&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vectrait"><a class="header" href="#vectrait">VecTrait</a></h1>
<p>Trait for the interface of a storage vec.</p>
<p>Fully qualified path: <code>core::starknet::storage::vec::VecTrait</code></p>
<pre><code class="language-rust">pub trait VecTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-127"><a class="header" href="#trait-functions-127">Trait functions</a></h2>
<h3 id="get-3"><a class="header" href="#get-3">get</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::vec::VecTrait::get</code></p>
<pre><code class="language-rust">fn get(self: T, index: u64) -&gt; Option&lt;StoragePath&lt;Self::ElementType&gt;&gt;</code></pre>
<h3 id="at-2"><a class="header" href="#at-2">at</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::vec::VecTrait::at</code></p>
<pre><code class="language-rust">fn at(self: T, index: u64) -&gt; StoragePath&lt;Self::ElementType&gt;</code></pre>
<h3 id="len-2"><a class="header" href="#len-2">len</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::vec::VecTrait::len</code></p>
<pre><code class="language-rust">fn len(self: T) -&gt; u64</code></pre>
<h2 id="trait-types-21"><a class="header" href="#trait-types-21">Trait types</a></h2>
<h3 id="elementtype"><a class="header" href="#elementtype">ElementType</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::vec::VecTrait::ElementType</code></p>
<pre><code class="language-rust">type ElementType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutablevectrait"><a class="header" href="#mutablevectrait">MutableVecTrait</a></h1>
<p>Trait for the interface of a mutable storage vec.</p>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait</code></p>
<pre><code class="language-rust">pub trait MutableVecTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-128"><a class="header" href="#trait-functions-128">Trait functions</a></h2>
<h3 id="get-4"><a class="header" href="#get-4">get</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait::get</code></p>
<pre><code class="language-rust">fn get(self: T, index: u64) -&gt; Option&lt;StoragePath&lt;Mutable&lt;Self::ElementType&gt;&gt;&gt;</code></pre>
<h3 id="at-3"><a class="header" href="#at-3">at</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait::at</code></p>
<pre><code class="language-rust">fn at(self: T, index: u64) -&gt; StoragePath&lt;Mutable&lt;Self::ElementType&gt;&gt;</code></pre>
<h3 id="len-3"><a class="header" href="#len-3">len</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait::len</code></p>
<pre><code class="language-rust">fn len(self: T) -&gt; u64</code></pre>
<h3 id="append-1"><a class="header" href="#append-1">append</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait::append</code></p>
<pre><code class="language-rust">fn append(self: T) -&gt; StoragePath&lt;Mutable&lt;Self::ElementType&gt;&gt;</code></pre>
<h2 id="trait-types-22"><a class="header" href="#trait-types-22">Trait types</a></h2>
<h3 id="elementtype-1"><a class="header" href="#elementtype-1">ElementType</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::vec::MutableVecTrait::ElementType</code></p>
<pre><code class="language-rust">type ElementType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagenode"><a class="header" href="#storagenode">StorageNode</a></h1>
<p>A trait that given a storage path of a struct, generates the storage node of this struct.  The storage node is a struct that is used to structure the storage of a struct, while taking into account this structure when computing the address of the struct members in the storage. The trigger for creating a storage node is the <code>#[starknet::storage_node]</code> attribute.  Storage nodes are used in order to structure the storage of a struct, while not enforcing the struct to be sequential in the storage. This is useful for structs that contains phantom types such as <code>Map</code> and <code>Vec</code>. As a result, structs attributed with <code>#[starknet::storage_node]</code> are also considered to be phantom types, although not explicitly annotated as such. Structs which do not contain phantom types, can still be declared a storage node, and it will make them a phantom type. However, it may be preferable to simply make this struct storable (i.e. <code>#[derive(Store)]') instead. This will still allow accessing individual members of the struct (see </code>SubPointers`), but will not make the struct a phantom type.  For example, given the following struct:</p>
<pre><code class="language-cairo"><span class="boring">[starknet::storage_node]
</span>struct MyStruct {
   a: felt252,
   b: Map&lt;felt252, felt52&gt;,
}
</code></pre>
<p>The following storage node struct and impl will be generated:</p>
<pre><code class="language-cairo">struct MyStructStorageNode {
    a: PendingStoragePath&lt;felt252&gt;,
    b: PendingStoragePath&lt;Map&lt;felt252, felt52&gt;&gt;,
}

impl MyStructStorageNodeImpl of StorageNode&lt;MyStruct&gt; {
   fn storage_node(self: StoragePath&lt;MyStruct&gt;) -&gt; MyStructStorageNode {
        MyStructStorageNode {
           a: PendingStoragePathTrait::new(@self, selector!("a")),
           b: PendingStoragePathTrait::new(@self, selector!("b")),
        }
   }
}
</code></pre>
<p>For a type <code>T</code> that implement <code>StorageNode</code> (e.g. <code>MyStruct</code> in the example above), <code>Deref&lt;StoragePath&lt;T&gt;&gt;</code> is implemented as simply calling <code>storage_node</code>, and thus exposing the members of the storage node (<code>a</code> and <code>b</code> in the example above). For example, given the following storage:</p>
<pre><code class="language-cairo"><span class="boring">[storage]
</span>struct Storage {
    my_struct: MyStruct,
    a: felt52,
}

We can access the members of the storage node as follows:
</code></pre>
<p>fn use_storage(self: @ContractState) {    let a_value = self.a.read();    let inner_a_value = self.my_struct.a.read();    let b_value = self.my_struct.b.entry(42).read(); }</p>
<pre><code class="language-cairo">
If a member is annotated with `#[flat]`, the storage node will be flattened, and the
member name (i.e. `my_struct`) will not affect the address of the storage object.
In the storage example above, it will look like:
</code></pre>
<p>#<a href="%5Bstorage%5D">storage</a> struct Storage {    #<a href="%5Bflat%5D">flat</a>    my_struct: MyStruct,    a: felt52, }  In this case, the storage node will be flattened, and both <code>self.a</code> and <code>self.my_struct.a</code> will point to the same address. This behavior is rarely intended, and thus <code>#[flat]</code> should be used with caution.  Notice that the members of the storage node are <code>PendingStoragePath</code> instances, which are used to lazily get the updated storage path of the struct members, in this way only members that are accessed are actually evaluated.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_node::StorageNode</code></p>
<pre><code class="language-rust">pub trait StorageNode&lt;T&gt;</code></pre>
<h2 id="trait-functions-129"><a class="header" href="#trait-functions-129">Trait functions</a></h2>
<h3 id="storage_node"><a class="header" href="#storage_node">storage_node</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::storage_node::StorageNode::storage_node</code></p>
<pre><code class="language-rust">fn storage_node(self: StoragePath&lt;T&gt;) -&gt; Self::NodeType</code></pre>
<h2 id="trait-types-23"><a class="header" href="#trait-types-23">Trait types</a></h2>
<h3 id="nodetype"><a class="header" href="#nodetype">NodeType</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::storage_node::StorageNode::NodeType</code></p>
<pre><code class="language-rust">type NodeType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagenodemut"><a class="header" href="#storagenodemut">StorageNodeMut</a></h1>
<p>A mutable version of <code>StorageNode</code>, works the same way, but on <code>Mutable&lt;T&gt;</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_node::StorageNodeMut</code></p>
<pre><code class="language-rust">pub trait StorageNodeMut&lt;T&gt;</code></pre>
<h2 id="trait-functions-130"><a class="header" href="#trait-functions-130">Trait functions</a></h2>
<h3 id="storage_node_mut"><a class="header" href="#storage_node_mut">storage_node_mut</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::storage_node::StorageNodeMut::storage_node_mut</code></p>
<pre><code class="language-rust">fn storage_node_mut(self: StoragePath&lt;Mutable&lt;T&gt;&gt;) -&gt; Self::NodeType</code></pre>
<h2 id="trait-types-24"><a class="header" href="#trait-types-24">Trait types</a></h2>
<h3 id="nodetype-1"><a class="header" href="#nodetype-1">NodeType</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::storage_node::StorageNodeMut::NodeType</code></p>
<pre><code class="language-rust">type NodeType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subpointers"><a class="header" href="#subpointers">SubPointers</a></h1>
<p>Similar to storage node, but for structs which are stored sequentially in the storage. In contrast to storage node, the fields of the struct are just offsetted from the base address of the struct.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointers</code></p>
<pre><code class="language-rust">pub trait SubPointers&lt;T&gt;</code></pre>
<h2 id="trait-functions-131"><a class="header" href="#trait-functions-131">Trait functions</a></h2>
<h3 id="sub_pointers"><a class="header" href="#sub_pointers">sub_pointers</a></h3>
<p>Creates a sub pointers struct for the given storage pointer to a struct T.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointers::sub_pointers</code></p>
<pre><code class="language-rust">fn sub_pointers(self: StoragePointer&lt;T&gt;) -&gt; Self::SubPointersType</code></pre>
<h2 id="trait-types-25"><a class="header" href="#trait-types-25">Trait types</a></h2>
<h3 id="subpointerstype"><a class="header" href="#subpointerstype">SubPointersType</a></h3>
<p>The type of the storage pointers, generated for the struct T.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointers::SubPointersType</code></p>
<pre><code class="language-rust">type SubPointersType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subpointersmut"><a class="header" href="#subpointersmut">SubPointersMut</a></h1>
<p>A mutable version of <code>SubPointers</code>, works the same way, but on <code>Mutable&lt;T&gt;</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersMut</code></p>
<pre><code class="language-rust">pub trait SubPointersMut&lt;T&gt;</code></pre>
<h2 id="trait-functions-132"><a class="header" href="#trait-functions-132">Trait functions</a></h2>
<h3 id="sub_pointers_mut"><a class="header" href="#sub_pointers_mut">sub_pointers_mut</a></h3>
<p>Creates a sub pointers struct for the given storage pointer to a struct T.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersMut::sub_pointers_mut</code></p>
<pre><code class="language-rust">fn sub_pointers_mut(self: StoragePointer&lt;Mutable&lt;T&gt;&gt;) -&gt; Self::SubPointersType</code></pre>
<h2 id="trait-types-26"><a class="header" href="#trait-types-26">Trait types</a></h2>
<h3 id="subpointerstype-1"><a class="header" href="#subpointerstype-1">SubPointersType</a></h3>
<p>The type of the storage pointers, generated for the struct T.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersMut::SubPointersType</code></p>
<pre><code class="language-rust">type SubPointersType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subpointersforward"><a class="header" href="#subpointersforward">SubPointersForward</a></h1>
<p>A trait for implementing <code>SubPointers</code> for types which are not a <code>StoragePointer</code>, such as <code>StorageBase</code> and <code>StoragePath</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersForward</code></p>
<pre><code class="language-rust">pub trait SubPointersForward&lt;T&gt;</code></pre>
<h2 id="trait-functions-133"><a class="header" href="#trait-functions-133">Trait functions</a></h2>
<h3 id="sub_pointers-1"><a class="header" href="#sub_pointers-1">sub_pointers</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersForward::sub_pointers</code></p>
<pre><code class="language-rust">fn sub_pointers(self: T) -&gt; Self::SubPointersType</code></pre>
<h2 id="trait-types-27"><a class="header" href="#trait-types-27">Trait types</a></h2>
<h3 id="subpointerstype-2"><a class="header" href="#subpointerstype-2">SubPointersType</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersForward::SubPointersType</code></p>
<pre><code class="language-rust">type SubPointersType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subpointersmutforward"><a class="header" href="#subpointersmutforward">SubPointersMutForward</a></h1>
<p>A trait for implementing <code>SubPointersMut</code> for types which are not a <code>StoragePointer</code>, such as <code>StorageBase</code> and <code>StoragePath</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersMutForward</code></p>
<pre><code class="language-rust">pub trait SubPointersMutForward&lt;T&gt;</code></pre>
<h2 id="trait-functions-134"><a class="header" href="#trait-functions-134">Trait functions</a></h2>
<h3 id="sub_pointers_mut-1"><a class="header" href="#sub_pointers_mut-1">sub_pointers_mut</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersMutForward::sub_pointers_mut</code></p>
<pre><code class="language-rust">fn sub_pointers_mut(self: T) -&gt; Self::SubPointersType</code></pre>
<h2 id="trait-types-28"><a class="header" href="#trait-types-28">Trait types</a></h2>
<h3 id="subpointerstype-3"><a class="header" href="#subpointerstype-3">SubPointersType</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::sub_pointers::SubPointersMutForward::SubPointersType</code></p>
<pre><code class="language-rust">type SubPointersType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagetrait"><a class="header" href="#storagetrait">StorageTrait</a></h1>
<p>A trait for creating the struct containing the StorageBase or FlattenedStorage of all the members of a contract state.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageTrait</code></p>
<pre><code class="language-rust">pub trait StorageTrait&lt;T&gt;</code></pre>
<h2 id="trait-functions-135"><a class="header" href="#trait-functions-135">Trait functions</a></h2>
<h3 id="storage-1"><a class="header" href="#storage-1">storage</a></h3>
<p>Creates a struct containing the StorageBase or FlattenedStorage of all the members of a contract state. Should be called from the <code>deref</code> method of the contract state.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageTrait::storage</code></p>
<pre><code class="language-rust">fn storage(self: FlattenedStorage&lt;T&gt;) -&gt; Self::BaseType</code></pre>
<h2 id="trait-types-29"><a class="header" href="#trait-types-29">Trait types</a></h2>
<h3 id="basetype"><a class="header" href="#basetype">BaseType</a></h3>
<p>The type of the struct containing the StorageBase or FlattenedStorage of all the members of a the type <code>T</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageTrait::BaseType</code></p>
<pre><code class="language-rust">type BaseType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagetraitmut"><a class="header" href="#storagetraitmut">StorageTraitMut</a></h1>
<p>A trait for creating the struct containing the mutable StorageBase or FlattenedStorage of all the members of a contract state.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageTraitMut</code></p>
<pre><code class="language-rust">pub trait StorageTraitMut&lt;T&gt;</code></pre>
<h2 id="trait-functions-136"><a class="header" href="#trait-functions-136">Trait functions</a></h2>
<h3 id="storage_mut"><a class="header" href="#storage_mut">storage_mut</a></h3>
<p>Creates a struct containing a mutable version of the the StorageBase or FlattenedStorage of all the members of a contract state. Should be called from the <code>deref</code> method of the contract state.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageTraitMut::storage_mut</code></p>
<pre><code class="language-rust">fn storage_mut(self: FlattenedStorage&lt;Mutable&lt;T&gt;&gt;) -&gt; Self::BaseType</code></pre>
<h2 id="trait-types-30"><a class="header" href="#trait-types-30">Trait types</a></h2>
<h3 id="basetype-1"><a class="header" href="#basetype-1">BaseType</a></h3>
<p>The type of the struct containing the mutable StorageBase or FlattenedStorage of all the members of a the type <code>T</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage::storage_base::StorageTraitMut::BaseType</code></p>
<pre><code class="language-rust">type BaseType;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagemapreadaccess"><a class="header" href="#storagemapreadaccess">StorageMapReadAccess</a></h1>
<p>Trait for reading a contract/component storage member in a specific key place.</p>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapReadAccess</code></p>
<pre><code class="language-rust">pub trait StorageMapReadAccess&lt;TMemberState&gt;</code></pre>
<h2 id="trait-functions-137"><a class="header" href="#trait-functions-137">Trait functions</a></h2>
<h3 id="read-3"><a class="header" href="#read-3">read</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapReadAccess::read</code></p>
<pre><code class="language-rust">fn read(self: TMemberState, key: Self::Key) -&gt; Self::Value</code></pre>
<h2 id="trait-types-31"><a class="header" href="#trait-types-31">Trait types</a></h2>
<h3 id="key"><a class="header" href="#key">Key</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapReadAccess::Key</code></p>
<pre><code class="language-rust">type Key;</code></pre>
<h3 id="value-4"><a class="header" href="#value-4">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapReadAccess::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagemapwriteaccess"><a class="header" href="#storagemapwriteaccess">StorageMapWriteAccess</a></h1>
<p>Trait for writing contract/component storage member in a specific key place.</p>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapWriteAccess</code></p>
<pre><code class="language-rust">pub trait StorageMapWriteAccess&lt;TMemberState&gt;</code></pre>
<h2 id="trait-functions-138"><a class="header" href="#trait-functions-138">Trait functions</a></h2>
<h3 id="write-3"><a class="header" href="#write-3">write</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapWriteAccess::write</code></p>
<pre><code class="language-rust">fn write(self: TMemberState, key: Self::Key, value: Self::Value)</code></pre>
<h2 id="trait-types-32"><a class="header" href="#trait-types-32">Trait types</a></h2>
<h3 id="key-1"><a class="header" href="#key-1">Key</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapWriteAccess::Key</code></p>
<pre><code class="language-rust">type Key;</code></pre>
<h3 id="value-5"><a class="header" href="#value-5">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StorageMapWriteAccess::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagepathentry"><a class="header" href="#storagepathentry">StoragePathEntry</a></h1>
<p>Trait for updating the hash state with a value, using an <code>entry</code> method.</p>
<p>Fully qualified path: <code>core::starknet::storage::map::StoragePathEntry</code></p>
<pre><code class="language-rust">pub trait StoragePathEntry&lt;C&gt;</code></pre>
<h2 id="trait-functions-139"><a class="header" href="#trait-functions-139">Trait functions</a></h2>
<h3 id="entry-1"><a class="header" href="#entry-1">entry</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StoragePathEntry::entry</code></p>
<pre><code class="language-rust">fn entry(self: C, key: Self::Key) -&gt; StoragePath&lt;Self::Value&gt;</code></pre>
<h2 id="trait-types-33"><a class="header" href="#trait-types-33">Trait types</a></h2>
<h3 id="key-2"><a class="header" href="#key-2">Key</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StoragePathEntry::Key</code></p>
<pre><code class="language-rust">type Key;</code></pre>
<h3 id="value-6"><a class="header" href="#value-6">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::map::StoragePathEntry::Value</code></p>
<pre><code class="language-rust">type Value;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addhelper"><a class="header" href="#addhelper">AddHelper</a></h1>
<p>A helper trait for adding two <code>BoundedInt</code> instances.</p>
<p>Fully qualified path: <code>core::internal::bounded_int::AddHelper</code></p>
<pre><code class="language-rust">pub trait AddHelper&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-types-34"><a class="header" href="#trait-types-34">Trait types</a></h2>
<h3 id="result-2"><a class="header" href="#result-2">Result</a></h3>
<p>Fully qualified path: <code>core::internal::bounded_int::AddHelper::Result</code></p>
<pre><code class="language-rust">type Result;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subhelper"><a class="header" href="#subhelper">SubHelper</a></h1>
<p>A helper trait for subtracting two <code>BoundedInt</code> instances.</p>
<p>Fully qualified path: <code>core::internal::bounded_int::SubHelper</code></p>
<pre><code class="language-rust">pub trait SubHelper&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-types-35"><a class="header" href="#trait-types-35">Trait types</a></h2>
<h3 id="result-3"><a class="header" href="#result-3">Result</a></h3>
<p>Fully qualified path: <code>core::internal::bounded_int::SubHelper::Result</code></p>
<pre><code class="language-rust">type Result;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mulhelper"><a class="header" href="#mulhelper">MulHelper</a></h1>
<p>A helper trait for multiplying two <code>BoundedInt</code> instances.</p>
<p>Fully qualified path: <code>core::internal::bounded_int::MulHelper</code></p>
<pre><code class="language-rust">pub trait MulHelper&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-types-36"><a class="header" href="#trait-types-36">Trait types</a></h2>
<h3 id="result-4"><a class="header" href="#result-4">Result</a></h3>
<p>Fully qualified path: <code>core::internal::bounded_int::MulHelper::Result</code></p>
<pre><code class="language-rust">type Result;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="divremhelper"><a class="header" href="#divremhelper">DivRemHelper</a></h1>
<p>A helper trait for dividing two <code>BoundedInt</code> instances.</p>
<p>Fully qualified path: <code>core::internal::bounded_int::DivRemHelper</code></p>
<pre><code class="language-rust">pub trait DivRemHelper&lt;Lhs, Rhs&gt;</code></pre>
<h2 id="trait-types-37"><a class="header" href="#trait-types-37">Trait types</a></h2>
<h3 id="divt"><a class="header" href="#divt">DivT</a></h3>
<p>Fully qualified path: <code>core::internal::bounded_int::DivRemHelper::DivT</code></p>
<pre><code class="language-rust">type DivT;</code></pre>
<h3 id="remt"><a class="header" href="#remt">RemT</a></h3>
<p>Fully qualified path: <code>core::internal::bounded_int::DivRemHelper::RemT</code></p>
<pre><code class="language-rust">type RemT;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constrainhelper"><a class="header" href="#constrainhelper">ConstrainHelper</a></h1>
<p>A helper trait for constraining a <code>BoundedInt</code> instance.</p>
<p>Fully qualified path: <code>core::internal::bounded_int::ConstrainHelper</code></p>
<pre><code class="language-rust">pub trait ConstrainHelper&lt;T, const BOUNDARY: felt252&gt;</code></pre>
<h2 id="trait-types-38"><a class="header" href="#trait-types-38">Trait types</a></h2>
<h3 id="lowt"><a class="header" href="#lowt">LowT</a></h3>
<p>Fully qualified path: <code>core::internal::bounded_int::ConstrainHelper::LowT</code></p>
<pre><code class="language-rust">type LowT;</code></pre>
<h3 id="hight"><a class="header" href="#hight">HighT</a></h3>
<p>Fully qualified path: <code>core::internal::bounded_int::ConstrainHelper::HighT</code></p>
<pre><code class="language-rust">type HighT;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trimhelper"><a class="header" href="#trimhelper">TrimHelper</a></h1>
<p>A helper trait for trimming a <code>BoundedInt</code> instance.</p>
<p>Fully qualified path: <code>core::internal::bounded_int::TrimHelper</code></p>
<pre><code class="language-rust">pub trait TrimHelper&lt;T, const TRIMMED_VALUE: felt252&gt;</code></pre>
<h2 id="trait-types-39"><a class="header" href="#trait-types-39">Trait types</a></h2>
<h3 id="target-13"><a class="header" href="#target-13">Target</a></h3>
<p>Fully qualified path: <code>core::internal::bounded_int::TrimHelper::Target</code></p>
<pre><code class="language-rust">type Target;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="negatehelper"><a class="header" href="#negatehelper">NegateHelper</a></h1>
<p>A helper trait for negating a <code>BoundedInt</code> instance.</p>
<p>Fully qualified path: <code>core::internal::bounded_int::NegateHelper</code></p>
<pre><code class="language-rust">pub trait NegateHelper&lt;T&gt;</code></pre>
<h2 id="trait-functions-140"><a class="header" href="#trait-functions-140">Trait functions</a></h2>
<h3 id="negate"><a class="header" href="#negate">negate</a></h3>
<p>Negates the given value.</p>
<p>Fully qualified path: <code>core::internal::bounded_int::NegateHelper::negate</code></p>
<pre><code class="language-rust">fn negate(self: T) -&gt; Self::Result</code></pre>
<h3 id="negate_nz"><a class="header" href="#negate_nz">negate_nz</a></h3>
<p>Negates the given non-zero value.</p>
<p>Fully qualified path: <code>core::internal::bounded_int::NegateHelper::negate_nz</code></p>
<pre><code class="language-rust">fn negate_nz(self: NonZero&lt;T&gt;) -&gt; NonZero&lt;Self::Result&gt;</code></pre>
<h2 id="trait-types-40"><a class="header" href="#trait-types-40">Trait types</a></h2>
<h3 id="result-5"><a class="header" href="#result-5">Result</a></h3>
<p>The result of negating the given value.</p>
<p>Fully qualified path: <code>core::internal::bounded_int::NegateHelper::Result</code></p>
<pre><code class="language-rust">type Result;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zeroable-1"><a class="header" href="#zeroable-1">Zeroable</a></h1>
<p>A trait for types that have a concept of zero and can be compared to zero.  This trait is useful for numeric types or any type that has an additive identity element.</p>
<p>Fully qualified path: <code>core::zeroable::Zeroable</code></p>
<pre><code class="language-rust">pub(crate) trait Zeroable&lt;T&gt;</code></pre>
<h2 id="trait-functions-141"><a class="header" href="#trait-functions-141">Trait functions</a></h2>
<h3 id="zero-6"><a class="header" href="#zero-6">zero</a></h3>
<p>Returns the additive identity element of <code>self</code>, 0.  This method should return a value that, when added to any other value of type <code>T</code>, does not change that value.  # Examples</p>
<pre><code class="language-cairo">assert!(Zeroable::&lt;i32&gt;::zero() == 0);
</code></pre>
<p>Fully qualified path: <code>core::zeroable::Zeroable::zero</code></p>
<pre><code class="language-rust">fn zero() -&gt; T</code></pre>
<h3 id="is_zero-2"><a class="header" href="#is_zero-2">is_zero</a></h3>
<p>Returns whether <code>self</code> is equal to 0, the additive identity element.  # Examples</p>
<pre><code class="language-cairo">assert!(0.is_zero());
assert!(!5.is_zero());
</code></pre>
<p>Fully qualified path: <code>core::zeroable::Zeroable::is_zero</code></p>
<pre><code class="language-rust">fn is_zero(self: T) -&gt; bool</code></pre>
<h3 id="is_non_zero-2"><a class="header" href="#is_non_zero-2">is_non_zero</a></h3>
<p>Returns whether <code>self</code> is not equal to 0, the additive identity element.  This method is the logical inverse of <code>is_zero()</code>.  # Examples</p>
<pre><code class="language-cairo">assert!(5.is_non_zero());
assert!(!0.is_non_zero());
</code></pre>
<p>Fully qualified path: <code>core::zeroable::Zeroable::is_non_zero</code></p>
<pre><code class="language-rust">fn is_non_zero(self: T) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes31trait"><a class="header" href="#bytes31trait">Bytes31Trait</a></h1>
<p>Fully qualified path: <code>core::bytes_31::Bytes31Trait</code></p>
<pre><code class="language-rust">pub trait Bytes31Trait</code></pre>
<h2 id="trait-functions-142"><a class="header" href="#trait-functions-142">Trait functions</a></h2>
<h3 id="at-4"><a class="header" href="#at-4">at</a></h3>
<p>Returns the byte at the given index (LSB's index is 0).  Assumes that <code>index &lt; BYTES_IN_BYTES31</code>. If the assumption is not met, the behavior is undefined.  # Examples</p>
<pre><code class="language-cairo">let bytes: bytes31 = 1_u8.into();
assert!(bytes.at(0) == 1);
</code></pre>
<p>Fully qualified path: <code>core::bytes_31::Bytes31Trait::at</code></p>
<pre><code class="language-rust">fn at(self: @bytes31, index: usize) -&gt; u8</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytearraytrait"><a class="header" href="#bytearraytrait">ByteArrayTrait</a></h1>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait</code></p>
<pre><code class="language-rust">pub trait ByteArrayTrait</code></pre>
<h2 id="trait-functions-143"><a class="header" href="#trait-functions-143">Trait functions</a></h2>
<h3 id="append_word"><a class="header" href="#append_word">append_word</a></h3>
<p>Appends a single word of <code>len</code> bytes to the end of the <code>ByteArray</code>.  This function assumes that: 1. <code>word</code> could be validly converted to a <code>bytes31</code> which has no more than <code>len</code> bytes    of data. 2. len &lt;= BYTES_IN_BYTES31.  If these assumptions are not met, it can corrupt the <code>ByteArray</code>. Thus, this should be a private function. We could add masking/assertions but it would be more expensive.  # Examples</p>
<pre><code class="language-cairo">let mut ba = "";
ba.append_word('word', 4);
assert!(ba == "word");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_word</code></p>
<pre><code class="language-rust">fn append_word(ref self: ByteArray, word: felt252, len: usize)</code></pre>
<h3 id="append-2"><a class="header" href="#append-2">append</a></h3>
<p>Appends a <code>ByteArray</code> to the end of another <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">let mut ba: ByteArray = "1";
ba.append(@"2");
assert!(ba == "12");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append</code></p>
<pre><code class="language-rust">fn append(ref self: ByteArray, other: @ByteArray)</code></pre>
<h3 id="concat"><a class="header" href="#concat">concat</a></h3>
<p>Concatenates two <code>ByteArray</code> and returns the result.  The content of <code>left</code> is cloned in a new memory segment. # Examples</p>
<pre><code class="language-cairo">let ba = "1";
let other_ba = "2";
let result = ByteArrayTrait::concat(@ba, @other_ba);
assert!(result == "12");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::concat</code></p>
<pre><code class="language-rust">fn concat(left: @ByteArray, right: @ByteArray) -&gt; ByteArray</code></pre>
<h3 id="append_byte"><a class="header" href="#append_byte">append_byte</a></h3>
<p>Appends a single byte to the end of the <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">let mut ba = "";
ba.append_byte(0);
assert!(ba == "0");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_byte</code></p>
<pre><code class="language-rust">fn append_byte(ref self: ByteArray, byte: u8)</code></pre>
<h3 id="len-4"><a class="header" href="#len-4">len</a></h3>
<p>Returns the length of the <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "byte array";
let len = ba.len();
assert!(len == 10);
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::len</code></p>
<pre><code class="language-rust">fn len(self: @ByteArray) -&gt; usize</code></pre>
<h3 id="at-5"><a class="header" href="#at-5">at</a></h3>
<p>Returns an option of the byte at the given index of <code>self</code> or <code>Option::None</code> if the index is out of bounds.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "byte array";
let byte = ba.at(0).unwrap();
assert!(byte == 98);
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::at</code></p>
<pre><code class="language-rust">fn at(self: @ByteArray, index: usize) -&gt; Option&lt;u8&gt;</code></pre>
<h3 id="rev"><a class="header" href="#rev">rev</a></h3>
<p>Returns a <code>ByteArray</code> with the reverse order of <code>self</code>.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "123";
let rev_ba = ba.rev();
assert!(rev_ba == "321");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::rev</code></p>
<pre><code class="language-rust">fn rev(self: @ByteArray) -&gt; ByteArray</code></pre>
<h3 id="append_word_rev"><a class="header" href="#append_word_rev">append_word_rev</a></h3>
<p>Appends the reverse of the given word to the end of <code>self</code>.  This function assumes that: 1. len &lt; 31 2. word is validly convertible to bytes31 of length <code>len</code>.  # Examples</p>
<pre><code class="language-cairo">let mut ba: ByteArray = "";
ba.append_word_rev('123', 3);
assert!(ba == "321");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_word_rev</code></p>
<pre><code class="language-rust">fn append_word_rev(ref self: ByteArray, word: felt252, len: usize)</code></pre>
<h3 id="append_word_fits_into_pending"><a class="header" href="#append_word_fits_into_pending">append_word_fits_into_pending</a></h3>
<p>Appends a single word of <code>len</code> bytes to the end of the <code>ByteArray</code>, assuming there is enough space in the pending word (<code>self.pending_word_len + len &lt; BYTES_IN_BYTES31</code>).  <code>word</code> is of type <code>felt252</code> but actually represents a <code>bytes31</code>. It is represented as a <code>felt252</code> to improve performance of building the <code>ByteArray</code>.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_word_fits_into_pending</code></p>
<pre><code class="language-rust">fn append_word_fits_into_pending(ref self: ByteArray, word: felt252, len: usize)</code></pre>
<h3 id="append_split_index_lt_16"><a class="header" href="#append_split_index_lt_16">append_split_index_lt_16</a></h3>
<p>Appends a single word to the end of <code>self</code>, given that <code>0 &lt; split_index &lt; 16</code>.  <code>split_index</code> is the number of bytes left in <code>self.pending_word</code> after this function. This is the index of the split (LSB's index is 0).  Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_split_index_lt_16</code></p>
<pre><code class="language-rust">fn append_split_index_lt_16(ref self: ByteArray, word: felt252, split_index: usize)</code></pre>
<h3 id="append_split_index_16"><a class="header" href="#append_split_index_16">append_split_index_16</a></h3>
<p>Appends a single word to the end of <code>self</code>, given that the index of splitting <code>word</code> is exactly 16.  <code>split_index</code> is the number of bytes left in <code>self.pending_word</code> after this function. This is the index of the split (LSB's index is 0).  Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_split_index_16</code></p>
<pre><code class="language-rust">fn append_split_index_16(ref self: ByteArray, word: felt252)</code></pre>
<h3 id="append_split_index_gt_16"><a class="header" href="#append_split_index_gt_16">append_split_index_gt_16</a></h3>
<p>Appends a single word to the end of <code>self</code>, given that the index of splitting <code>word</code> is &gt; 16.  <code>split_index</code> is the number of bytes left in <code>self.pending_word</code> after this function. This is the index of the split (LSB's index is 0).  Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_split_index_gt_16</code></p>
<pre><code class="language-rust">fn append_split_index_gt_16(ref self: ByteArray, word: felt252, split_index: usize)</code></pre>
<h3 id="append_split"><a class="header" href="#append_split">append_split</a></h3>
<p>A helper function to append a remainder to <code>self</code>, by: 1. completing <code>self.pending_word</code> to a full word using <code>complete_full_word</code>, assuming it's    validly convertible to a <code>bytes31</code> of length exactly <code>BYTES_IN_BYTES31 -    self.pending_word_len</code>. 2. Setting <code>self.pending_word</code> to <code>new_pending</code>.  Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayTrait::append_split</code></p>
<pre><code class="language-rust">fn append_split(ref self: ByteArray, complete_full_word: felt252, new_pending: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stringliteral"><a class="header" href="#stringliteral">StringLiteral</a></h1>
<p>Fully qualified path: <code>core::string::StringLiteral</code></p>
<pre><code class="language-rust">pub trait StringLiteral&lt;T&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendformattedtobytearray"><a class="header" href="#appendformattedtobytearray">AppendFormattedToByteArray</a></h1>
<p>A trait for appending the ASCII representation of a number to an existing <code>ByteArray</code>.</p>
<p>Fully qualified path: <code>core::to_byte_array::AppendFormattedToByteArray</code></p>
<pre><code class="language-rust">pub trait AppendFormattedToByteArray&lt;T&gt;</code></pre>
<h2 id="trait-functions-144"><a class="header" href="#trait-functions-144">Trait functions</a></h2>
<h3 id="append_formatted_to_byte_array"><a class="header" href="#append_formatted_to_byte_array">append_formatted_to_byte_array</a></h3>
<p>Appends the ASCII representation of the value to the provided <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">use core::to_byte_array::AppendFormattedToByteArray;

let mut buffer = "Count: ";
let num: u32 = 42;
num.append_formatted_to_byte_array(ref buffer, 10);
assert!(buffer == "Count: 42");
</code></pre>
<p>Fully qualified path: <code>core::to_byte_array::AppendFormattedToByteArray::append_formatted_to_byte_array</code></p>
<pre><code class="language-rust">fn append_formatted_to_byte_array(self: @T, ref byte_array: ByteArray, base: NonZero&lt;T&gt;)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatasbytearray"><a class="header" href="#formatasbytearray">FormatAsByteArray</a></h1>
<p>A trait for formatting values into their ASCII string representation in a <code>ByteArray</code>.</p>
<p>Fully qualified path: <code>core::to_byte_array::FormatAsByteArray</code></p>
<pre><code class="language-rust">pub trait FormatAsByteArray&lt;T&gt;</code></pre>
<h2 id="trait-functions-145"><a class="header" href="#trait-functions-145">Trait functions</a></h2>
<h3 id="format_as_byte_array"><a class="header" href="#format_as_byte_array">format_as_byte_array</a></h3>
<p>Returns a new <code>ByteArray</code> containing the ASCII representation of the value.  # Examples</p>
<pre><code class="language-cairo">use core::to_byte_array::FormatAsByteArray;

let num: u32 = 42;
let formatted = num.format_as_byte_array(16);
assert!(formatted, "2a");
</code></pre>
<p>Fully qualified path: <code>core::to_byte_array::FormatAsByteArray::format_as_byte_array</code></p>
<pre><code class="language-rust">fn format_as_byte_array(self: @T, base: NonZero&lt;T&gt;) -&gt; ByteArray</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typeequal"><a class="header" href="#typeequal">TypeEqual</a></h1>
<p>A trait that can be used to disable implementations based on the types of the generic args. Assumes that <code>TypeEqualImpl</code> is the only implementation of this trait.</p>
<p>Fully qualified path: <code>core::metaprogramming::TypeEqual</code></p>
<pre><code class="language-rust">pub trait TypeEqual&lt;S, T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="istuple"><a class="header" href="#istuple">IsTuple</a></h1>
<p>Marker trait for types that are tuples. Currently supports tuples of size 0 to 10.</p>
<p>Fully qualified path: <code>core::metaprogramming::IsTuple</code></p>
<pre><code class="language-rust">pub(crate) trait IsTuple&lt;T&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuplesplit"><a class="header" href="#tuplesplit">TupleSplit</a></h1>
<p>A trait for splitting a tuple into head element and a tail tuple, as well as reconstructing from them.</p>
<p>Fully qualified path: <code>core::metaprogramming::TupleSplit</code></p>
<pre><code class="language-rust">pub(crate) trait TupleSplit&lt;T&gt;</code></pre>
<h2 id="trait-functions-146"><a class="header" href="#trait-functions-146">Trait functions</a></h2>
<h3 id="split_head"><a class="header" href="#split_head">split_head</a></h3>
<p>Splits the tuple into the head and the rest.</p>
<p>Fully qualified path: <code>core::metaprogramming::TupleSplit::split_head</code></p>
<pre><code class="language-rust">fn split_head(self: T) -&gt; (Self::Head, Self::Rest) nopanic</code></pre>
<h3 id="reconstruct"><a class="header" href="#reconstruct">reconstruct</a></h3>
<p>Reconstructs the tuple from the head and the rest.</p>
<p>Fully qualified path: <code>core::metaprogramming::TupleSplit::reconstruct</code></p>
<pre><code class="language-rust">fn reconstruct(head: Self::Head, rest: Self::Rest) -&gt; T nopanic</code></pre>
<h2 id="trait-types-41"><a class="header" href="#trait-types-41">Trait types</a></h2>
<h3 id="head"><a class="header" href="#head">Head</a></h3>
<p>The type of the first element of the tuple.</p>
<p>Fully qualified path: <code>core::metaprogramming::TupleSplit::Head</code></p>
<pre><code class="language-rust">type Head;</code></pre>
<h3 id="rest"><a class="header" href="#rest">Rest</a></h3>
<p>The type of the rest of the tuple.</p>
<p>Fully qualified path: <code>core::metaprogramming::TupleSplit::Rest</code></p>
<pre><code class="language-rust">type Rest;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tupleextendfront"><a class="header" href="#tupleextendfront">TupleExtendFront</a></h1>
<p>A trait for extending a tuple from the front.</p>
<p>Fully qualified path: <code>core::metaprogramming::TupleExtendFront</code></p>
<pre><code class="language-rust">pub(crate) trait TupleExtendFront&lt;T, E&gt;</code></pre>
<h2 id="trait-functions-147"><a class="header" href="#trait-functions-147">Trait functions</a></h2>
<h3 id="extend_front"><a class="header" href="#extend_front">extend_front</a></h3>
<p>Creates a new tuple from the <code>value</code> tuple with <code>element</code> in front of it.</p>
<p>Fully qualified path: <code>core::metaprogramming::TupleExtendFront::extend_front</code></p>
<pre><code class="language-rust">fn extend_front(value: T, element: E) -&gt; Self::Result nopanic</code></pre>
<h2 id="trait-types-42"><a class="header" href="#trait-types-42">Trait types</a></h2>
<h3 id="result-6"><a class="header" href="#result-6">Result</a></h3>
<p>The type of the resulting tuple.</p>
<p>Fully qualified path: <code>core::metaprogramming::TupleExtendFront::Result</code></p>
<pre><code class="language-rust">type Result;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuplesnapforward"><a class="header" href="#tuplesnapforward">TupleSnapForward</a></h1>
<p>A trait for forwarding a wrapping snapshot from a tuple style struct into a tuple style struct of the snapshots.</p>
<p>Fully qualified path: <code>core::metaprogramming::TupleSnapForward</code></p>
<pre><code class="language-rust">pub(crate) trait TupleSnapForward&lt;T&gt;</code></pre>
<h2 id="trait-functions-148"><a class="header" href="#trait-functions-148">Trait functions</a></h2>
<h3 id="snap_forward"><a class="header" href="#snap_forward">snap_forward</a></h3>
<p>Fully qualified path: <code>core::metaprogramming::TupleSnapForward::snap_forward</code></p>
<pre><code class="language-rust">fn snap_forward(self: @T) -&gt; Self::SnapForward nopanic</code></pre>
<h2 id="trait-types-43"><a class="header" href="#trait-types-43">Trait types</a></h2>
<h3 id="snapforward"><a class="header" href="#snapforward">SnapForward</a></h3>
<p>Fully qualified path: <code>core::metaprogramming::TupleSnapForward::SnapForward</code></p>
<pre><code class="language-rust">type SnapForward;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snapremove"><a class="header" href="#snapremove">SnapRemove</a></h1>
<p>A trait for removing a wrapping snapshot from the types in tuple style struct.</p>
<p>Fully qualified path: <code>core::metaprogramming::SnapRemove</code></p>
<pre><code class="language-rust">pub(crate) trait SnapRemove&lt;T&gt;</code></pre>
<h2 id="trait-types-44"><a class="header" href="#trait-types-44">Trait types</a></h2>
<h3 id="result-7"><a class="header" href="#result-7">Result</a></h3>
<p>Fully qualified path: <code>core::metaprogramming::SnapRemove::Result</code></p>
<pre><code class="language-rust">type Result;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<p>An iterator over a collection of values.</p>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator</code></p>
<pre><code class="language-rust">pub trait Iterator&lt;T&gt;</code></pre>
<h2 id="trait-functions-149"><a class="header" href="#trait-functions-149">Trait functions</a></h2>
<h3 id="next-1"><a class="header" href="#next-1">next</a></h3>
<p>Advance the iterator and return the next value.</p>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::next</code></p>
<pre><code class="language-rust">fn next(ref self: T) -&gt; Option&lt;Self::Item&gt;</code></pre>
<h2 id="trait-types-45"><a class="header" href="#trait-types-45">Trait types</a></h2>
<h3 id="item"><a class="header" href="#item">Item</a></h3>
<p>The type of the elements being iterated over.</p>
<p>Fully qualified path: <code>core::iter::traits::iterator::Iterator::Item</code></p>
<pre><code class="language-rust">type Item;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intoiterator"><a class="header" href="#intoiterator">IntoIterator</a></h1>
<p>Turn a collection of values into an iterator.</p>
<p>Fully qualified path: <code>core::iter::traits::iterator::IntoIterator</code></p>
<pre><code class="language-rust">pub trait IntoIterator&lt;T&gt;</code></pre>
<h2 id="trait-functions-150"><a class="header" href="#trait-functions-150">Trait functions</a></h2>
<h3 id="into_iter"><a class="header" href="#into_iter">into_iter</a></h3>
<p>Creates an iterator from a collection.</p>
<p>Fully qualified path: <code>core::iter::traits::iterator::IntoIterator::into_iter</code></p>
<pre><code class="language-rust">fn into_iter(self: T) -&gt; Self::IntoIter</code></pre>
<h2 id="trait-types-46"><a class="header" href="#trait-types-46">Trait types</a></h2>
<h3 id="intoiter"><a class="header" href="#intoiter">IntoIter</a></h3>
<p>The iterator type that will be created.</p>
<p>Fully qualified path: <code>core::iter::traits::iterator::IntoIterator::IntoIter</code></p>
<pre><code class="language-rust">type IntoIter;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impls-19"><a class="header" href="#impls-19">Impls</a></h1>
<ul>
<li>
<p><a href="./core-BoolSerde.html">BoolSerde</a></p>
</li>
<li>
<p><a href="./core-BoolBitAnd.html">BoolBitAnd</a></p>
</li>
<li>
<p><a href="./core-BoolBitOr.html">BoolBitOr</a></p>
</li>
<li>
<p><a href="./core-BoolNot.html">BoolNot</a></p>
</li>
<li>
<p><a href="./core-BoolBitXor.html">BoolBitXor</a></p>
</li>
<li>
<p><a href="./core-BoolPartialEq.html">BoolPartialEq</a></p>
</li>
<li>
<p><a href="./core-BoolFelt252DictValue.html">BoolFelt252DictValue</a></p>
</li>
<li>
<p><a href="./core-BoolIntoFelt252.html">BoolIntoFelt252</a></p>
</li>
<li>
<p><a href="./core-Felt252Serde.html">Felt252Serde</a></p>
</li>
<li>
<p><a href="./core-Felt252Add.html">Felt252Add</a></p>
</li>
<li>
<p><a href="./core-Felt252AddEq.html">Felt252AddEq</a></p>
</li>
<li>
<p><a href="./core-Felt252Sub.html">Felt252Sub</a></p>
</li>
<li>
<p><a href="./core-Felt252SubEq.html">Felt252SubEq</a></p>
</li>
<li>
<p><a href="./core-Felt252Mul.html">Felt252Mul</a></p>
</li>
<li>
<p><a href="./core-Felt252MulEq.html">Felt252MulEq</a></p>
</li>
<li>
<p><a href="./core-Felt252Neg.html">Felt252Neg</a></p>
</li>
<li>
<p><a href="./core-Felt252PartialEq.html">Felt252PartialEq</a></p>
</li>
<li>
<p><a href="./core-Felt252TryIntoNonZero.html">Felt252TryIntoNonZero</a></p>
</li>
<li>
<p><a href="./core-Felt252Default.html">Felt252Default</a></p>
</li>
<li>
<p><a href="./core-Felt252Felt252DictValue.html">Felt252Felt252DictValue</a></p>
</li>
<li>
<p><a href="./core-boolCopy.html">boolCopy</a></p>
</li>
<li>
<p><a href="./core-boolDrop.html">boolDrop</a></p>
</li>
<li>
<p><a href="./core-boolDefault.html">boolDefault</a></p>
</li>
<li>
<p><a href="./core-felt252Copy.html">felt252Copy</a></p>
</li>
<li>
<p><a href="./core-felt252Drop.html">felt252Drop</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitElementDrop.html">CircuitElementDrop</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitElementCopy.html">CircuitElementCopy</a></p>
</li>
<li>
<p><a href="./core-circuit-DestructFailureGuarantee.html">DestructFailureGuarantee</a></p>
</li>
<li>
<p><a href="./core-felt_252-Felt252Zero.html">Felt252Zero</a></p>
</li>
<li>
<p><a href="./core-felt_252-Felt252One.html">Felt252One</a></p>
</li>
<li>
<p><a href="./core-array-SpanIndex.html">SpanIndex</a></p>
</li>
<li>
<p><a href="./core-option-DestructOption.html">DestructOption</a></p>
</li>
<li>
<p><a href="./core-ec-EcStateImpl.html">EcStateImpl</a></p>
</li>
<li>
<p><a href="./core-ec-EcPointImpl.html">EcPointImpl</a></p>
</li>
<li>
<p><a href="./core-integer-U128TryIntoNonZero.html">U128TryIntoNonZero</a></p>
</li>
<li>
<p><a href="./core-integer-U32TryIntoNonZero.html">U32TryIntoNonZero</a></p>
</li>
<li>
<p><a href="./core-integer-U256TryIntoNonZero.html">U256TryIntoNonZero</a></p>
</li>
<li>
<p><a href="./core-integer-Felt252TryIntoU8.html">Felt252TryIntoU8</a></p>
</li>
<li>
<p><a href="./core-integer-U8IntoFelt252.html">U8IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-Felt252TryIntoU16.html">Felt252TryIntoU16</a></p>
</li>
<li>
<p><a href="./core-integer-U16IntoFelt252.html">U16IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-Felt252TryIntoU32.html">Felt252TryIntoU32</a></p>
</li>
<li>
<p><a href="./core-integer-U32IntoFelt252.html">U32IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-Felt252TryIntoU64.html">Felt252TryIntoU64</a></p>
</li>
<li>
<p><a href="./core-integer-U64IntoFelt252.html">U64IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-Felt252TryIntoU128.html">Felt252TryIntoU128</a></p>
</li>
<li>
<p><a href="./core-integer-U128IntoFelt252.html">U128IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-Felt252IntoU256.html">Felt252IntoU256</a></p>
</li>
<li>
<p><a href="./core-integer-U256TryIntoFelt252.html">U256TryIntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-I8IntoFelt252.html">I8IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-I16IntoFelt252.html">I16IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-I32IntoFelt252.html">I32IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-I64IntoFelt252.html">I64IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-integer-I128IntoFelt252.html">I128IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-pedersen-PedersenImpl.html">PedersenImpl</a></p>
</li>
<li>
<p><a href="./core-poseidon-PoseidonImpl.html">PoseidonImpl</a></p>
</li>
<li>
<p><a href="./core-debug-Felt252PrintImpl.html">Felt252PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-BoolPrintImpl.html">BoolPrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-ContractAddressPrintImpl.html">ContractAddressPrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-U8PrintImpl.html">U8PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-U16PrintImpl.html">U16PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-U32PrintImpl.html">U32PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-U64PrintImpl.html">U64PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-U128PrintImpl.html">U128PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-U256PrintImpl.html">U256PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-I8PrintImpl.html">I8PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-I16PrintImpl.html">I16PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-I32PrintImpl.html">I32PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-I64PrintImpl.html">I64PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-I128PrintImpl.html">I128PrintImpl</a></p>
</li>
<li>
<p><a href="./core-debug-ArrayGenericPrintImpl.html">ArrayGenericPrintImpl</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256k1-Secp256k1Impl.html">Secp256k1Impl</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256k1-Secp256k1PointImpl.html">Secp256k1PointImpl</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256r1-Secp256r1Impl.html">Secp256r1Impl</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256r1-Secp256r1PointImpl.html">Secp256r1PointImpl</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-Felt252TryIntoContractAddress.html">Felt252TryIntoContractAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-ContractAddressIntoFelt252.html">ContractAddressIntoFelt252</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-Felt252TryIntoEthAddress.html">Felt252TryIntoEthAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-EthAddressIntoFelt252.html">EthAddressIntoFelt252</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-U256IntoEthAddress.html">U256IntoEthAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-EthAddressSerde.html">EthAddressSerde</a></p>
</li>
<li>
<p><a href="./core-starknet-eth_address-EthAddressPrintImpl.html">EthAddressPrintImpl</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-Felt252TryIntoClassHash.html">Felt252TryIntoClassHash</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-ClassHashIntoFelt252.html">ClassHashIntoFelt252</a></p>
</li>
<li>
<p><a href="./core-starknet-storage-StorableStoragePointerReadAccess.html">StorableStoragePointerReadAccess</a></p>
</li>
<li>
<p><a href="./core-zeroable-NonZeroIntoImpl.html">NonZeroIntoImpl</a></p>
</li>
<li>
<p><a href="./core-bytes_31-Bytes31Impl.html">Bytes31Impl</a></p>
</li>
<li>
<p><a href="./core-bytes_31-Bytes31IndexView.html">Bytes31IndexView</a></p>
</li>
<li>
<p><a href="./core-bytes_31-Bytes31IntoFelt252.html">Bytes31IntoFelt252</a></p>
</li>
<li>
<p><a href="./core-bytes_31-Bytes31IntoU256.html">Bytes31IntoU256</a></p>
</li>
<li>
<p><a href="./core-bytes_31-Felt252TryIntoBytes31.html">Felt252TryIntoBytes31</a></p>
</li>
<li>
<p><a href="./core-bytes_31-U8IntoBytes31.html">U8IntoBytes31</a></p>
</li>
<li>
<p><a href="./core-bytes_31-U128IntoBytes31.html">U128IntoBytes31</a></p>
</li>
<li>
<p><a href="./core-byte_array-ByteArrayStringLiteral.html">ByteArrayStringLiteral</a></p>
</li>
<li>
<p><a href="./core-byte_array-ByteArrayImpl.html">ByteArrayImpl</a></p>
</li>
<li>
<p><a href="./core-byte_array-ByteArrayIndexView.html">ByteArrayIndexView</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolserde"><a class="header" href="#boolserde">BoolSerde</a></h1>
<p>Fully qualified path: <code>core::BoolSerde</code></p>
<pre><code class="language-rust">impl BoolSerde of Serde&lt;bool&gt;</code></pre>
<h2 id="impl-functions"><a class="header" href="#impl-functions">Impl functions</a></h2>
<h3 id="serialize-1"><a class="header" href="#serialize-1">serialize</a></h3>
<p>Fully qualified path: <code>core::BoolSerde::serialize</code></p>
<pre><code class="language-rust">fn serialize(self: @bool, ref output: Array&lt;felt252&gt;)</code></pre>
<h3 id="deserialize-3"><a class="header" href="#deserialize-3">deserialize</a></h3>
<p>Fully qualified path: <code>core::BoolSerde::deserialize</code></p>
<pre><code class="language-rust">fn deserialize(ref serialized: Span&lt;felt252&gt;) -&gt; Option&lt;bool&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolbitand"><a class="header" href="#boolbitand">BoolBitAnd</a></h1>
<p>Fully qualified path: <code>core::BoolBitAnd</code></p>
<pre><code class="language-rust">impl BoolBitAnd of BitAnd&lt;bool&gt;</code></pre>
<h2 id="impl-functions-1"><a class="header" href="#impl-functions-1">Impl functions</a></h2>
<h3 id="bitand-2"><a class="header" href="#bitand-2">bitand</a></h3>
<p>Fully qualified path: <code>core::BoolBitAnd::bitand</code></p>
<pre><code class="language-rust">fn bitand(lhs: bool, rhs: bool) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolbitor"><a class="header" href="#boolbitor">BoolBitOr</a></h1>
<p>Fully qualified path: <code>core::BoolBitOr</code></p>
<pre><code class="language-rust">impl BoolBitOr of BitOr&lt;bool&gt;</code></pre>
<h2 id="impl-functions-2"><a class="header" href="#impl-functions-2">Impl functions</a></h2>
<h3 id="bitor-2"><a class="header" href="#bitor-2">bitor</a></h3>
<p>Fully qualified path: <code>core::BoolBitOr::bitor</code></p>
<pre><code class="language-rust">fn bitor(lhs: bool, rhs: bool) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolnot"><a class="header" href="#boolnot">BoolNot</a></h1>
<p>Fully qualified path: <code>core::BoolNot</code></p>
<pre><code class="language-rust">impl BoolNot of Not&lt;bool&gt;</code></pre>
<h2 id="impl-functions-3"><a class="header" href="#impl-functions-3">Impl functions</a></h2>
<h3 id="not-2"><a class="header" href="#not-2">not</a></h3>
<p>Fully qualified path: <code>core::BoolNot::not</code></p>
<pre><code class="language-rust">fn not(a: bool) -&gt; bool implicits() nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolbitxor"><a class="header" href="#boolbitxor">BoolBitXor</a></h1>
<p>Fully qualified path: <code>core::BoolBitXor</code></p>
<pre><code class="language-rust">impl BoolBitXor of BitXor&lt;bool&gt;</code></pre>
<h2 id="impl-functions-4"><a class="header" href="#impl-functions-4">Impl functions</a></h2>
<h3 id="bitxor-2"><a class="header" href="#bitxor-2">bitxor</a></h3>
<p>Fully qualified path: <code>core::BoolBitXor::bitxor</code></p>
<pre><code class="language-rust">fn bitxor(lhs: bool, rhs: bool) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolpartialeq"><a class="header" href="#boolpartialeq">BoolPartialEq</a></h1>
<p>Fully qualified path: <code>core::BoolPartialEq</code></p>
<pre><code class="language-rust">impl BoolPartialEq of PartialEq&lt;bool&gt;</code></pre>
<h2 id="impl-functions-5"><a class="header" href="#impl-functions-5">Impl functions</a></h2>
<h3 id="eq-1"><a class="header" href="#eq-1">eq</a></h3>
<p>Fully qualified path: <code>core::BoolPartialEq::eq</code></p>
<pre><code class="language-rust">fn eq(lhs: @bool, rhs: @bool) -&gt; bool</code></pre>
<h3 id="ne-1"><a class="header" href="#ne-1">ne</a></h3>
<p>Fully qualified path: <code>core::BoolPartialEq::ne</code></p>
<pre><code class="language-rust">fn ne(lhs: @bool, rhs: @bool) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolfelt252dictvalue"><a class="header" href="#boolfelt252dictvalue">BoolFelt252DictValue</a></h1>
<p>Default values for felt252_dict values.</p>
<p>Fully qualified path: <code>core::BoolFelt252DictValue</code></p>
<pre><code class="language-rust">impl BoolFelt252DictValue of Felt252DictValue&lt;bool&gt;</code></pre>
<h2 id="impl-functions-6"><a class="header" href="#impl-functions-6">Impl functions</a></h2>
<h3 id="zero_default-1"><a class="header" href="#zero_default-1">zero_default</a></h3>
<p>Fully qualified path: <code>core::BoolFelt252DictValue::zero_default</code></p>
<pre><code class="language-rust">fn zero_default() -&gt; bool nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolintofelt252"><a class="header" href="#boolintofelt252">BoolIntoFelt252</a></h1>
<p>Fully qualified path: <code>core::BoolIntoFelt252</code></p>
<pre><code class="language-rust">impl BoolIntoFelt252 of Into&lt;bool, felt252&gt;</code></pre>
<h2 id="impl-functions-7"><a class="header" href="#impl-functions-7">Impl functions</a></h2>
<h3 id="into-2"><a class="header" href="#into-2">into</a></h3>
<p>Fully qualified path: <code>core::BoolIntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: bool) -&gt; felt252 implicits() nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252serde"><a class="header" href="#felt252serde">Felt252Serde</a></h1>
<p>Fully qualified path: <code>core::Felt252Serde</code></p>
<pre><code class="language-rust">impl Felt252Serde of Serde&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-8"><a class="header" href="#impl-functions-8">Impl functions</a></h2>
<h3 id="serialize-2"><a class="header" href="#serialize-2">serialize</a></h3>
<p>Fully qualified path: <code>core::Felt252Serde::serialize</code></p>
<pre><code class="language-rust">fn serialize(self: @felt252, ref output: Array&lt;felt252&gt;)</code></pre>
<h3 id="deserialize-4"><a class="header" href="#deserialize-4">deserialize</a></h3>
<p>Fully qualified path: <code>core::Felt252Serde::deserialize</code></p>
<pre><code class="language-rust">fn deserialize(ref serialized: Span&lt;felt252&gt;) -&gt; Option&lt;felt252&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252add"><a class="header" href="#felt252add">Felt252Add</a></h1>
<p>Fully qualified path: <code>core::Felt252Add</code></p>
<pre><code class="language-rust">impl Felt252Add of Add&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-9"><a class="header" href="#impl-functions-9">Impl functions</a></h2>
<h3 id="add-4"><a class="header" href="#add-4">add</a></h3>
<p>Fully qualified path: <code>core::Felt252Add::add</code></p>
<pre><code class="language-rust">fn add(lhs: felt252, rhs: felt252) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252addeq"><a class="header" href="#felt252addeq">Felt252AddEq</a></h1>
<p>Fully qualified path: <code>core::Felt252AddEq</code></p>
<pre><code class="language-rust">impl Felt252AddEq of AddEq&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-10"><a class="header" href="#impl-functions-10">Impl functions</a></h2>
<h3 id="add_eq-1"><a class="header" href="#add_eq-1">add_eq</a></h3>
<p>Fully qualified path: <code>core::Felt252AddEq::add_eq</code></p>
<pre><code class="language-rust">fn add_eq(ref self: felt252, other: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252sub"><a class="header" href="#felt252sub">Felt252Sub</a></h1>
<p>Fully qualified path: <code>core::Felt252Sub</code></p>
<pre><code class="language-rust">impl Felt252Sub of Sub&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-11"><a class="header" href="#impl-functions-11">Impl functions</a></h2>
<h3 id="sub-3"><a class="header" href="#sub-3">sub</a></h3>
<p>Fully qualified path: <code>core::Felt252Sub::sub</code></p>
<pre><code class="language-rust">fn sub(lhs: felt252, rhs: felt252) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252subeq"><a class="header" href="#felt252subeq">Felt252SubEq</a></h1>
<p>Fully qualified path: <code>core::Felt252SubEq</code></p>
<pre><code class="language-rust">impl Felt252SubEq of SubEq&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-12"><a class="header" href="#impl-functions-12">Impl functions</a></h2>
<h3 id="sub_eq-1"><a class="header" href="#sub_eq-1">sub_eq</a></h3>
<p>Fully qualified path: <code>core::Felt252SubEq::sub_eq</code></p>
<pre><code class="language-rust">fn sub_eq(ref self: felt252, other: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252mul"><a class="header" href="#felt252mul">Felt252Mul</a></h1>
<p>Fully qualified path: <code>core::Felt252Mul</code></p>
<pre><code class="language-rust">impl Felt252Mul of Mul&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-13"><a class="header" href="#impl-functions-13">Impl functions</a></h2>
<h3 id="mul-4"><a class="header" href="#mul-4">mul</a></h3>
<p>Fully qualified path: <code>core::Felt252Mul::mul</code></p>
<pre><code class="language-rust">fn mul(lhs: felt252, rhs: felt252) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252muleq"><a class="header" href="#felt252muleq">Felt252MulEq</a></h1>
<p>Fully qualified path: <code>core::Felt252MulEq</code></p>
<pre><code class="language-rust">impl Felt252MulEq of MulEq&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-14"><a class="header" href="#impl-functions-14">Impl functions</a></h2>
<h3 id="mul_eq-1"><a class="header" href="#mul_eq-1">mul_eq</a></h3>
<p>Fully qualified path: <code>core::Felt252MulEq::mul_eq</code></p>
<pre><code class="language-rust">fn mul_eq(ref self: felt252, other: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252neg"><a class="header" href="#felt252neg">Felt252Neg</a></h1>
<p>Fully qualified path: <code>core::Felt252Neg</code></p>
<pre><code class="language-rust">impl Felt252Neg of Neg&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-15"><a class="header" href="#impl-functions-15">Impl functions</a></h2>
<h3 id="neg-2"><a class="header" href="#neg-2">neg</a></h3>
<p>Fully qualified path: <code>core::Felt252Neg::neg</code></p>
<pre><code class="language-rust">fn neg(a: felt252) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252partialeq"><a class="header" href="#felt252partialeq">Felt252PartialEq</a></h1>
<p>Fully qualified path: <code>core::Felt252PartialEq</code></p>
<pre><code class="language-rust">impl Felt252PartialEq of PartialEq&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-16"><a class="header" href="#impl-functions-16">Impl functions</a></h2>
<h3 id="eq-2"><a class="header" href="#eq-2">eq</a></h3>
<p>Fully qualified path: <code>core::Felt252PartialEq::eq</code></p>
<pre><code class="language-rust">fn eq(lhs: @felt252, rhs: @felt252) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252tryintononzero"><a class="header" href="#felt252tryintononzero">Felt252TryIntoNonZero</a></h1>
<p>Fully qualified path: <code>core::Felt252TryIntoNonZero</code></p>
<pre><code class="language-rust">impl Felt252TryIntoNonZero of TryInto&lt;felt252, NonZero&lt;felt252&gt;&gt;</code></pre>
<h2 id="impl-functions-17"><a class="header" href="#impl-functions-17">Impl functions</a></h2>
<h3 id="try_into-1"><a class="header" href="#try_into-1">try_into</a></h3>
<p>Fully qualified path: <code>core::Felt252TryIntoNonZero::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: felt252) -&gt; Option&lt;NonZero&lt;felt252&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252default"><a class="header" href="#felt252default">Felt252Default</a></h1>
<p>Fully qualified path: <code>core::Felt252Default</code></p>
<pre><code class="language-rust">impl Felt252Default of Default&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-18"><a class="header" href="#impl-functions-18">Impl functions</a></h2>
<h3 id="default-2"><a class="header" href="#default-2">default</a></h3>
<p>Fully qualified path: <code>core::Felt252Default::default</code></p>
<pre><code class="language-rust">fn default() -&gt; felt252 nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252felt252dictvalue"><a class="header" href="#felt252felt252dictvalue">Felt252Felt252DictValue</a></h1>
<p>Fully qualified path: <code>core::Felt252Felt252DictValue</code></p>
<pre><code class="language-rust">impl Felt252Felt252DictValue of Felt252DictValue&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-19"><a class="header" href="#impl-functions-19">Impl functions</a></h2>
<h3 id="zero_default-2"><a class="header" href="#zero_default-2">zero_default</a></h3>
<p>Fully qualified path: <code>core::Felt252Felt252DictValue::zero_default</code></p>
<pre><code class="language-rust">fn zero_default() -&gt; felt252 nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolcopy"><a class="header" href="#boolcopy">boolCopy</a></h1>
<p>Fully qualified path: <code>core::boolCopy</code></p>
<pre><code class="language-rust">impl boolCopy of core::traits::Copy&lt;bool&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="booldrop"><a class="header" href="#booldrop">boolDrop</a></h1>
<p>Fully qualified path: <code>core::boolDrop</code></p>
<pre><code class="language-rust">impl boolDrop of core::traits::Drop&lt;bool&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="booldefault"><a class="header" href="#booldefault">boolDefault</a></h1>
<p>Fully qualified path: <code>core::boolDefault</code></p>
<pre><code class="language-rust">impl boolDefault of core::traits::Default&lt;bool&gt;</code></pre>
<h2 id="impl-functions-20"><a class="header" href="#impl-functions-20">Impl functions</a></h2>
<h3 id="default-3"><a class="header" href="#default-3">default</a></h3>
<p>Fully qualified path: <code>core::boolDefault::default</code></p>
<pre><code class="language-rust">fn default() -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252copy"><a class="header" href="#felt252copy">felt252Copy</a></h1>
<p>Fully qualified path: <code>core::felt252Copy</code></p>
<pre><code class="language-rust">impl felt252Copy of core::traits::Copy&lt;felt252&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252drop"><a class="header" href="#felt252drop">felt252Drop</a></h1>
<p>Fully qualified path: <code>core::felt252Drop</code></p>
<pre><code class="language-rust">impl felt252Drop of core::traits::Drop&lt;felt252&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitelementdrop"><a class="header" href="#circuitelementdrop">CircuitElementDrop</a></h1>
<p>Fully qualified path: <code>core::circuit::CircuitElementDrop</code></p>
<pre><code class="language-rust">pub impl CircuitElementDrop&lt;T&gt; of Drop&lt;CircuitElement&lt;T&gt;&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitelementcopy"><a class="header" href="#circuitelementcopy">CircuitElementCopy</a></h1>
<p>Fully qualified path: <code>core::circuit::CircuitElementCopy</code></p>
<pre><code class="language-rust">pub impl CircuitElementCopy&lt;T&gt; of Copy&lt;CircuitElement&lt;T&gt;&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructfailureguarantee"><a class="header" href="#destructfailureguarantee">DestructFailureGuarantee</a></h1>
<p>Fully qualified path: <code>core::circuit::DestructFailureGuarantee</code></p>
<pre><code class="language-rust">pub impl DestructFailureGuarantee of Destruct&lt;CircuitFailureGuarantee&gt;</code></pre>
<h2 id="impl-functions-21"><a class="header" href="#impl-functions-21">Impl functions</a></h2>
<h3 id="destruct-2"><a class="header" href="#destruct-2">destruct</a></h3>
<p>Fully qualified path: <code>core::circuit::DestructFailureGuarantee::destruct</code></p>
<pre><code class="language-rust">fn destruct(self: CircuitFailureGuarantee) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252zero"><a class="header" href="#felt252zero">Felt252Zero</a></h1>
<p>Fully qualified path: <code>core::felt_252::Felt252Zero</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252Zero of crate::num::traits::Zero&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-22"><a class="header" href="#impl-functions-22">Impl functions</a></h2>
<h3 id="zero-7"><a class="header" href="#zero-7">zero</a></h3>
<p>Fully qualified path: <code>core::felt_252::Felt252Zero::zero</code></p>
<pre><code class="language-rust">fn zero() -&gt; felt252</code></pre>
<h3 id="is_zero-3"><a class="header" href="#is_zero-3">is_zero</a></h3>
<p>Fully qualified path: <code>core::felt_252::Felt252Zero::is_zero</code></p>
<pre><code class="language-rust">fn is_zero(self: @felt252) -&gt; bool</code></pre>
<h3 id="is_non_zero-3"><a class="header" href="#is_non_zero-3">is_non_zero</a></h3>
<p>Fully qualified path: <code>core::felt_252::Felt252Zero::is_non_zero</code></p>
<pre><code class="language-rust">fn is_non_zero(self: @felt252) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252one"><a class="header" href="#felt252one">Felt252One</a></h1>
<p>Fully qualified path: <code>core::felt_252::Felt252One</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252One of crate::num::traits::One&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-23"><a class="header" href="#impl-functions-23">Impl functions</a></h2>
<h3 id="one-5"><a class="header" href="#one-5">one</a></h3>
<p>Fully qualified path: <code>core::felt_252::Felt252One::one</code></p>
<pre><code class="language-rust">fn one() -&gt; felt252</code></pre>
<h3 id="is_one-2"><a class="header" href="#is_one-2">is_one</a></h3>
<p>Fully qualified path: <code>core::felt_252::Felt252One::is_one</code></p>
<pre><code class="language-rust">fn is_one(self: @felt252) -&gt; bool</code></pre>
<h3 id="is_non_one-2"><a class="header" href="#is_non_one-2">is_non_one</a></h3>
<p>Fully qualified path: <code>core::felt_252::Felt252One::is_non_one</code></p>
<pre><code class="language-rust">fn is_non_one(self: @felt252) -&gt; bool</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spanindex"><a class="header" href="#spanindex">SpanIndex</a></h1>
<p>Fully qualified path: <code>core::array::SpanIndex</code></p>
<pre><code class="language-rust">pub impl SpanIndex&lt;T&gt; of IndexView&lt;Span&lt;T&gt;, usize, @T&gt;</code></pre>
<h2 id="impl-functions-24"><a class="header" href="#impl-functions-24">Impl functions</a></h2>
<h3 id="index-10"><a class="header" href="#index-10">index</a></h3>
<p>Returns a snapshot of the element at the given index.  # Examples</p>
<pre><code class="language-cairo">let span: @Span&lt;u8&gt; = @array![1, 2, 3].span();
let element: @u8 = span[0];
assert!(element == @1);
</code></pre>
<p>Fully qualified path: <code>core::array::SpanIndex::index</code></p>
<pre><code class="language-rust">fn index(self: @Span&lt;T&gt;, index: usize) -&gt; @T</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructoption"><a class="header" href="#destructoption">DestructOption</a></h1>
<p>Fully qualified path: <code>core::option::DestructOption</code></p>
<pre><code class="language-rust">pub impl DestructOption&lt;T, +Destruct&lt;T&gt;, -Drop&lt;Option&lt;T&gt;&gt;&gt; of Destruct&lt;Option&lt;T&gt;&gt;</code></pre>
<h2 id="impl-functions-25"><a class="header" href="#impl-functions-25">Impl functions</a></h2>
<h3 id="destruct-3"><a class="header" href="#destruct-3">destruct</a></h3>
<p>Fully qualified path: <code>core::option::DestructOption::destruct</code></p>
<pre><code class="language-rust">fn destruct(self: Option&lt;T&gt;) nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecstateimpl"><a class="header" href="#ecstateimpl">EcStateImpl</a></h1>
<p>Fully qualified path: <code>core::ec::EcStateImpl</code></p>
<pre><code class="language-rust">pub impl EcStateImpl of EcStateTrait</code></pre>
<h2 id="impl-functions-26"><a class="header" href="#impl-functions-26">Impl functions</a></h2>
<h3 id="init-1"><a class="header" href="#init-1">init</a></h3>
<p>Initializes an EC computation with the zero point.</p>
<p>Fully qualified path: <code>core::ec::EcStateImpl::init</code></p>
<pre><code class="language-rust">fn init() -&gt; EcState nopanic</code></pre>
<h3 id="add-5"><a class="header" href="#add-5">add</a></h3>
<p>Adds a point to the computation.</p>
<p>Fully qualified path: <code>core::ec::EcStateImpl::add</code></p>
<pre><code class="language-rust">fn add(ref self: EcState, p: NonZeroEcPoint) nopanic</code></pre>
<h3 id="sub-4"><a class="header" href="#sub-4">sub</a></h3>
<p>Subs a point to the computation.</p>
<p>Fully qualified path: <code>core::ec::EcStateImpl::sub</code></p>
<pre><code class="language-rust">fn sub(ref self: EcState, p: NonZeroEcPoint)</code></pre>
<h3 id="add_mul-1"><a class="header" href="#add_mul-1">add_mul</a></h3>
<p>Adds the product p * scalar to the state.</p>
<p>Fully qualified path: <code>core::ec::EcStateImpl::add_mul</code></p>
<pre><code class="language-rust">fn add_mul(ref self: EcState, scalar: felt252, p: NonZeroEcPoint) nopanic</code></pre>
<h3 id="finalize_nz-1"><a class="header" href="#finalize_nz-1">finalize_nz</a></h3>
<p>Finalizes the EC computation and returns the result (returns <code>None</code> if the result is the zero point).</p>
<p>Fully qualified path: <code>core::ec::EcStateImpl::finalize_nz</code></p>
<pre><code class="language-rust">fn finalize_nz(self: EcState) -&gt; Option&lt;NonZeroEcPoint&gt; nopanic</code></pre>
<h3 id="finalize-3"><a class="header" href="#finalize-3">finalize</a></h3>
<p>Finalizes the EC computation and returns the result.</p>
<p>Fully qualified path: <code>core::ec::EcStateImpl::finalize</code></p>
<pre><code class="language-rust">fn finalize(self: EcState) -&gt; EcPoint</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecpointimpl"><a class="header" href="#ecpointimpl">EcPointImpl</a></h1>
<p>Fully qualified path: <code>core::ec::EcPointImpl</code></p>
<pre><code class="language-rust">pub impl EcPointImpl of EcPointTrait</code></pre>
<h2 id="impl-functions-27"><a class="header" href="#impl-functions-27">Impl functions</a></h2>
<h3 id="new-7"><a class="header" href="#new-7">new</a></h3>
<p>Creates a new EC point from its (x, y) coordinates.</p>
<p>Fully qualified path: <code>core::ec::EcPointImpl::new</code></p>
<pre><code class="language-rust">fn new(x: felt252, y: felt252) -&gt; Option&lt;EcPoint&gt;</code></pre>
<h3 id="new_nz-1"><a class="header" href="#new_nz-1">new_nz</a></h3>
<p>Creates a new NonZero EC point from its (x, y) coordinates.</p>
<p>Fully qualified path: <code>core::ec::EcPointImpl::new_nz</code></p>
<pre><code class="language-rust">fn new_nz(x: felt252, y: felt252) -&gt; Option&lt;NonZeroEcPoint&gt;</code></pre>
<h3 id="new_from_x-1"><a class="header" href="#new_from_x-1">new_from_x</a></h3>
<p>Creates a new EC point from its x coordinate.</p>
<p>Fully qualified path: <code>core::ec::EcPointImpl::new_from_x</code></p>
<pre><code class="language-rust">fn new_from_x(x: felt252) -&gt; Option&lt;EcPoint&gt;</code></pre>
<h3 id="new_nz_from_x-1"><a class="header" href="#new_nz_from_x-1">new_nz_from_x</a></h3>
<p>Creates a new NonZero EC point from its x coordinate.</p>
<p>Fully qualified path: <code>core::ec::EcPointImpl::new_nz_from_x</code></p>
<pre><code class="language-rust">fn new_nz_from_x(x: felt252) -&gt; Option&lt;NonZeroEcPoint&gt;</code></pre>
<h3 id="coordinates-1"><a class="header" href="#coordinates-1">coordinates</a></h3>
<p>Returns the coordinates of the EC point.</p>
<p>Fully qualified path: <code>core::ec::EcPointImpl::coordinates</code></p>
<pre><code class="language-rust">fn coordinates(self: NonZeroEcPoint) -&gt; (felt252, felt252)</code></pre>
<h3 id="x-1"><a class="header" href="#x-1">x</a></h3>
<p>Returns the x coordinate of the EC point.</p>
<p>Fully qualified path: <code>core::ec::EcPointImpl::x</code></p>
<pre><code class="language-rust">fn x(self: NonZeroEcPoint) -&gt; felt252</code></pre>
<h3 id="y-1"><a class="header" href="#y-1">y</a></h3>
<p>Returns the y coordinate of the EC point.</p>
<p>Fully qualified path: <code>core::ec::EcPointImpl::y</code></p>
<pre><code class="language-rust">fn y(self: NonZeroEcPoint) -&gt; felt252</code></pre>
<h3 id="mul-5"><a class="header" href="#mul-5">mul</a></h3>
<p>Computes the product of an EC point <code>p</code> by the given scalar <code>scalar</code>.</p>
<p>Fully qualified path: <code>core::ec::EcPointImpl::mul</code></p>
<pre><code class="language-rust">fn mul(self: EcPoint, scalar: felt252) -&gt; EcPoint</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128tryintononzero"><a class="header" href="#u128tryintononzero">U128TryIntoNonZero</a></h1>
<p>Fully qualified path: <code>core::integer::U128TryIntoNonZero</code></p>
<pre><code class="language-rust">pub(crate) impl U128TryIntoNonZero of TryInto&lt;u128, NonZero&lt;u128&gt;&gt;</code></pre>
<h2 id="impl-functions-28"><a class="header" href="#impl-functions-28">Impl functions</a></h2>
<h3 id="try_into-2"><a class="header" href="#try_into-2">try_into</a></h3>
<p>Fully qualified path: <code>core::integer::U128TryIntoNonZero::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: u128) -&gt; Option&lt;NonZero&lt;u128&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32tryintononzero"><a class="header" href="#u32tryintononzero">U32TryIntoNonZero</a></h1>
<p>Fully qualified path: <code>core::integer::U32TryIntoNonZero</code></p>
<pre><code class="language-rust">pub(crate) impl U32TryIntoNonZero of TryInto&lt;u32, NonZero&lt;u32&gt;&gt;</code></pre>
<h2 id="impl-functions-29"><a class="header" href="#impl-functions-29">Impl functions</a></h2>
<h3 id="try_into-3"><a class="header" href="#try_into-3">try_into</a></h3>
<p>Fully qualified path: <code>core::integer::U32TryIntoNonZero::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: u32) -&gt; Option&lt;NonZero&lt;u32&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256tryintononzero"><a class="header" href="#u256tryintononzero">U256TryIntoNonZero</a></h1>
<p>Fully qualified path: <code>core::integer::U256TryIntoNonZero</code></p>
<pre><code class="language-rust">pub(crate) impl U256TryIntoNonZero of TryInto&lt;u256, NonZero&lt;u256&gt;&gt;</code></pre>
<h2 id="impl-functions-30"><a class="header" href="#impl-functions-30">Impl functions</a></h2>
<h3 id="try_into-4"><a class="header" href="#try_into-4">try_into</a></h3>
<p>Fully qualified path: <code>core::integer::U256TryIntoNonZero::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: u256) -&gt; Option&lt;NonZero&lt;u256&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252tryintou8"><a class="header" href="#felt252tryintou8">Felt252TryIntoU8</a></h1>
<p>Conversions.</p>
<p>Fully qualified path: <code>core::integer::Felt252TryIntoU8</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252TryIntoU8 of TryInto&lt;felt252, u8&gt;</code></pre>
<h2 id="impl-functions-31"><a class="header" href="#impl-functions-31">Impl functions</a></h2>
<h3 id="try_into-5"><a class="header" href="#try_into-5">try_into</a></h3>
<p>Fully qualified path: <code>core::integer::Felt252TryIntoU8::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: felt252) -&gt; Option&lt;u8&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8intofelt252"><a class="header" href="#u8intofelt252">U8IntoFelt252</a></h1>
<p>Fully qualified path: <code>core::integer::U8IntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl U8IntoFelt252 of Into&lt;u8, felt252&gt;</code></pre>
<h2 id="impl-functions-32"><a class="header" href="#impl-functions-32">Impl functions</a></h2>
<h3 id="into-3"><a class="header" href="#into-3">into</a></h3>
<p>Fully qualified path: <code>core::integer::U8IntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: u8) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252tryintou16"><a class="header" href="#felt252tryintou16">Felt252TryIntoU16</a></h1>
<p>Fully qualified path: <code>core::integer::Felt252TryIntoU16</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252TryIntoU16 of TryInto&lt;felt252, u16&gt;</code></pre>
<h2 id="impl-functions-33"><a class="header" href="#impl-functions-33">Impl functions</a></h2>
<h3 id="try_into-6"><a class="header" href="#try_into-6">try_into</a></h3>
<p>Fully qualified path: <code>core::integer::Felt252TryIntoU16::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: felt252) -&gt; Option&lt;u16&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16intofelt252"><a class="header" href="#u16intofelt252">U16IntoFelt252</a></h1>
<p>Fully qualified path: <code>core::integer::U16IntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl U16IntoFelt252 of Into&lt;u16, felt252&gt;</code></pre>
<h2 id="impl-functions-34"><a class="header" href="#impl-functions-34">Impl functions</a></h2>
<h3 id="into-4"><a class="header" href="#into-4">into</a></h3>
<p>Fully qualified path: <code>core::integer::U16IntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: u16) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252tryintou32"><a class="header" href="#felt252tryintou32">Felt252TryIntoU32</a></h1>
<p>Fully qualified path: <code>core::integer::Felt252TryIntoU32</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252TryIntoU32 of TryInto&lt;felt252, u32&gt;</code></pre>
<h2 id="impl-functions-35"><a class="header" href="#impl-functions-35">Impl functions</a></h2>
<h3 id="try_into-7"><a class="header" href="#try_into-7">try_into</a></h3>
<p>Fully qualified path: <code>core::integer::Felt252TryIntoU32::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: felt252) -&gt; Option&lt;u32&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32intofelt252"><a class="header" href="#u32intofelt252">U32IntoFelt252</a></h1>
<p>Fully qualified path: <code>core::integer::U32IntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl U32IntoFelt252 of Into&lt;u32, felt252&gt;</code></pre>
<h2 id="impl-functions-36"><a class="header" href="#impl-functions-36">Impl functions</a></h2>
<h3 id="into-5"><a class="header" href="#into-5">into</a></h3>
<p>Fully qualified path: <code>core::integer::U32IntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: u32) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252tryintou64"><a class="header" href="#felt252tryintou64">Felt252TryIntoU64</a></h1>
<p>Fully qualified path: <code>core::integer::Felt252TryIntoU64</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252TryIntoU64 of TryInto&lt;felt252, u64&gt;</code></pre>
<h2 id="impl-functions-37"><a class="header" href="#impl-functions-37">Impl functions</a></h2>
<h3 id="try_into-8"><a class="header" href="#try_into-8">try_into</a></h3>
<p>Fully qualified path: <code>core::integer::Felt252TryIntoU64::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: felt252) -&gt; Option&lt;u64&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64intofelt252"><a class="header" href="#u64intofelt252">U64IntoFelt252</a></h1>
<p>Fully qualified path: <code>core::integer::U64IntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl U64IntoFelt252 of Into&lt;u64, felt252&gt;</code></pre>
<h2 id="impl-functions-38"><a class="header" href="#impl-functions-38">Impl functions</a></h2>
<h3 id="into-6"><a class="header" href="#into-6">into</a></h3>
<p>Fully qualified path: <code>core::integer::U64IntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: u64) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252tryintou128"><a class="header" href="#felt252tryintou128">Felt252TryIntoU128</a></h1>
<p>Fully qualified path: <code>core::integer::Felt252TryIntoU128</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252TryIntoU128 of TryInto&lt;felt252, u128&gt;</code></pre>
<h2 id="impl-functions-39"><a class="header" href="#impl-functions-39">Impl functions</a></h2>
<h3 id="try_into-9"><a class="header" href="#try_into-9">try_into</a></h3>
<p>Fully qualified path: <code>core::integer::Felt252TryIntoU128::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: felt252) -&gt; Option&lt;u128&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128intofelt252"><a class="header" href="#u128intofelt252">U128IntoFelt252</a></h1>
<p>Fully qualified path: <code>core::integer::U128IntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl U128IntoFelt252 of Into&lt;u128, felt252&gt;</code></pre>
<h2 id="impl-functions-40"><a class="header" href="#impl-functions-40">Impl functions</a></h2>
<h3 id="into-7"><a class="header" href="#into-7">into</a></h3>
<p>Fully qualified path: <code>core::integer::U128IntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: u128) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252intou256"><a class="header" href="#felt252intou256">Felt252IntoU256</a></h1>
<p>Fully qualified path: <code>core::integer::Felt252IntoU256</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252IntoU256 of Into&lt;felt252, u256&gt;</code></pre>
<h2 id="impl-functions-41"><a class="header" href="#impl-functions-41">Impl functions</a></h2>
<h3 id="into-8"><a class="header" href="#into-8">into</a></h3>
<p>Fully qualified path: <code>core::integer::Felt252IntoU256::into</code></p>
<pre><code class="language-rust">fn into(self: felt252) -&gt; u256</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256tryintofelt252"><a class="header" href="#u256tryintofelt252">U256TryIntoFelt252</a></h1>
<p>Fully qualified path: <code>core::integer::U256TryIntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl U256TryIntoFelt252 of TryInto&lt;u256, felt252&gt;</code></pre>
<h2 id="impl-functions-42"><a class="header" href="#impl-functions-42">Impl functions</a></h2>
<h3 id="try_into-10"><a class="header" href="#try_into-10">try_into</a></h3>
<p>Fully qualified path: <code>core::integer::U256TryIntoFelt252::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: u256) -&gt; Option&lt;felt252&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i8intofelt252"><a class="header" href="#i8intofelt252">I8IntoFelt252</a></h1>
<p>Fully qualified path: <code>core::integer::I8IntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl I8IntoFelt252 of Into&lt;i8, felt252&gt;</code></pre>
<h2 id="impl-functions-43"><a class="header" href="#impl-functions-43">Impl functions</a></h2>
<h3 id="into-9"><a class="header" href="#into-9">into</a></h3>
<p>Fully qualified path: <code>core::integer::I8IntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: i8) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i16intofelt252"><a class="header" href="#i16intofelt252">I16IntoFelt252</a></h1>
<p>Fully qualified path: <code>core::integer::I16IntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl I16IntoFelt252 of Into&lt;i16, felt252&gt;</code></pre>
<h2 id="impl-functions-44"><a class="header" href="#impl-functions-44">Impl functions</a></h2>
<h3 id="into-10"><a class="header" href="#into-10">into</a></h3>
<p>Fully qualified path: <code>core::integer::I16IntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: i16) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i32intofelt252"><a class="header" href="#i32intofelt252">I32IntoFelt252</a></h1>
<p>Fully qualified path: <code>core::integer::I32IntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl I32IntoFelt252 of Into&lt;i32, felt252&gt;</code></pre>
<h2 id="impl-functions-45"><a class="header" href="#impl-functions-45">Impl functions</a></h2>
<h3 id="into-11"><a class="header" href="#into-11">into</a></h3>
<p>Fully qualified path: <code>core::integer::I32IntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: i32) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i64intofelt252"><a class="header" href="#i64intofelt252">I64IntoFelt252</a></h1>
<p>Fully qualified path: <code>core::integer::I64IntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl I64IntoFelt252 of Into&lt;i64, felt252&gt;</code></pre>
<h2 id="impl-functions-46"><a class="header" href="#impl-functions-46">Impl functions</a></h2>
<h3 id="into-12"><a class="header" href="#into-12">into</a></h3>
<p>Fully qualified path: <code>core::integer::I64IntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: i64) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i128intofelt252"><a class="header" href="#i128intofelt252">I128IntoFelt252</a></h1>
<p>Fully qualified path: <code>core::integer::I128IntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl I128IntoFelt252 of Into&lt;i128, felt252&gt;</code></pre>
<h2 id="impl-functions-47"><a class="header" href="#impl-functions-47">Impl functions</a></h2>
<h3 id="into-13"><a class="header" href="#into-13">into</a></h3>
<p>Fully qualified path: <code>core::integer::I128IntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: i128) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersenimpl"><a class="header" href="#pedersenimpl">PedersenImpl</a></h1>
<p>A trait for creating a new Pedersen hash state.</p>
<p>Fully qualified path: <code>core::pedersen::PedersenImpl</code></p>
<pre><code class="language-rust">pub impl PedersenImpl of PedersenTrait</code></pre>
<h2 id="impl-functions-48"><a class="header" href="#impl-functions-48">Impl functions</a></h2>
<h3 id="new-8"><a class="header" href="#new-8">new</a></h3>
<p>Creates a new Pedersen hash state with the given base value.  # Examples</p>
<pre><code class="language-cairo">use core::pedersen::PedersenTrait;

let mut state = PedersenTrait::new(0);
assert!(state.state == 0);
</code></pre>
<p>Fully qualified path: <code>core::pedersen::PedersenImpl::new</code></p>
<pre><code class="language-rust">fn new(base: felt252) -&gt; HashState</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidonimpl"><a class="header" href="#poseidonimpl">PoseidonImpl</a></h1>
<p>A trait for creating a new Poseidon hash state.</p>
<p>Fully qualified path: <code>core::poseidon::PoseidonImpl</code></p>
<pre><code class="language-rust">pub impl PoseidonImpl of PoseidonTrait</code></pre>
<h2 id="impl-functions-49"><a class="header" href="#impl-functions-49">Impl functions</a></h2>
<h3 id="new-9"><a class="header" href="#new-9">new</a></h3>
<p>Creates an initial state with all fields set to 0.  # Examples</p>
<pre><code class="language-cairo">use core::poseidon::PoseidonTrait;

let mut state = PoseidonTrait::new();
</code></pre>
<p>Fully qualified path: <code>core::poseidon::PoseidonImpl::new</code></p>
<pre><code class="language-rust">fn new() -&gt; HashState</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252printimpl"><a class="header" href="#felt252printimpl">Felt252PrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::Felt252PrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252PrintImpl of PrintTrait&lt;felt252&gt;</code></pre>
<h2 id="impl-functions-50"><a class="header" href="#impl-functions-50">Impl functions</a></h2>
<h3 id="print-1"><a class="header" href="#print-1">print</a></h3>
<p>Fully qualified path: <code>core::debug::Felt252PrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolprintimpl"><a class="header" href="#boolprintimpl">BoolPrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::BoolPrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl BoolPrintImpl of PrintTrait&lt;bool&gt;</code></pre>
<h2 id="impl-functions-51"><a class="header" href="#impl-functions-51">Impl functions</a></h2>
<h3 id="print-2"><a class="header" href="#print-2">print</a></h3>
<p>Fully qualified path: <code>core::debug::BoolPrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: bool)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contractaddressprintimpl"><a class="header" href="#contractaddressprintimpl">ContractAddressPrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::ContractAddressPrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl ContractAddressPrintImpl of PrintTrait&lt;starknet::ContractAddress&gt;</code></pre>
<h2 id="impl-functions-52"><a class="header" href="#impl-functions-52">Impl functions</a></h2>
<h3 id="print-3"><a class="header" href="#print-3">print</a></h3>
<p>Fully qualified path: <code>core::debug::ContractAddressPrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: starknet::ContractAddress)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8printimpl"><a class="header" href="#u8printimpl">U8PrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::U8PrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl U8PrintImpl of PrintTrait&lt;u8&gt;</code></pre>
<h2 id="impl-functions-53"><a class="header" href="#impl-functions-53">Impl functions</a></h2>
<h3 id="print-4"><a class="header" href="#print-4">print</a></h3>
<p>Fully qualified path: <code>core::debug::U8PrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: u8)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16printimpl"><a class="header" href="#u16printimpl">U16PrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::U16PrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl U16PrintImpl of PrintTrait&lt;u16&gt;</code></pre>
<h2 id="impl-functions-54"><a class="header" href="#impl-functions-54">Impl functions</a></h2>
<h3 id="print-5"><a class="header" href="#print-5">print</a></h3>
<p>Fully qualified path: <code>core::debug::U16PrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: u16)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32printimpl"><a class="header" href="#u32printimpl">U32PrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::U32PrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl U32PrintImpl of PrintTrait&lt;u32&gt;</code></pre>
<h2 id="impl-functions-55"><a class="header" href="#impl-functions-55">Impl functions</a></h2>
<h3 id="print-6"><a class="header" href="#print-6">print</a></h3>
<p>Fully qualified path: <code>core::debug::U32PrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: u32)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64printimpl"><a class="header" href="#u64printimpl">U64PrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::U64PrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl U64PrintImpl of PrintTrait&lt;u64&gt;</code></pre>
<h2 id="impl-functions-56"><a class="header" href="#impl-functions-56">Impl functions</a></h2>
<h3 id="print-7"><a class="header" href="#print-7">print</a></h3>
<p>Fully qualified path: <code>core::debug::U64PrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: u64)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128printimpl"><a class="header" href="#u128printimpl">U128PrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::U128PrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl U128PrintImpl of PrintTrait&lt;u128&gt;</code></pre>
<h2 id="impl-functions-57"><a class="header" href="#impl-functions-57">Impl functions</a></h2>
<h3 id="print-8"><a class="header" href="#print-8">print</a></h3>
<p>Fully qualified path: <code>core::debug::U128PrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: u128)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256printimpl"><a class="header" href="#u256printimpl">U256PrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::U256PrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl U256PrintImpl of PrintTrait&lt;u256&gt;</code></pre>
<h2 id="impl-functions-58"><a class="header" href="#impl-functions-58">Impl functions</a></h2>
<h3 id="print-9"><a class="header" href="#print-9">print</a></h3>
<p>Fully qualified path: <code>core::debug::U256PrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: u256)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i8printimpl"><a class="header" href="#i8printimpl">I8PrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::I8PrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl I8PrintImpl of PrintTrait&lt;i8&gt;</code></pre>
<h2 id="impl-functions-59"><a class="header" href="#impl-functions-59">Impl functions</a></h2>
<h3 id="print-10"><a class="header" href="#print-10">print</a></h3>
<p>Fully qualified path: <code>core::debug::I8PrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: i8)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i16printimpl"><a class="header" href="#i16printimpl">I16PrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::I16PrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl I16PrintImpl of PrintTrait&lt;i16&gt;</code></pre>
<h2 id="impl-functions-60"><a class="header" href="#impl-functions-60">Impl functions</a></h2>
<h3 id="print-11"><a class="header" href="#print-11">print</a></h3>
<p>Fully qualified path: <code>core::debug::I16PrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: i16)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i32printimpl"><a class="header" href="#i32printimpl">I32PrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::I32PrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl I32PrintImpl of PrintTrait&lt;i32&gt;</code></pre>
<h2 id="impl-functions-61"><a class="header" href="#impl-functions-61">Impl functions</a></h2>
<h3 id="print-12"><a class="header" href="#print-12">print</a></h3>
<p>Fully qualified path: <code>core::debug::I32PrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: i32)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i64printimpl"><a class="header" href="#i64printimpl">I64PrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::I64PrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl I64PrintImpl of PrintTrait&lt;i64&gt;</code></pre>
<h2 id="impl-functions-62"><a class="header" href="#impl-functions-62">Impl functions</a></h2>
<h3 id="print-13"><a class="header" href="#print-13">print</a></h3>
<p>Fully qualified path: <code>core::debug::I64PrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: i64)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i128printimpl"><a class="header" href="#i128printimpl">I128PrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::I128PrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl I128PrintImpl of PrintTrait&lt;i128&gt;</code></pre>
<h2 id="impl-functions-63"><a class="header" href="#impl-functions-63">Impl functions</a></h2>
<h3 id="print-14"><a class="header" href="#print-14">print</a></h3>
<p>Fully qualified path: <code>core::debug::I128PrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: i128)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arraygenericprintimpl"><a class="header" href="#arraygenericprintimpl">ArrayGenericPrintImpl</a></h1>
<p>Fully qualified path: <code>core::debug::ArrayGenericPrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl ArrayGenericPrintImpl of PrintTrait&lt;Array&lt;felt252&gt;&gt;</code></pre>
<h2 id="impl-functions-64"><a class="header" href="#impl-functions-64">Impl functions</a></h2>
<h3 id="print-15"><a class="header" href="#print-15">print</a></h3>
<p>Fully qualified path: <code>core::debug::ArrayGenericPrintImpl::print</code></p>
<pre><code class="language-rust">fn print(mut self: Array&lt;felt252&gt;)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256k1impl"><a class="header" href="#secp256k1impl">Secp256k1Impl</a></h1>
<p>Fully qualified path: <code>core::starknet::secp256k1::Secp256k1Impl</code></p>
<pre><code class="language-rust">pub(crate) impl Secp256k1Impl of Secp256Trait&lt;Secp256k1Point&gt;</code></pre>
<h2 id="impl-functions-65"><a class="header" href="#impl-functions-65">Impl functions</a></h2>
<h3 id="get_curve_size-1"><a class="header" href="#get_curve_size-1">get_curve_size</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256k1::Secp256k1Impl::get_curve_size</code></p>
<pre><code class="language-rust">fn get_curve_size() -&gt; u256</code></pre>
<h3 id="get_generator_point-1"><a class="header" href="#get_generator_point-1">get_generator_point</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256k1::Secp256k1Impl::get_generator_point</code></p>
<pre><code class="language-rust">fn get_generator_point() -&gt; Secp256k1Point</code></pre>
<h3 id="secp256_ec_new_syscall-1"><a class="header" href="#secp256_ec_new_syscall-1">secp256_ec_new_syscall</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256k1::Secp256k1Impl::secp256_ec_new_syscall</code></p>
<pre><code class="language-rust">fn secp256_ec_new_syscall(x: u256, y: u256) -&gt; SyscallResult&lt;Option&lt;Secp256k1Point&gt;&gt;</code></pre>
<h3 id="secp256_ec_get_point_from_x_syscall-1"><a class="header" href="#secp256_ec_get_point_from_x_syscall-1">secp256_ec_get_point_from_x_syscall</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256k1::Secp256k1Impl::secp256_ec_get_point_from_x_syscall</code></p>
<pre><code class="language-rust">fn secp256_ec_get_point_from_x_syscall(
    x: u256, y_parity: bool,
) -&gt; SyscallResult&lt;Option&lt;Secp256k1Point&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256k1pointimpl"><a class="header" href="#secp256k1pointimpl">Secp256k1PointImpl</a></h1>
<p>Fully qualified path: <code>core::starknet::secp256k1::Secp256k1PointImpl</code></p>
<pre><code class="language-rust">pub(crate) impl Secp256k1PointImpl of Secp256PointTrait&lt;Secp256k1Point&gt;</code></pre>
<h2 id="impl-functions-66"><a class="header" href="#impl-functions-66">Impl functions</a></h2>
<h3 id="get_coordinates-1"><a class="header" href="#get_coordinates-1">get_coordinates</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256k1::Secp256k1PointImpl::get_coordinates</code></p>
<pre><code class="language-rust">fn get_coordinates(self: Secp256k1Point) -&gt; SyscallResult&lt;(u256, u256)&gt;</code></pre>
<h3 id="add-6"><a class="header" href="#add-6">add</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256k1::Secp256k1PointImpl::add</code></p>
<pre><code class="language-rust">fn add(self: Secp256k1Point, other: Secp256k1Point) -&gt; SyscallResult&lt;Secp256k1Point&gt;</code></pre>
<h3 id="mul-6"><a class="header" href="#mul-6">mul</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256k1::Secp256k1PointImpl::mul</code></p>
<pre><code class="language-rust">fn mul(self: Secp256k1Point, scalar: u256) -&gt; SyscallResult&lt;Secp256k1Point&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256r1impl"><a class="header" href="#secp256r1impl">Secp256r1Impl</a></h1>
<p>Fully qualified path: <code>core::starknet::secp256r1::Secp256r1Impl</code></p>
<pre><code class="language-rust">pub(crate) impl Secp256r1Impl of Secp256Trait&lt;Secp256r1Point&gt;</code></pre>
<h2 id="impl-functions-67"><a class="header" href="#impl-functions-67">Impl functions</a></h2>
<h3 id="get_curve_size-2"><a class="header" href="#get_curve_size-2">get_curve_size</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256r1::Secp256r1Impl::get_curve_size</code></p>
<pre><code class="language-rust">fn get_curve_size() -&gt; u256</code></pre>
<h3 id="get_generator_point-2"><a class="header" href="#get_generator_point-2">get_generator_point</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256r1::Secp256r1Impl::get_generator_point</code></p>
<pre><code class="language-rust">fn get_generator_point() -&gt; Secp256r1Point</code></pre>
<h3 id="secp256_ec_new_syscall-2"><a class="header" href="#secp256_ec_new_syscall-2">secp256_ec_new_syscall</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256r1::Secp256r1Impl::secp256_ec_new_syscall</code></p>
<pre><code class="language-rust">fn secp256_ec_new_syscall(x: u256, y: u256) -&gt; SyscallResult&lt;Option&lt;Secp256r1Point&gt;&gt;</code></pre>
<h3 id="secp256_ec_get_point_from_x_syscall-2"><a class="header" href="#secp256_ec_get_point_from_x_syscall-2">secp256_ec_get_point_from_x_syscall</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256r1::Secp256r1Impl::secp256_ec_get_point_from_x_syscall</code></p>
<pre><code class="language-rust">fn secp256_ec_get_point_from_x_syscall(
    x: u256, y_parity: bool,
) -&gt; SyscallResult&lt;Option&lt;Secp256r1Point&gt;&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256r1pointimpl"><a class="header" href="#secp256r1pointimpl">Secp256r1PointImpl</a></h1>
<p>Fully qualified path: <code>core::starknet::secp256r1::Secp256r1PointImpl</code></p>
<pre><code class="language-rust">pub(crate) impl Secp256r1PointImpl of Secp256PointTrait&lt;Secp256r1Point&gt;</code></pre>
<h2 id="impl-functions-68"><a class="header" href="#impl-functions-68">Impl functions</a></h2>
<h3 id="get_coordinates-2"><a class="header" href="#get_coordinates-2">get_coordinates</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256r1::Secp256r1PointImpl::get_coordinates</code></p>
<pre><code class="language-rust">fn get_coordinates(self: Secp256r1Point) -&gt; SyscallResult&lt;(u256, u256)&gt;</code></pre>
<h3 id="add-7"><a class="header" href="#add-7">add</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256r1::Secp256r1PointImpl::add</code></p>
<pre><code class="language-rust">fn add(self: Secp256r1Point, other: Secp256r1Point) -&gt; SyscallResult&lt;Secp256r1Point&gt;</code></pre>
<h3 id="mul-7"><a class="header" href="#mul-7">mul</a></h3>
<p>Fully qualified path: <code>core::starknet::secp256r1::Secp256r1PointImpl::mul</code></p>
<pre><code class="language-rust">fn mul(self: Secp256r1Point, scalar: u256) -&gt; SyscallResult&lt;Secp256r1Point&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252tryintocontractaddress"><a class="header" href="#felt252tryintocontractaddress">Felt252TryIntoContractAddress</a></h1>
<p>Fully qualified path: <code>core::starknet::contract_address::Felt252TryIntoContractAddress</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252TryIntoContractAddress of TryInto&lt;felt252, ContractAddress&gt;</code></pre>
<h2 id="impl-functions-69"><a class="header" href="#impl-functions-69">Impl functions</a></h2>
<h3 id="try_into-11"><a class="header" href="#try_into-11">try_into</a></h3>
<p>Fully qualified path: <code>core::starknet::contract_address::Felt252TryIntoContractAddress::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: felt252) -&gt; Option&lt;ContractAddress&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contractaddressintofelt252"><a class="header" href="#contractaddressintofelt252">ContractAddressIntoFelt252</a></h1>
<p>Fully qualified path: <code>core::starknet::contract_address::ContractAddressIntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl ContractAddressIntoFelt252 of Into&lt;ContractAddress, felt252&gt;</code></pre>
<h2 id="impl-functions-70"><a class="header" href="#impl-functions-70">Impl functions</a></h2>
<h3 id="into-14"><a class="header" href="#into-14">into</a></h3>
<p>Fully qualified path: <code>core::starknet::contract_address::ContractAddressIntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: ContractAddress) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252tryintoethaddress"><a class="header" href="#felt252tryintoethaddress">Felt252TryIntoEthAddress</a></h1>
<p>Fully qualified path: <code>core::starknet::eth_address::Felt252TryIntoEthAddress</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252TryIntoEthAddress of TryInto&lt;felt252, EthAddress&gt;</code></pre>
<h2 id="impl-functions-71"><a class="header" href="#impl-functions-71">Impl functions</a></h2>
<h3 id="try_into-12"><a class="header" href="#try_into-12">try_into</a></h3>
<p>Fully qualified path: <code>core::starknet::eth_address::Felt252TryIntoEthAddress::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: felt252) -&gt; Option&lt;EthAddress&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethaddressintofelt252"><a class="header" href="#ethaddressintofelt252">EthAddressIntoFelt252</a></h1>
<p>Fully qualified path: <code>core::starknet::eth_address::EthAddressIntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl EthAddressIntoFelt252 of Into&lt;EthAddress, felt252&gt;</code></pre>
<h2 id="impl-functions-72"><a class="header" href="#impl-functions-72">Impl functions</a></h2>
<h3 id="into-15"><a class="header" href="#into-15">into</a></h3>
<p>Fully qualified path: <code>core::starknet::eth_address::EthAddressIntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: EthAddress) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256intoethaddress"><a class="header" href="#u256intoethaddress">U256IntoEthAddress</a></h1>
<p>Fully qualified path: <code>core::starknet::eth_address::U256IntoEthAddress</code></p>
<pre><code class="language-rust">pub(crate) impl U256IntoEthAddress of Into&lt;u256, EthAddress&gt;</code></pre>
<h2 id="impl-functions-73"><a class="header" href="#impl-functions-73">Impl functions</a></h2>
<h3 id="into-16"><a class="header" href="#into-16">into</a></h3>
<p>Fully qualified path: <code>core::starknet::eth_address::U256IntoEthAddress::into</code></p>
<pre><code class="language-rust">fn into(self: u256) -&gt; EthAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethaddressserde"><a class="header" href="#ethaddressserde">EthAddressSerde</a></h1>
<p>Fully qualified path: <code>core::starknet::eth_address::EthAddressSerde</code></p>
<pre><code class="language-rust">pub(crate) impl EthAddressSerde of Serde&lt;EthAddress&gt;</code></pre>
<h2 id="impl-functions-74"><a class="header" href="#impl-functions-74">Impl functions</a></h2>
<h3 id="serialize-3"><a class="header" href="#serialize-3">serialize</a></h3>
<p>Fully qualified path: <code>core::starknet::eth_address::EthAddressSerde::serialize</code></p>
<pre><code class="language-rust">fn serialize(self: @EthAddress, ref output: Array&lt;felt252&gt;)</code></pre>
<h3 id="deserialize-5"><a class="header" href="#deserialize-5">deserialize</a></h3>
<p>Fully qualified path: <code>core::starknet::eth_address::EthAddressSerde::deserialize</code></p>
<pre><code class="language-rust">fn deserialize(ref serialized: Span&lt;felt252&gt;) -&gt; Option&lt;EthAddress&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ethaddressprintimpl"><a class="header" href="#ethaddressprintimpl">EthAddressPrintImpl</a></h1>
<p>Fully qualified path: <code>core::starknet::eth_address::EthAddressPrintImpl</code></p>
<pre><code class="language-rust">pub(crate) impl EthAddressPrintImpl of PrintTrait&lt;EthAddress&gt;</code></pre>
<h2 id="impl-functions-75"><a class="header" href="#impl-functions-75">Impl functions</a></h2>
<h3 id="print-16"><a class="header" href="#print-16">print</a></h3>
<p>Fully qualified path: <code>core::starknet::eth_address::EthAddressPrintImpl::print</code></p>
<pre><code class="language-rust">fn print(self: EthAddress)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252tryintoclasshash"><a class="header" href="#felt252tryintoclasshash">Felt252TryIntoClassHash</a></h1>
<p>Fully qualified path: <code>core::starknet::class_hash::Felt252TryIntoClassHash</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252TryIntoClassHash of TryInto&lt;felt252, ClassHash&gt;</code></pre>
<h2 id="impl-functions-76"><a class="header" href="#impl-functions-76">Impl functions</a></h2>
<h3 id="try_into-13"><a class="header" href="#try_into-13">try_into</a></h3>
<p>Fully qualified path: <code>core::starknet::class_hash::Felt252TryIntoClassHash::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: felt252) -&gt; Option&lt;ClassHash&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classhashintofelt252"><a class="header" href="#classhashintofelt252">ClassHashIntoFelt252</a></h1>
<p>Fully qualified path: <code>core::starknet::class_hash::ClassHashIntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl ClassHashIntoFelt252 of Into&lt;ClassHash, felt252&gt;</code></pre>
<h2 id="impl-functions-77"><a class="header" href="#impl-functions-77">Impl functions</a></h2>
<h3 id="into-17"><a class="header" href="#into-17">into</a></h3>
<p>Fully qualified path: <code>core::starknet::class_hash::ClassHashIntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: ClassHash) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storablestoragepointerreadaccess"><a class="header" href="#storablestoragepointerreadaccess">StorableStoragePointerReadAccess</a></h1>
<p>Simple implementation of <code>StoragePointerReadAccess</code> for any type that implements <code>Store</code> for any offset.</p>
<p>Fully qualified path: <code>core::starknet::storage::StorableStoragePointerReadAccess</code></p>
<pre><code class="language-rust">pub impl StorableStoragePointerReadAccess&lt;
    T, +starknet::Store&lt;T&gt;,
&gt; of StoragePointerReadAccess&lt;StoragePointer&lt;T&gt;&gt;</code></pre>
<h2 id="impl-functions-78"><a class="header" href="#impl-functions-78">Impl functions</a></h2>
<h3 id="read-4"><a class="header" href="#read-4">read</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorableStoragePointerReadAccess::read</code></p>
<pre><code class="language-rust">fn read(self: @StoragePointer&lt;T&gt;) -&gt; T</code></pre>
<h2 id="impl-types"><a class="header" href="#impl-types">Impl types</a></h2>
<h3 id="value-7"><a class="header" href="#value-7">Value</a></h3>
<p>Fully qualified path: <code>core::starknet::storage::StorableStoragePointerReadAccess::Value</code></p>
<pre><code class="language-rust">type Value = T;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nonzerointoimpl"><a class="header" href="#nonzerointoimpl">NonZeroIntoImpl</a></h1>
<p>Fully qualified path: <code>core::zeroable::NonZeroIntoImpl</code></p>
<pre><code class="language-rust">pub(crate) impl NonZeroIntoImpl&lt;T&gt; of Into&lt;NonZero&lt;T&gt;, T&gt;</code></pre>
<h2 id="impl-functions-79"><a class="header" href="#impl-functions-79">Impl functions</a></h2>
<h3 id="into-18"><a class="header" href="#into-18">into</a></h3>
<p>Fully qualified path: <code>core::zeroable::NonZeroIntoImpl::into</code></p>
<pre><code class="language-rust">fn into(self: NonZero&lt;T&gt;) -&gt; T nopanic</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes31impl"><a class="header" href="#bytes31impl">Bytes31Impl</a></h1>
<p>A trait for accessing a specific byte of a <code>bytes31</code> type.</p>
<p>Fully qualified path: <code>core::bytes_31::Bytes31Impl</code></p>
<pre><code class="language-rust">pub impl Bytes31Impl of Bytes31Trait</code></pre>
<h2 id="impl-functions-80"><a class="header" href="#impl-functions-80">Impl functions</a></h2>
<h3 id="at-6"><a class="header" href="#at-6">at</a></h3>
<p>Returns the byte at the given index (LSB's index is 0).  Assumes that <code>index &lt; BYTES_IN_BYTES31</code>. If the assumption is not met, the behavior is undefined.  # Examples</p>
<pre><code class="language-cairo">let bytes: bytes31 = 1_u8.into();
assert!(bytes.at(0) == 1);
</code></pre>
<p>Fully qualified path: <code>core::bytes_31::Bytes31Impl::at</code></p>
<pre><code class="language-rust">fn at(self: @bytes31, index: usize) -&gt; u8</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes31indexview"><a class="header" href="#bytes31indexview">Bytes31IndexView</a></h1>
<p>Fully qualified path: <code>core::bytes_31::Bytes31IndexView</code></p>
<pre><code class="language-rust">pub(crate) impl Bytes31IndexView of crate::traits::IndexView&lt;bytes31, usize, u8&gt;</code></pre>
<h2 id="impl-functions-81"><a class="header" href="#impl-functions-81">Impl functions</a></h2>
<h3 id="index-11"><a class="header" href="#index-11">index</a></h3>
<p>Fully qualified path: <code>core::bytes_31::Bytes31IndexView::index</code></p>
<pre><code class="language-rust">fn index(self: @bytes31, index: usize) -&gt; u8</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes31intofelt252"><a class="header" href="#bytes31intofelt252">Bytes31IntoFelt252</a></h1>
<p>Fully qualified path: <code>core::bytes_31::Bytes31IntoFelt252</code></p>
<pre><code class="language-rust">pub(crate) impl Bytes31IntoFelt252 of Into&lt;bytes31, felt252&gt;</code></pre>
<h2 id="impl-functions-82"><a class="header" href="#impl-functions-82">Impl functions</a></h2>
<h3 id="into-19"><a class="header" href="#into-19">into</a></h3>
<p>Fully qualified path: <code>core::bytes_31::Bytes31IntoFelt252::into</code></p>
<pre><code class="language-rust">fn into(self: bytes31) -&gt; felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes31intou256"><a class="header" href="#bytes31intou256">Bytes31IntoU256</a></h1>
<p>Fully qualified path: <code>core::bytes_31::Bytes31IntoU256</code></p>
<pre><code class="language-rust">pub(crate) impl Bytes31IntoU256 of Into&lt;bytes31, u256&gt;</code></pre>
<h2 id="impl-functions-83"><a class="header" href="#impl-functions-83">Impl functions</a></h2>
<h3 id="into-20"><a class="header" href="#into-20">into</a></h3>
<p>Fully qualified path: <code>core::bytes_31::Bytes31IntoU256::into</code></p>
<pre><code class="language-rust">fn into(self: bytes31) -&gt; u256</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252tryintobytes31"><a class="header" href="#felt252tryintobytes31">Felt252TryIntoBytes31</a></h1>
<p>Fully qualified path: <code>core::bytes_31::Felt252TryIntoBytes31</code></p>
<pre><code class="language-rust">pub(crate) impl Felt252TryIntoBytes31 of TryInto&lt;felt252, bytes31&gt;</code></pre>
<h2 id="impl-functions-84"><a class="header" href="#impl-functions-84">Impl functions</a></h2>
<h3 id="try_into-14"><a class="header" href="#try_into-14">try_into</a></h3>
<p>Fully qualified path: <code>core::bytes_31::Felt252TryIntoBytes31::try_into</code></p>
<pre><code class="language-rust">fn try_into(self: felt252) -&gt; Option&lt;bytes31&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8intobytes31"><a class="header" href="#u8intobytes31">U8IntoBytes31</a></h1>
<p>Fully qualified path: <code>core::bytes_31::U8IntoBytes31</code></p>
<pre><code class="language-rust">pub(crate) impl U8IntoBytes31 of Into&lt;u8, bytes31&gt;</code></pre>
<h2 id="impl-functions-85"><a class="header" href="#impl-functions-85">Impl functions</a></h2>
<h3 id="into-21"><a class="header" href="#into-21">into</a></h3>
<p>Fully qualified path: <code>core::bytes_31::U8IntoBytes31::into</code></p>
<pre><code class="language-rust">fn into(self: u8) -&gt; bytes31</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128intobytes31"><a class="header" href="#u128intobytes31">U128IntoBytes31</a></h1>
<p>Fully qualified path: <code>core::bytes_31::U128IntoBytes31</code></p>
<pre><code class="language-rust">pub(crate) impl U128IntoBytes31 of Into&lt;u128, bytes31&gt;</code></pre>
<h2 id="impl-functions-86"><a class="header" href="#impl-functions-86">Impl functions</a></h2>
<h3 id="into-22"><a class="header" href="#into-22">into</a></h3>
<p>Fully qualified path: <code>core::bytes_31::U128IntoBytes31::into</code></p>
<pre><code class="language-rust">fn into(self: u128) -&gt; bytes31</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytearraystringliteral"><a class="header" href="#bytearraystringliteral">ByteArrayStringLiteral</a></h1>
<p>Fully qualified path: <code>core::byte_array::ByteArrayStringLiteral</code></p>
<pre><code class="language-rust">pub(crate) impl ByteArrayStringLiteral of crate::string::StringLiteral&lt;ByteArray&gt;;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytearrayimpl"><a class="header" href="#bytearrayimpl">ByteArrayImpl</a></h1>
<p>Functions associated with the <code>ByteArray</code> type.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl</code></p>
<pre><code class="language-rust">pub impl ByteArrayImpl of ByteArrayTrait</code></pre>
<h2 id="impl-functions-87"><a class="header" href="#impl-functions-87">Impl functions</a></h2>
<h3 id="append_word-1"><a class="header" href="#append_word-1">append_word</a></h3>
<p>Appends a single word of <code>len</code> bytes to the end of the <code>ByteArray</code>.  This function assumes that: 1. <code>word</code> could be validly converted to a <code>bytes31</code> which has no more than <code>len</code> bytes    of data. 2. len &lt;= BYTES_IN_BYTES31.  If these assumptions are not met, it can corrupt the <code>ByteArray</code>. Thus, this should be a private function. We could add masking/assertions but it would be more expensive.  # Examples</p>
<pre><code class="language-cairo">let mut ba = "";
ba.append_word('word', 4);
assert!(ba == "word");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_word</code></p>
<pre><code class="language-rust">fn append_word(ref self: ByteArray, word: felt252, len: usize)</code></pre>
<h3 id="append-3"><a class="header" href="#append-3">append</a></h3>
<p>Appends a <code>ByteArray</code> to the end of another <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">let mut ba: ByteArray = "1";
ba.append(@"2");
assert!(ba == "12");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append</code></p>
<pre><code class="language-rust">fn append(ref self: ByteArray, mut other: @ByteArray)</code></pre>
<h3 id="concat-1"><a class="header" href="#concat-1">concat</a></h3>
<p>Concatenates two <code>ByteArray</code> and returns the result.  The content of <code>left</code> is cloned in a new memory segment. # Examples</p>
<pre><code class="language-cairo">let ba = "1";
let other_ba = "2";
let result = ByteArrayTrait::concat(@ba, @other_ba);
assert!(result == "12");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::concat</code></p>
<pre><code class="language-rust">fn concat(left: @ByteArray, right: @ByteArray) -&gt; ByteArray</code></pre>
<h3 id="append_byte-1"><a class="header" href="#append_byte-1">append_byte</a></h3>
<p>Appends a single byte to the end of the <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">let mut ba = "";
ba.append_byte(0);
assert!(ba == "0");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_byte</code></p>
<pre><code class="language-rust">fn append_byte(ref self: ByteArray, byte: u8)</code></pre>
<h3 id="len-5"><a class="header" href="#len-5">len</a></h3>
<p>Returns the length of the <code>ByteArray</code>.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "byte array";
let len = ba.len();
assert!(len == 10);
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::len</code></p>
<pre><code class="language-rust">fn len(self: @ByteArray) -&gt; usize</code></pre>
<h3 id="at-7"><a class="header" href="#at-7">at</a></h3>
<p>Returns an option of the byte at the given index of <code>self</code> or <code>Option::None</code> if the index is out of bounds.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "byte array";
let byte = ba.at(0).unwrap();
assert!(byte == 98);
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::at</code></p>
<pre><code class="language-rust">fn at(self: @ByteArray, index: usize) -&gt; Option&lt;u8&gt;</code></pre>
<h3 id="rev-1"><a class="header" href="#rev-1">rev</a></h3>
<p>Returns a <code>ByteArray</code> with the reverse order of <code>self</code>.  # Examples</p>
<pre><code class="language-cairo">let ba: ByteArray = "123";
let rev_ba = ba.rev();
assert!(rev_ba == "321");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::rev</code></p>
<pre><code class="language-rust">fn rev(self: @ByteArray) -&gt; ByteArray</code></pre>
<h3 id="append_word_rev-1"><a class="header" href="#append_word_rev-1">append_word_rev</a></h3>
<p>Appends the reverse of the given word to the end of <code>self</code>.  This function assumes that: 1. len &lt; 31 2. word is validly convertible to bytes31 of length <code>len</code>.  # Examples</p>
<pre><code class="language-cairo">let mut ba: ByteArray = "";
ba.append_word_rev('123', 3);
assert!(ba == "321");
</code></pre>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_word_rev</code></p>
<pre><code class="language-rust">fn append_word_rev(ref self: ByteArray, word: felt252, len: usize)</code></pre>
<h3 id="append_word_fits_into_pending-1"><a class="header" href="#append_word_fits_into_pending-1">append_word_fits_into_pending</a></h3>
<p>Appends a single word of <code>len</code> bytes to the end of the <code>ByteArray</code>, assuming there is enough space in the pending word (<code>self.pending_word_len + len &lt; BYTES_IN_BYTES31</code>).  <code>word</code> is of type <code>felt252</code> but actually represents a <code>bytes31</code>. It is represented as a <code>felt252</code> to improve performance of building the <code>ByteArray</code>.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_word_fits_into_pending</code></p>
<pre><code class="language-rust">fn append_word_fits_into_pending(ref self: ByteArray, word: felt252, len: usize)</code></pre>
<h3 id="append_split_index_lt_16-1"><a class="header" href="#append_split_index_lt_16-1">append_split_index_lt_16</a></h3>
<p>Appends a single word to the end of <code>self</code>, given that <code>0 &lt; split_index &lt; 16</code>.  <code>split_index</code> is the number of bytes left in <code>self.pending_word</code> after this function. This is the index of the split (LSB's index is 0).  Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_split_index_lt_16</code></p>
<pre><code class="language-rust">fn append_split_index_lt_16(ref self: ByteArray, word: felt252, split_index: usize)</code></pre>
<h3 id="append_split_index_16-1"><a class="header" href="#append_split_index_16-1">append_split_index_16</a></h3>
<p>Appends a single word to the end of <code>self</code>, given that the index of splitting <code>word</code> is exactly 16.  <code>split_index</code> is the number of bytes left in <code>self.pending_word</code> after this function. This is the index of the split (LSB's index is 0).  Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_split_index_16</code></p>
<pre><code class="language-rust">fn append_split_index_16(ref self: ByteArray, word: felt252)</code></pre>
<h3 id="append_split_index_gt_16-1"><a class="header" href="#append_split_index_gt_16-1">append_split_index_gt_16</a></h3>
<p>Appends a single word to the end of <code>self</code>, given that the index of splitting <code>word</code> is &gt; 16.  <code>split_index</code> is the number of bytes left in <code>self.pending_word</code> after this function. This is the index of the split (LSB's index is 0).  Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_split_index_gt_16</code></p>
<pre><code class="language-rust">fn append_split_index_gt_16(ref self: ByteArray, word: felt252, split_index: usize)</code></pre>
<h3 id="append_split-1"><a class="header" href="#append_split-1">append_split</a></h3>
<p>A helper function to append a remainder to <code>self</code>, by: 1. completing <code>self.pending_word</code> to a full word using <code>complete_full_word</code>, assuming it's    validly convertible to a <code>bytes31</code> of length exactly <code>BYTES_IN_BYTES31 -    self.pending_word_len</code>. 2. Setting <code>self.pending_word</code> to <code>new_pending</code>.  Note: this function doesn't update the new pending length of <code>self</code>. It's the caller's responsibility.</p>
<p>Fully qualified path: <code>core::byte_array::ByteArrayImpl::append_split</code></p>
<pre><code class="language-rust">fn append_split(ref self: ByteArray, complete_full_word: felt252, new_pending: felt252)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytearrayindexview"><a class="header" href="#bytearrayindexview">ByteArrayIndexView</a></h1>
<p>Fully qualified path: <code>core::byte_array::ByteArrayIndexView</code></p>
<pre><code class="language-rust">pub(crate) impl ByteArrayIndexView of crate::traits::IndexView&lt;ByteArray, usize, u8&gt;</code></pre>
<h2 id="impl-functions-88"><a class="header" href="#impl-functions-88">Impl functions</a></h2>
<h3 id="index-12"><a class="header" href="#index-12">index</a></h3>
<p>Fully qualified path: <code>core::byte_array::ByteArrayIndexView::index</code></p>
<pre><code class="language-rust">fn index(self: @ByteArray, index: usize) -&gt; u8</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extern-types-21"><a class="header" href="#extern-types-21">Extern types</a></h1>
<ul>
<li>
<p><a href="./core-RangeCheck.html">RangeCheck</a></p>
</li>
<li>
<p><a href="./core-SegmentArena.html">SegmentArena</a></p>
</li>
<li>
<p><a href="./core-felt252.html">felt252</a></p>
</li>
<li>
<p><a href="./core-circuit-RangeCheck96.html">RangeCheck96</a></p>
</li>
<li>
<p><a href="./core-circuit-AddMod.html">AddMod</a></p>
</li>
<li>
<p><a href="./core-circuit-MulMod.html">MulMod</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitModulus.html">CircuitModulus</a></p>
</li>
<li>
<p><a href="./core-circuit-Circuit.html">Circuit</a></p>
</li>
<li>
<p><a href="./core-circuit-CircuitInput.html">CircuitInput</a></p>
</li>
<li>
<p><a href="./core-box-Box.html">Box</a></p>
</li>
<li>
<p><a href="./core-nullable-Nullable.html">Nullable</a></p>
</li>
<li>
<p><a href="./core-array-Array.html">Array</a></p>
</li>
<li>
<p><a href="./core-dict-Felt252Dict.html">Felt252Dict</a></p>
</li>
<li>
<p><a href="./core-dict-SquashedFelt252Dict.html">SquashedFelt252Dict</a></p>
</li>
<li>
<p><a href="./core-dict-Felt252DictEntry.html">Felt252DictEntry</a></p>
</li>
<li>
<p><a href="./core-ec-EcOp.html">EcOp</a></p>
</li>
<li>
<p><a href="./core-ec-EcPoint.html">EcPoint</a></p>
</li>
<li>
<p><a href="./core-ec-EcState.html">EcState</a></p>
</li>
<li>
<p><a href="./core-integer-u128.html">u128</a></p>
</li>
<li>
<p><a href="./core-integer-U128MulGuarantee.html">U128MulGuarantee</a></p>
</li>
<li>
<p><a href="./core-integer-Bitwise.html">Bitwise</a></p>
</li>
<li>
<p><a href="./core-integer-u8.html">u8</a></p>
</li>
<li>
<p><a href="./core-integer-u16.html">u16</a></p>
</li>
<li>
<p><a href="./core-integer-u32.html">u32</a></p>
</li>
<li>
<p><a href="./core-integer-u64.html">u64</a></p>
</li>
<li>
<p><a href="./core-integer-i8.html">i8</a></p>
</li>
<li>
<p><a href="./core-integer-i16.html">i16</a></p>
</li>
<li>
<p><a href="./core-integer-i32.html">i32</a></p>
</li>
<li>
<p><a href="./core-integer-i64.html">i64</a></p>
</li>
<li>
<p><a href="./core-integer-i128.html">i128</a></p>
</li>
<li>
<p><a href="./core-gas-BuiltinCosts.html">BuiltinCosts</a></p>
</li>
<li>
<p><a href="./core-gas-GasBuiltin.html">GasBuiltin</a></p>
</li>
<li>
<p><a href="./core-sha256-Sha256StateHandle.html">Sha256StateHandle</a></p>
</li>
<li>
<p><a href="./core-pedersen-Pedersen.html">Pedersen</a></p>
</li>
<li>
<p><a href="./core-poseidon-Poseidon.html">Poseidon</a></p>
</li>
<li>
<p><a href="./core-starknet-System.html">System</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorageAddress.html">starknet::storage_access::StorageAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-ContractAddress.html">starknet::contract_address::ContractAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-ClassHash.html">starknet::class_hash::ClassHash</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorageAddress.html">starknet::storage_access::StorageAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-StorageBaseAddress.html">StorageBaseAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256k1-Secp256k1Point.html">Secp256k1Point</a></p>
</li>
<li>
<p><a href="./core-starknet-secp256r1-Secp256r1Point.html">Secp256r1Point</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-ContractAddress.html">starknet::contract_address::ContractAddress</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-ClassHash.html">starknet::class_hash::ClassHash</a></p>
</li>
<li>
<p><a href="./core-internal-bounded_int-BoundedInt.html">BoundedInt</a></p>
</li>
<li>
<p><a href="./core-zeroable-NonZero.html">NonZero</a></p>
</li>
<li>
<p><a href="./core-bytes_31-bytes31.html">bytes31</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rangecheck"><a class="header" href="#rangecheck">RangeCheck</a></h1>
<p>General purpose implicits.</p>
<p>Fully qualified path: <code>core::RangeCheck</code></p>
<pre><code class="language-rust">pub extern type RangeCheck</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segmentarena"><a class="header" href="#segmentarena">SegmentArena</a></h1>
<p>Fully qualified path: <code>core::SegmentArena</code></p>
<pre><code class="language-rust">pub extern type SegmentArena</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252"><a class="header" href="#felt252">felt252</a></h1>
<p>Fully qualified path: <code>core::felt252</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type felt252</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rangecheck96"><a class="header" href="#rangecheck96">RangeCheck96</a></h1>
<p>Fully qualified path: <code>core::circuit::RangeCheck96</code></p>
<pre><code class="language-rust">pub extern type RangeCheck96</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="addmod"><a class="header" href="#addmod">AddMod</a></h1>
<p>Fully qualified path: <code>core::circuit::AddMod</code></p>
<pre><code class="language-rust">pub extern type AddMod</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mulmod"><a class="header" href="#mulmod">MulMod</a></h1>
<p>Fully qualified path: <code>core::circuit::MulMod</code></p>
<pre><code class="language-rust">pub extern type MulMod</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitmodulus"><a class="header" href="#circuitmodulus">CircuitModulus</a></h1>
<p>A type that can be used as a circuit modulus (a u384 that is not zero or one).</p>
<p>Fully qualified path: <code>core::circuit::CircuitModulus</code></p>
<pre><code class="language-rust">pub extern type CircuitModulus</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuit-1"><a class="header" href="#circuit-1">Circuit</a></h1>
<p>A type that creates a circuit from a tuple of outputs.</p>
<p>Fully qualified path: <code>core::circuit::Circuit</code></p>
<pre><code class="language-rust">pub extern type Circuit&lt;Outputs&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="circuitinput"><a class="header" href="#circuitinput">CircuitInput</a></h1>
<p>Defines an input for a circuit.</p>
<p>Fully qualified path: <code>core::circuit::CircuitInput</code></p>
<pre><code class="language-rust">#[phantom]
pub extern type CircuitInput&lt;const N: usize&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box-1"><a class="header" href="#box-1">Box</a></h1>
<p>A <code>Box</code> is a type that points to a wrapped value. It allows for cheap moving around of the value, as its size is small, and may wrap a large size.</p>
<p>Fully qualified path: <code>core::box::Box</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type Box&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullable-1"><a class="header" href="#nullable-1">Nullable</a></h1>
<p>A type that can either be null or contain a boxed value.</p>
<p>Fully qualified path: <code>core::nullable::Nullable</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type Nullable&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-1"><a class="header" href="#array-1">Array</a></h1>
<p>A collection of elements of the same type continuous in memory.</p>
<p>Fully qualified path: <code>core::array::Array</code></p>
<pre><code class="language-rust">#[derive(Drop)]
pub extern type Array&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252dict"><a class="header" href="#felt252dict">Felt252Dict</a></h1>
<p>A dictionary that maps <code>felt252</code> keys to a value of any type.</p>
<p>Fully qualified path: <code>core::dict::Felt252Dict</code></p>
<pre><code class="language-rust">pub extern type Felt252Dict&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="squashedfelt252dict"><a class="header" href="#squashedfelt252dict">SquashedFelt252Dict</a></h1>
<p>A dictionary in a squashed state. It cannot be mutated anymore.</p>
<p>Fully qualified path: <code>core::dict::SquashedFelt252Dict</code></p>
<pre><code class="language-rust">pub extern type SquashedFelt252Dict&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252dictentry"><a class="header" href="#felt252dictentry">Felt252DictEntry</a></h1>
<p>An intermediate type that is returned after calling the <code>entry</code> method that consumes ownership of the dictionary. This ensures that the dictionary cannot be mutated until the entry is finalized, which restores ownership of the dictionary.</p>
<p>Fully qualified path: <code>core::dict::Felt252DictEntry</code></p>
<pre><code class="language-rust">pub extern type Felt252DictEntry&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecop"><a class="header" href="#ecop">EcOp</a></h1>
<p>Fully qualified path: <code>core::ec::EcOp</code></p>
<pre><code class="language-rust">pub extern type EcOp</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecpoint"><a class="header" href="#ecpoint">EcPoint</a></h1>
<p>Fully qualified path: <code>core::ec::EcPoint</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type EcPoint</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecstate"><a class="header" href="#ecstate">EcState</a></h1>
<p>Fully qualified path: <code>core::ec::EcState</code></p>
<pre><code class="language-rust">#[derive(Drop)]
pub extern type EcState</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128"><a class="header" href="#u128">u128</a></h1>
<p>Fully qualified path: <code>core::integer::u128</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type u128</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128mulguarantee"><a class="header" href="#u128mulguarantee">U128MulGuarantee</a></h1>
<p>A type that contains 4 u128s (a, b, c, d) and guarantees that <code>a * b = 2**128 * c + d</code>.  The guarantee is verified by <code>u128_mul_guarantee_verify</code>, which is the only way to destruct this type. This way, one can trust that the guarantee holds although it has not yet been verified.</p>
<p>Fully qualified path: <code>core::integer::U128MulGuarantee</code></p>
<pre><code class="language-rust">pub extern type U128MulGuarantee</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitwise"><a class="header" href="#bitwise">Bitwise</a></h1>
<p>Fully qualified path: <code>core::integer::Bitwise</code></p>
<pre><code class="language-rust">pub extern type Bitwise</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8"><a class="header" href="#u8">u8</a></h1>
<p>Fully qualified path: <code>core::integer::u8</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type u8</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16"><a class="header" href="#u16">u16</a></h1>
<p>Fully qualified path: <code>core::integer::u16</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type u16</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32"><a class="header" href="#u32">u32</a></h1>
<p>Fully qualified path: <code>core::integer::u32</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type u32</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64"><a class="header" href="#u64">u64</a></h1>
<p>Fully qualified path: <code>core::integer::u64</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type u64</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i8"><a class="header" href="#i8">i8</a></h1>
<p>Fully qualified path: <code>core::integer::i8</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type i8</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i16"><a class="header" href="#i16">i16</a></h1>
<p>Fully qualified path: <code>core::integer::i16</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type i16</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i32"><a class="header" href="#i32">i32</a></h1>
<p>Fully qualified path: <code>core::integer::i32</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type i32</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i64"><a class="header" href="#i64">i64</a></h1>
<p>Fully qualified path: <code>core::integer::i64</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type i64</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i128"><a class="header" href="#i128">i128</a></h1>
<p>Fully qualified path: <code>core::integer::i128</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type i128</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtincosts"><a class="header" href="#builtincosts">BuiltinCosts</a></h1>
<p>Type representing the table of the costs of the different builtin usages.</p>
<p>Fully qualified path: <code>core::gas::BuiltinCosts</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type BuiltinCosts</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gasbuiltin"><a class="header" href="#gasbuiltin">GasBuiltin</a></h1>
<p>The gas builtin. This type is used to handle gas in the Cairo code. Contains the amount of gas available for the current run.</p>
<p>Fully qualified path: <code>core::gas::GasBuiltin</code></p>
<pre><code class="language-rust">pub extern type GasBuiltin</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha256statehandle"><a class="header" href="#sha256statehandle">Sha256StateHandle</a></h1>
<p>A handle to the state of a SHA-256 hash.</p>
<p>Fully qualified path: <code>core::sha256::Sha256StateHandle</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub(crate) extern type Sha256StateHandle</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersen-1"><a class="header" href="#pedersen-1">pedersen</a></h1>
<p>Fully qualified path: <code>core::pedersen::pedersen</code></p>
<pre><code class="language-rust">pub extern fn pedersen(a: felt252, b: felt252) -&gt; felt252 implicits(Pedersen) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="poseidon-1"><a class="header" href="#poseidon-1">Poseidon</a></h1>
<p>Fully qualified path: <code>core::poseidon::Poseidon</code></p>
<pre><code class="language-rust">pub extern type Poseidon</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system"><a class="header" href="#system">System</a></h1>
<p>Fully qualified path: <code>core::starknet::System</code></p>
<pre><code class="language-rust">pub extern type System</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storageaddress"><a class="header" href="#storageaddress">StorageAddress</a></h1>
<p>Represents the address of a storage value in a Starknet contract. The value range of this type is <code>[0, 2**251)</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::StorageAddress</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type StorageAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contractaddress"><a class="header" href="#contractaddress">ContractAddress</a></h1>
<p>Represents a Starknet contract address. The value range of this type is <code>[0, 2**251)</code>.</p>
<p>Fully qualified path: <code>core::starknet::contract_address::ContractAddress</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type ContractAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classhash"><a class="header" href="#classhash">ClassHash</a></h1>
<p>Represents a Starknet contract class hash. The value range of this type is <code>[0, 2**251)</code>.</p>
<p>Fully qualified path: <code>core::starknet::class_hash::ClassHash</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type ClassHash</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storageaddress-1"><a class="header" href="#storageaddress-1">StorageAddress</a></h1>
<p>Represents the address of a storage value in a Starknet contract. The value range of this type is <code>[0, 2**251)</code>.</p>
<p>Fully qualified path: <code>core::starknet::storage_access::StorageAddress</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type StorageAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storagebaseaddress"><a class="header" href="#storagebaseaddress">StorageBaseAddress</a></h1>
<p>Fully qualified path: <code>core::starknet::storage_access::StorageBaseAddress</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type StorageBaseAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256k1point"><a class="header" href="#secp256k1point">Secp256k1Point</a></h1>
<p>A point on the secp256k1 curve.</p>
<p>Fully qualified path: <code>core::starknet::secp256k1::Secp256k1Point</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type Secp256k1Point</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secp256r1point"><a class="header" href="#secp256r1point">Secp256r1Point</a></h1>
<p>Represents a point on the secp256r1 elliptic curve.</p>
<p>Fully qualified path: <code>core::starknet::secp256r1::Secp256r1Point</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type Secp256r1Point</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contractaddress-1"><a class="header" href="#contractaddress-1">ContractAddress</a></h1>
<p>Represents a Starknet contract address. The value range of this type is <code>[0, 2**251)</code>.</p>
<p>Fully qualified path: <code>core::starknet::contract_address::ContractAddress</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type ContractAddress</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classhash-1"><a class="header" href="#classhash-1">ClassHash</a></h1>
<p>Represents a Starknet contract class hash. The value range of this type is <code>[0, 2**251)</code>.</p>
<p>Fully qualified path: <code>core::starknet::class_hash::ClassHash</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type ClassHash</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boundedint-1"><a class="header" href="#boundedint-1">BoundedInt</a></h1>
<p>Fully qualified path: <code>core::internal::bounded_int::BoundedInt</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub(crate) extern type BoundedInt&lt;const MIN: felt252, const MAX: felt252&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nonzero-1"><a class="header" href="#nonzero-1">NonZero</a></h1>
<p>A wrapper type for non-zero values of type T.  This type guarantees that the wrapped value is never zero.</p>
<p>Fully qualified path: <code>core::zeroable::NonZero</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type NonZero&lt;T&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes31"><a class="header" href="#bytes31">bytes31</a></h1>
<p>Represents a 31-byte fixed-size byte type.</p>
<p>Fully qualified path: <code>core::bytes_31::bytes31</code></p>
<pre><code class="language-rust">#[derive(Copy, Drop)]
pub extern type bytes31</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extern-functions-20"><a class="header" href="#extern-functions-20">Extern functions</a></h1>
<ul>
<li>
<p><a href="./core-bool_and_impl.html">bool_and_impl</a></p>
</li>
<li>
<p><a href="./core-bool_or_impl.html">bool_or_impl</a></p>
</li>
<li>
<p><a href="./core-bool_not_impl.html">bool_not_impl</a></p>
</li>
<li>
<p><a href="./core-bool_xor_impl.html">bool_xor_impl</a></p>
</li>
<li>
<p><a href="./core-bool_to_felt252.html">bool_to_felt252</a></p>
</li>
<li>
<p><a href="./core-felt252_const.html">felt252_const</a></p>
</li>
<li>
<p><a href="./core-felt252_add.html">felt252_add</a></p>
</li>
<li>
<p><a href="./core-felt252_sub.html">felt252_sub</a></p>
</li>
<li>
<p><a href="./core-felt252_mul.html">felt252_mul</a></p>
</li>
<li>
<p><a href="./core-felt252_div.html">felt252_div</a></p>
</li>
<li>
<p><a href="./core-felt252_is_zero.html">felt252_is_zero</a></p>
</li>
<li>
<p><a href="./core-dup.html">dup</a></p>
</li>
<li>
<p><a href="./core-drop.html">drop</a></p>
</li>
<li>
<p><a href="./core-nullable-null.html">null</a></p>
</li>
<li>
<p><a href="./core-nullable-nullable_from_box.html">nullable_from_box</a></p>
</li>
<li>
<p><a href="./core-nullable-match_nullable.html">match_nullable</a></p>
</li>
<li>
<p><a href="./core-array-array_snapshot_pop_front.html">array_snapshot_pop_front</a></p>
</li>
<li>
<p><a href="./core-dict-felt252_dict_new.html">felt252_dict_new</a></p>
</li>
<li>
<p><a href="./core-dict-felt252_dict_squash.html">felt252_dict_squash</a></p>
</li>
<li>
<p><a href="./core-ec-ec_point_unwrap.html">ec_point_unwrap</a></p>
</li>
<li>
<p><a href="./core-integer-u128_to_felt252.html">u128_to_felt252</a></p>
</li>
<li>
<p><a href="./core-integer-u128_overflowing_add.html">u128_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u128_overflowing_sub.html">u128_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u128_sqrt.html">u128_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u128_safe_divmod.html">u128_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u128_is_zero.html">u128_is_zero</a></p>
</li>
<li>
<p><a href="./core-integer-u128_byte_reverse.html">u128_byte_reverse</a></p>
</li>
<li>
<p><a href="./core-integer-u8_overflowing_add.html">u8_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u8_overflowing_sub.html">u8_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u8_wide_mul.html">u8_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u8_sqrt.html">u8_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u8_safe_divmod.html">u8_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u16_overflowing_add.html">u16_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u16_overflowing_sub.html">u16_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u16_wide_mul.html">u16_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u16_sqrt.html">u16_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u16_safe_divmod.html">u16_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u32_overflowing_add.html">u32_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u32_overflowing_sub.html">u32_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u32_wide_mul.html">u32_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u32_sqrt.html">u32_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u32_safe_divmod.html">u32_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u64_overflowing_add.html">u64_overflowing_add</a></p>
</li>
<li>
<p><a href="./core-integer-u64_overflowing_sub.html">u64_overflowing_sub</a></p>
</li>
<li>
<p><a href="./core-integer-u64_wide_mul.html">u64_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-u64_sqrt.html">u64_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-u64_safe_divmod.html">u64_safe_divmod</a></p>
</li>
<li>
<p><a href="./core-integer-u256_sqrt.html">u256_sqrt</a></p>
</li>
<li>
<p><a href="./core-integer-upcast.html">upcast</a></p>
</li>
<li>
<p><a href="./core-integer-downcast.html">downcast</a></p>
</li>
<li>
<p><a href="./core-integer-i8_wide_mul.html">i8_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i8_diff.html">i8_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i16_wide_mul.html">i16_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i16_diff.html">i16_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i32_wide_mul.html">i32_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i32_diff.html">i32_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i64_wide_mul.html">i64_wide_mul</a></p>
</li>
<li>
<p><a href="./core-integer-i64_diff.html">i64_diff</a></p>
</li>
<li>
<p><a href="./core-integer-i128_diff.html">i128_diff</a></p>
</li>
<li>
<p><a href="./core-gas-withdraw_gas.html">withdraw_gas</a></p>
</li>
<li>
<p><a href="./core-gas-withdraw_gas_all.html">withdraw_gas_all</a></p>
</li>
<li>
<p><a href="./core-gas-redeposit_gas.html">redeposit_gas</a></p>
</li>
<li>
<p><a href="./core-gas-get_builtin_costs.html">get_builtin_costs</a></p>
</li>
<li>
<p><a href="./core-panics-panic.html">panic</a></p>
</li>
<li>
<p><a href="./core-pedersen-pedersen.html">pedersen</a></p>
</li>
<li>
<p><a href="./core-poseidon-hades_permutation.html">hades_permutation</a></p>
</li>
<li>
<p><a href="./core-debug-print.html">print</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-contract_address_const.html">starknet::contract_address::contract_address_const</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_base_address_const.html">storage_base_address_const</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_base_address_from_felt252.html">storage_base_address_from_felt252</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_address_to_felt252.html">storage_address_to_felt252</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_address_from_base_and_offset.html">storage_address_from_base_and_offset</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_address_from_base.html">storage_address_from_base</a></p>
</li>
<li>
<p><a href="./core-starknet-storage_access-storage_address_try_from_felt252.html">storage_address_try_from_felt252</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-call_contract_syscall.html">call_contract_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-deploy_syscall.html">deploy_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-emit_event_syscall.html">emit_event_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_block_hash_syscall.html">get_block_hash_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_execution_info_syscall.html">get_execution_info_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_execution_info_v2_syscall.html">get_execution_info_v2_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-library_call_syscall.html">library_call_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-send_message_to_l1_syscall.html">send_message_to_l1_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-storage_read_syscall.html">storage_read_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-storage_write_syscall.html">storage_write_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-replace_class_syscall.html">replace_class_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-get_class_hash_at_syscall.html">get_class_hash_at_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-keccak_syscall.html">keccak_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-syscalls-sha256_process_block_syscall.html">sha256_process_block_syscall</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-contract_address_const.html">starknet::contract_address::contract_address_const</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-contract_address_to_felt252.html">contract_address_to_felt252</a></p>
</li>
<li>
<p><a href="./core-starknet-contract_address-contract_address_try_from_felt252.html">contract_address_try_from_felt252</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-class_hash_const.html">class_hash_const</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-class_hash_to_felt252.html">class_hash_to_felt252</a></p>
</li>
<li>
<p><a href="./core-starknet-class_hash-class_hash_try_from_felt252.html">class_hash_try_from_felt252</a></p>
</li>
<li>
<p><a href="./core-starknet-testing-cheatcode.html">cheatcode</a></p>
</li>
<li>
<p><a href="./core-internal-revoke_ap_tracking.html">revoke_ap_tracking</a></p>
</li>
<li>
<p><a href="./core-internal-require_implicit.html">require_implicit</a></p>
</li>
<li>
<p><a href="./core-bytes_31-bytes31_const.html">bytes31_const</a></p>
</li>
<li>
<p><a href="./core-testing-get_available_gas.html">get_available_gas</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool_and_impl"><a class="header" href="#bool_and_impl">bool_and_impl</a></h1>
<p>Fully qualified path: <code>core::bool_and_impl</code></p>
<pre><code class="language-rust">extern fn bool_and_impl(lhs: bool, rhs: bool) -&gt; (bool,) implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool_or_impl"><a class="header" href="#bool_or_impl">bool_or_impl</a></h1>
<p>Fully qualified path: <code>core::bool_or_impl</code></p>
<pre><code class="language-rust">extern fn bool_or_impl(lhs: bool, rhs: bool) -&gt; (bool,) implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool_not_impl"><a class="header" href="#bool_not_impl">bool_not_impl</a></h1>
<p>Fully qualified path: <code>core::bool_not_impl</code></p>
<pre><code class="language-rust">extern fn bool_not_impl(a: bool) -&gt; (bool,) implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool_xor_impl"><a class="header" href="#bool_xor_impl">bool_xor_impl</a></h1>
<p>Fully qualified path: <code>core::bool_xor_impl</code></p>
<pre><code class="language-rust">extern fn bool_xor_impl(lhs: bool, rhs: bool) -&gt; (bool,) implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool_to_felt252"><a class="header" href="#bool_to_felt252">bool_to_felt252</a></h1>
<p>Fully qualified path: <code>core::bool_to_felt252</code></p>
<pre><code class="language-rust">extern fn bool_to_felt252(a: bool) -&gt; felt252 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252_const"><a class="header" href="#felt252_const">felt252_const</a></h1>
<p>Fully qualified path: <code>core::felt252_const</code></p>
<pre><code class="language-rust">extern fn felt252_const&lt;const value: felt252&gt;() -&gt; felt252 nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252_add"><a class="header" href="#felt252_add">felt252_add</a></h1>
<p>Fully qualified path: <code>core::felt252_add</code></p>
<pre><code class="language-rust">extern fn felt252_add(lhs: felt252, rhs: felt252) -&gt; felt252 nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252_sub"><a class="header" href="#felt252_sub">felt252_sub</a></h1>
<p>Fully qualified path: <code>core::felt252_sub</code></p>
<pre><code class="language-rust">extern fn felt252_sub(lhs: felt252, rhs: felt252) -&gt; felt252 nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252_mul"><a class="header" href="#felt252_mul">felt252_mul</a></h1>
<p>Fully qualified path: <code>core::felt252_mul</code></p>
<pre><code class="language-rust">extern fn felt252_mul(lhs: felt252, rhs: felt252) -&gt; felt252 nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252_div"><a class="header" href="#felt252_div">felt252_div</a></h1>
<p>Fully qualified path: <code>core::felt252_div</code></p>
<pre><code class="language-rust">pub extern fn felt252_div(lhs: felt252, rhs: NonZero&lt;felt252&gt;) -&gt; felt252 nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252_is_zero"><a class="header" href="#felt252_is_zero">felt252_is_zero</a></h1>
<p>Fully qualified path: <code>core::felt252_is_zero</code></p>
<pre><code class="language-rust">extern fn felt252_is_zero(lhs: felt252) -&gt; zeroable::IsZeroResult&lt;felt252&gt; nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dup"><a class="header" href="#dup">dup</a></h1>
<p>Fully qualified path: <code>core::dup</code></p>
<pre><code class="language-rust">extern fn dup&lt;T&gt;(obj: T) -&gt; (T, T) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop-1"><a class="header" href="#drop-1">drop</a></h1>
<p>Fully qualified path: <code>core::drop</code></p>
<pre><code class="language-rust">extern fn drop&lt;T&gt;(obj: T) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-1"><a class="header" href="#null-1">null</a></h1>
<p>Fully qualified path: <code>core::nullable::null</code></p>
<pre><code class="language-rust">pub extern fn null&lt;T&gt;() -&gt; Nullable&lt;T&gt; nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullable_from_box"><a class="header" href="#nullable_from_box">nullable_from_box</a></h1>
<p>Fully qualified path: <code>core::nullable::nullable_from_box</code></p>
<pre><code class="language-rust">pub(crate) extern fn nullable_from_box&lt;T&gt;(value: Box&lt;T&gt;) -&gt; Nullable&lt;T&gt; nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match_nullable"><a class="header" href="#match_nullable">match_nullable</a></h1>
<p>Fully qualified path: <code>core::nullable::match_nullable</code></p>
<pre><code class="language-rust">pub extern fn match_nullable&lt;T&gt;(value: Nullable&lt;T&gt;) -&gt; FromNullableResult&lt;T&gt; nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array_snapshot_pop_front"><a class="header" href="#array_snapshot_pop_front">array_snapshot_pop_front</a></h1>
<p>Fully qualified path: <code>core::array::array_snapshot_pop_front</code></p>
<pre><code class="language-rust">pub(crate) extern fn array_snapshot_pop_front&lt;T&gt;(ref arr: @Array&lt;T&gt;) -&gt; Option&lt;Box&lt;@T&gt;&gt; nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252_dict_new"><a class="header" href="#felt252_dict_new">felt252_dict_new</a></h1>
<p>Fully qualified path: <code>core::dict::felt252_dict_new</code></p>
<pre><code class="language-rust">pub(crate) extern fn felt252_dict_new&lt;T&gt;() -&gt; Felt252Dict&lt;T&gt; implicits(SegmentArena) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252_dict_squash"><a class="header" href="#felt252_dict_squash">felt252_dict_squash</a></h1>
<p>Fully qualified path: <code>core::dict::felt252_dict_squash</code></p>
<pre><code class="language-rust">pub(crate) extern fn felt252_dict_squash&lt;T&gt;(
    dict: Felt252Dict&lt;T&gt;,
) -&gt; SquashedFelt252Dict&lt;T&gt; implicits(RangeCheck, GasBuiltin, SegmentArena) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec_point_unwrap"><a class="header" href="#ec_point_unwrap">ec_point_unwrap</a></h1>
<p>Unwraps a non-zero point into its (x, y) coordinates.</p>
<p>Fully qualified path: <code>core::ec::ec_point_unwrap</code></p>
<pre><code class="language-rust">pub extern fn ec_point_unwrap(p: NonZeroEcPoint) -&gt; (felt252, felt252) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_to_felt252"><a class="header" href="#u128_to_felt252">u128_to_felt252</a></h1>
<p>Fully qualified path: <code>core::integer::u128_to_felt252</code></p>
<pre><code class="language-rust">pub(crate) extern fn u128_to_felt252(a: u128) -&gt; felt252 nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_overflowing_add"><a class="header" href="#u128_overflowing_add">u128_overflowing_add</a></h1>
<p>Fully qualified path: <code>core::integer::u128_overflowing_add</code></p>
<pre><code class="language-rust">pub extern fn u128_overflowing_add(
    lhs: u128, rhs: u128,
) -&gt; Result&lt;u128, u128&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_overflowing_sub"><a class="header" href="#u128_overflowing_sub">u128_overflowing_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u128_overflowing_sub</code></p>
<pre><code class="language-rust">pub extern fn u128_overflowing_sub(
    lhs: u128, rhs: u128,
) -&gt; Result&lt;u128, u128&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_sqrt"><a class="header" href="#u128_sqrt">u128_sqrt</a></h1>
<p>Fully qualified path: <code>core::integer::u128_sqrt</code></p>
<pre><code class="language-rust">pub extern fn u128_sqrt(value: u128) -&gt; u64 implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_safe_divmod"><a class="header" href="#u128_safe_divmod">u128_safe_divmod</a></h1>
<p>Fully qualified path: <code>core::integer::u128_safe_divmod</code></p>
<pre><code class="language-rust">pub extern fn u128_safe_divmod(
    lhs: u128, rhs: NonZero&lt;u128&gt;,
) -&gt; (u128, u128) implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_is_zero"><a class="header" href="#u128_is_zero">u128_is_zero</a></h1>
<p>Fully qualified path: <code>core::integer::u128_is_zero</code></p>
<pre><code class="language-rust">pub(crate) extern fn u128_is_zero(a: u128) -&gt; IsZeroResult&lt;u128&gt; implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u128_byte_reverse"><a class="header" href="#u128_byte_reverse">u128_byte_reverse</a></h1>
<p>Fully qualified path: <code>core::integer::u128_byte_reverse</code></p>
<pre><code class="language-rust">pub extern fn u128_byte_reverse(input: u128) -&gt; u128 implicits(Bitwise) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_overflowing_add"><a class="header" href="#u8_overflowing_add">u8_overflowing_add</a></h1>
<p>Fully qualified path: <code>core::integer::u8_overflowing_add</code></p>
<pre><code class="language-rust">pub extern fn u8_overflowing_add(lhs: u8, rhs: u8) -&gt; Result&lt;u8, u8&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_overflowing_sub"><a class="header" href="#u8_overflowing_sub">u8_overflowing_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u8_overflowing_sub</code></p>
<pre><code class="language-rust">pub extern fn u8_overflowing_sub(lhs: u8, rhs: u8) -&gt; Result&lt;u8, u8&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_wide_mul"><a class="header" href="#u8_wide_mul">u8_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u8_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn u8_wide_mul(lhs: u8, rhs: u8) -&gt; u16 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_sqrt"><a class="header" href="#u8_sqrt">u8_sqrt</a></h1>
<p>Fully qualified path: <code>core::integer::u8_sqrt</code></p>
<pre><code class="language-rust">pub extern fn u8_sqrt(value: u8) -&gt; u8 implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u8_safe_divmod"><a class="header" href="#u8_safe_divmod">u8_safe_divmod</a></h1>
<p>Fully qualified path: <code>core::integer::u8_safe_divmod</code></p>
<pre><code class="language-rust">pub extern fn u8_safe_divmod(lhs: u8, rhs: NonZero&lt;u8&gt;) -&gt; (u8, u8) implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_overflowing_add"><a class="header" href="#u16_overflowing_add">u16_overflowing_add</a></h1>
<p>Fully qualified path: <code>core::integer::u16_overflowing_add</code></p>
<pre><code class="language-rust">pub extern fn u16_overflowing_add(
    lhs: u16, rhs: u16,
) -&gt; Result&lt;u16, u16&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_overflowing_sub"><a class="header" href="#u16_overflowing_sub">u16_overflowing_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u16_overflowing_sub</code></p>
<pre><code class="language-rust">pub extern fn u16_overflowing_sub(
    lhs: u16, rhs: u16,
) -&gt; Result&lt;u16, u16&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_wide_mul"><a class="header" href="#u16_wide_mul">u16_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u16_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn u16_wide_mul(lhs: u16, rhs: u16) -&gt; u32 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_sqrt"><a class="header" href="#u16_sqrt">u16_sqrt</a></h1>
<p>Fully qualified path: <code>core::integer::u16_sqrt</code></p>
<pre><code class="language-rust">pub extern fn u16_sqrt(value: u16) -&gt; u8 implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u16_safe_divmod"><a class="header" href="#u16_safe_divmod">u16_safe_divmod</a></h1>
<p>Fully qualified path: <code>core::integer::u16_safe_divmod</code></p>
<pre><code class="language-rust">pub extern fn u16_safe_divmod(
    lhs: u16, rhs: NonZero&lt;u16&gt;,
) -&gt; (u16, u16) implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_overflowing_add"><a class="header" href="#u32_overflowing_add">u32_overflowing_add</a></h1>
<p>Fully qualified path: <code>core::integer::u32_overflowing_add</code></p>
<pre><code class="language-rust">pub extern fn u32_overflowing_add(
    lhs: u32, rhs: u32,
) -&gt; Result&lt;u32, u32&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_overflowing_sub"><a class="header" href="#u32_overflowing_sub">u32_overflowing_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u32_overflowing_sub</code></p>
<pre><code class="language-rust">pub extern fn u32_overflowing_sub(
    lhs: u32, rhs: u32,
) -&gt; Result&lt;u32, u32&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_wide_mul"><a class="header" href="#u32_wide_mul">u32_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u32_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn u32_wide_mul(lhs: u32, rhs: u32) -&gt; u64 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_sqrt"><a class="header" href="#u32_sqrt">u32_sqrt</a></h1>
<p>Fully qualified path: <code>core::integer::u32_sqrt</code></p>
<pre><code class="language-rust">pub extern fn u32_sqrt(value: u32) -&gt; u16 implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u32_safe_divmod"><a class="header" href="#u32_safe_divmod">u32_safe_divmod</a></h1>
<p>Fully qualified path: <code>core::integer::u32_safe_divmod</code></p>
<pre><code class="language-rust">pub extern fn u32_safe_divmod(
    lhs: u32, rhs: NonZero&lt;u32&gt;,
) -&gt; (u32, u32) implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_overflowing_add"><a class="header" href="#u64_overflowing_add">u64_overflowing_add</a></h1>
<p>Fully qualified path: <code>core::integer::u64_overflowing_add</code></p>
<pre><code class="language-rust">pub extern fn u64_overflowing_add(
    lhs: u64, rhs: u64,
) -&gt; Result&lt;u64, u64&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_overflowing_sub"><a class="header" href="#u64_overflowing_sub">u64_overflowing_sub</a></h1>
<p>Fully qualified path: <code>core::integer::u64_overflowing_sub</code></p>
<pre><code class="language-rust">pub extern fn u64_overflowing_sub(
    lhs: u64, rhs: u64,
) -&gt; Result&lt;u64, u64&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_wide_mul"><a class="header" href="#u64_wide_mul">u64_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::u64_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn u64_wide_mul(lhs: u64, rhs: u64) -&gt; u128 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_sqrt"><a class="header" href="#u64_sqrt">u64_sqrt</a></h1>
<p>Fully qualified path: <code>core::integer::u64_sqrt</code></p>
<pre><code class="language-rust">pub extern fn u64_sqrt(value: u64) -&gt; u32 implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u64_safe_divmod"><a class="header" href="#u64_safe_divmod">u64_safe_divmod</a></h1>
<p>Fully qualified path: <code>core::integer::u64_safe_divmod</code></p>
<pre><code class="language-rust">pub extern fn u64_safe_divmod(
    lhs: u64, rhs: NonZero&lt;u64&gt;,
) -&gt; (u64, u64) implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="u256_sqrt"><a class="header" href="#u256_sqrt">u256_sqrt</a></h1>
<p>Fully qualified path: <code>core::integer::u256_sqrt</code></p>
<pre><code class="language-rust">pub extern fn u256_sqrt(a: u256) -&gt; u128 implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upcast"><a class="header" href="#upcast">upcast</a></h1>
<p>Fully qualified path: <code>core::integer::upcast</code></p>
<pre><code class="language-rust">pub(crate) extern fn upcast&lt;FromType, ToType&gt;(x: FromType) -&gt; ToType nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="downcast"><a class="header" href="#downcast">downcast</a></h1>
<p>Fully qualified path: <code>core::integer::downcast</code></p>
<pre><code class="language-rust">pub(crate) extern fn downcast&lt;FromType, ToType&gt;(
    x: FromType,
) -&gt; Option&lt;ToType&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i8_wide_mul"><a class="header" href="#i8_wide_mul">i8_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::i8_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn i8_wide_mul(lhs: i8, rhs: i8) -&gt; i16 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i8_diff"><a class="header" href="#i8_diff">i8_diff</a></h1>
<p>If <code>lhs</code> &gt;= <code>rhs</code> returns <code>Ok(lhs - rhs)</code> else returns <code>Err(2**8 + lhs - rhs)</code>.</p>
<p>Fully qualified path: <code>core::integer::i8_diff</code></p>
<pre><code class="language-rust">pub extern fn i8_diff(lhs: i8, rhs: i8) -&gt; Result&lt;u8, u8&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i16_wide_mul"><a class="header" href="#i16_wide_mul">i16_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::i16_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn i16_wide_mul(lhs: i16, rhs: i16) -&gt; i32 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i16_diff"><a class="header" href="#i16_diff">i16_diff</a></h1>
<p>If <code>lhs</code> &gt;= <code>rhs</code> returns <code>Ok(lhs - rhs)</code> else returns <code>Err(2**16 + lhs - rhs)</code>.</p>
<p>Fully qualified path: <code>core::integer::i16_diff</code></p>
<pre><code class="language-rust">pub extern fn i16_diff(lhs: i16, rhs: i16) -&gt; Result&lt;u16, u16&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i32_wide_mul"><a class="header" href="#i32_wide_mul">i32_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::i32_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn i32_wide_mul(lhs: i32, rhs: i32) -&gt; i64 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i32_diff"><a class="header" href="#i32_diff">i32_diff</a></h1>
<p>If <code>lhs</code> &gt;= <code>rhs</code> returns <code>Ok(lhs - rhs)</code> else returns <code>Err(2**32 + lhs - rhs)</code>.</p>
<p>Fully qualified path: <code>core::integer::i32_diff</code></p>
<pre><code class="language-rust">pub extern fn i32_diff(lhs: i32, rhs: i32) -&gt; Result&lt;u32, u32&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i64_wide_mul"><a class="header" href="#i64_wide_mul">i64_wide_mul</a></h1>
<p>Fully qualified path: <code>core::integer::i64_wide_mul</code></p>
<pre><code class="language-rust">pub extern fn i64_wide_mul(lhs: i64, rhs: i64) -&gt; i128 implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i64_diff"><a class="header" href="#i64_diff">i64_diff</a></h1>
<p>If <code>lhs</code> &gt;= <code>rhs</code> returns <code>Ok(lhs - rhs)</code> else returns <code>Err(2**64 + lhs - rhs)</code>.</p>
<p>Fully qualified path: <code>core::integer::i64_diff</code></p>
<pre><code class="language-rust">pub extern fn i64_diff(lhs: i64, rhs: i64) -&gt; Result&lt;u64, u64&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i128_diff"><a class="header" href="#i128_diff">i128_diff</a></h1>
<p>If <code>lhs</code> &gt;= <code>rhs</code> returns <code>Ok(lhs - rhs)</code> else returns <code>Err(2**128 + lhs - rhs)</code>.</p>
<p>Fully qualified path: <code>core::integer::i128_diff</code></p>
<pre><code class="language-rust">pub extern fn i128_diff(lhs: i128, rhs: i128) -&gt; Result&lt;u128, u128&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="withdraw_gas"><a class="header" href="#withdraw_gas">withdraw_gas</a></h1>
<p>Withdraws gas from the <code>GasBuiltin</code> to handle the success case flow. Returns <code>Option::Some(())</code> if there is sufficient gas to handle the success case, otherwise returns <code>Option::None</code>.  Example:</p>
<pre><code class="language-cairo">// The success branch is the following lines, the failure branch is the `panic` caused by the
// `unwrap` call.
withdraw_gas().unwrap();

// Direct handling of `withdraw_gas`.
match withdraw_gas() {
    Option::Some(()) =&gt; success_case(),
    Option::None =&gt; cheap_not_enough_gas_case(),
}
</code></pre>
<p>Fully qualified path: <code>core::gas::withdraw_gas</code></p>
<pre><code class="language-rust">pub extern fn withdraw_gas() -&gt; Option&lt;()&gt; implicits(RangeCheck, GasBuiltin) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="withdraw_gas_all"><a class="header" href="#withdraw_gas_all">withdraw_gas_all</a></h1>
<p>Same as <code>withdraw_gas</code>, but directly receives <code>BuiltinCosts</code>, which enables optimizations by removing the need for repeated internal calls for fetching the table of consts that may internally happen in calls to <code>withdraw_gas</code>. Should be used with caution.</p>
<p>Fully qualified path: <code>core::gas::withdraw_gas_all</code></p>
<pre><code class="language-rust">pub extern fn withdraw_gas_all(
    costs: BuiltinCosts,
) -&gt; Option&lt;()&gt; implicits(RangeCheck, GasBuiltin) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redeposit_gas"><a class="header" href="#redeposit_gas">redeposit_gas</a></h1>
<p>Returns unused gas into the gas builtin.  Useful for cases where different branches take different amounts of gas, but gas withdrawal is the same for both.</p>
<p>Fully qualified path: <code>core::gas::redeposit_gas</code></p>
<pre><code class="language-rust">pub extern fn redeposit_gas() implicits(GasBuiltin) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_builtin_costs"><a class="header" href="#get_builtin_costs">get_builtin_costs</a></h1>
<p>Returns the <code>BuiltinCosts</code> table to be used in <code>withdraw_gas_all</code>.</p>
<p>Fully qualified path: <code>core::gas::get_builtin_costs</code></p>
<pre><code class="language-rust">pub extern fn get_builtin_costs() -&gt; BuiltinCosts nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic-1"><a class="header" href="#panic-1">panic</a></h1>
<p>Triggers an immediate panic with the provided data and terminates execution.  # Examples</p>
<pre><code class="language-cairo">use core::panics::panic;

panic(array!['An error occurred']);
</code></pre>
<p>Fully qualified path: <code>core::panics::panic</code></p>
<pre><code class="language-rust">pub extern fn panic(data: Array&lt;felt252&gt;) -&gt; crate::never;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedersen-2"><a class="header" href="#pedersen-2">pedersen</a></h1>
<p>Fully qualified path: <code>core::pedersen::pedersen</code></p>
<pre><code class="language-rust">pub extern fn pedersen(a: felt252, b: felt252) -&gt; felt252 implicits(Pedersen) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hades_permutation"><a class="header" href="#hades_permutation">hades_permutation</a></h1>
<p>Fully qualified path: <code>core::poseidon::hades_permutation</code></p>
<pre><code class="language-rust">pub extern fn hades_permutation(
    s0: felt252, s1: felt252, s2: felt252,
) -&gt; (felt252, felt252, felt252) implicits(Poseidon) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="print-17"><a class="header" href="#print-17">print</a></h1>
<p>Fully qualified path: <code>core::debug::print</code></p>
<pre><code class="language-rust">pub(crate) extern fn print(message: Array&lt;felt252&gt;) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract_address_const"><a class="header" href="#contract_address_const">contract_address_const</a></h1>
<p>Fully qualified path: <code>core::starknet::contract_address::contract_address_const</code></p>
<pre><code class="language-rust">pub extern fn contract_address_const&lt;const address: felt252&gt;() -&gt; ContractAddress nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_base_address_const"><a class="header" href="#storage_base_address_const">storage_base_address_const</a></h1>
<p>Fully qualified path: <code>core::starknet::storage_access::storage_base_address_const</code></p>
<pre><code class="language-rust">pub extern fn storage_base_address_const&lt;const address: felt252&gt;() -&gt; StorageBaseAddress nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_base_address_from_felt252"><a class="header" href="#storage_base_address_from_felt252">storage_base_address_from_felt252</a></h1>
<p>Fully qualified path: <code>core::starknet::storage_access::storage_base_address_from_felt252</code></p>
<pre><code class="language-rust">pub extern fn storage_base_address_from_felt252(
    addr: felt252,
) -&gt; StorageBaseAddress implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_address_to_felt252"><a class="header" href="#storage_address_to_felt252">storage_address_to_felt252</a></h1>
<p>Fully qualified path: <code>core::starknet::storage_access::storage_address_to_felt252</code></p>
<pre><code class="language-rust">pub(crate) extern fn storage_address_to_felt252(address: StorageAddress) -&gt; felt252 nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_address_from_base_and_offset"><a class="header" href="#storage_address_from_base_and_offset">storage_address_from_base_and_offset</a></h1>
<p>Fully qualified path: <code>core::starknet::storage_access::storage_address_from_base_and_offset</code></p>
<pre><code class="language-rust">pub extern fn storage_address_from_base_and_offset(
    base: StorageBaseAddress, offset: u8,
) -&gt; StorageAddress nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_address_from_base"><a class="header" href="#storage_address_from_base">storage_address_from_base</a></h1>
<p>Fully qualified path: <code>core::starknet::storage_access::storage_address_from_base</code></p>
<pre><code class="language-rust">pub extern fn storage_address_from_base(base: StorageBaseAddress) -&gt; StorageAddress nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_address_try_from_felt252"><a class="header" href="#storage_address_try_from_felt252">storage_address_try_from_felt252</a></h1>
<p>Fully qualified path: <code>core::starknet::storage_access::storage_address_try_from_felt252</code></p>
<pre><code class="language-rust">pub(crate) extern fn storage_address_try_from_felt252(
    address: felt252,
) -&gt; Option&lt;StorageAddress&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="call_contract_syscall"><a class="header" href="#call_contract_syscall">call_contract_syscall</a></h1>
<p>Calls a given contract. <code>address</code> - The address of the called contract. <code>entry_point_selector</code> - A selector for a function within that contract. <code>calldata</code> - Call arguments.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::call_contract_syscall</code></p>
<pre><code class="language-rust">pub extern fn call_contract_syscall(
    address: ContractAddress, entry_point_selector: felt252, calldata: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;Span&lt;felt252&gt;&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploy_syscall"><a class="header" href="#deploy_syscall">deploy_syscall</a></h1>
<p>Deploys a new instance of a previously declared class. <code>class_hash</code> - The class hash of the contract to be deployed. <code>contract_address_salt</code> - The salt, an arbitrary value provided by the sender, used in thecomputation of the contract's address.
<code>calldata</code> - Call arguments for the constructor.<code>deploy_from_zero</code> - Deploy the contract from the zero address.Returns the address of the deployed contract and the serialized return value of the constructor.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::deploy_syscall</code></p>
<pre><code class="language-rust">pub extern fn deploy_syscall(
    class_hash: ClassHash,
    contract_address_salt: felt252,
    calldata: Span&lt;felt252&gt;,
    deploy_from_zero: bool,
) -&gt; SyscallResult&lt;(ContractAddress, Span&lt;felt252&gt;)&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="emit_event_syscall"><a class="header" href="#emit_event_syscall">emit_event_syscall</a></h1>
<p>Emits an event. <code>keys</code> - The keys of the event. <code>data</code> - The data of the event.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::emit_event_syscall</code></p>
<pre><code class="language-rust">pub extern fn emit_event_syscall(
    keys: Span&lt;felt252&gt;, data: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_block_hash_syscall"><a class="header" href="#get_block_hash_syscall">get_block_hash_syscall</a></h1>
<p>Gets the block hash of the block with the given number.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::get_block_hash_syscall</code></p>
<pre><code class="language-rust">pub extern fn get_block_hash_syscall(
    block_number: u64,
) -&gt; SyscallResult&lt;felt252&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_execution_info_syscall"><a class="header" href="#get_execution_info_syscall">get_execution_info_syscall</a></h1>
<p>Gets information about the current execution.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::get_execution_info_syscall</code></p>
<pre><code class="language-rust">pub extern fn get_execution_info_syscall() -&gt; SyscallResult&lt;
    Box&lt;starknet::info::ExecutionInfo&gt;,
&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_execution_info_v2_syscall"><a class="header" href="#get_execution_info_v2_syscall">get_execution_info_v2_syscall</a></h1>
<p>Gets information about the current execution, version 2.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::get_execution_info_v2_syscall</code></p>
<pre><code class="language-rust">pub extern fn get_execution_info_v2_syscall() -&gt; SyscallResult&lt;
    Box&lt;starknet::info::v2::ExecutionInfo&gt;,
&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library_call_syscall"><a class="header" href="#library_call_syscall">library_call_syscall</a></h1>
<p>Calls the requested function in any previously declared class. <code>class_hash</code> - The hash of the class you want to use. <code>function_selector</code> - A selector for a function within that class. <code>calldata</code> - Call arguments.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::library_call_syscall</code></p>
<pre><code class="language-rust">pub extern fn library_call_syscall(
    class_hash: ClassHash, function_selector: felt252, calldata: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;Span&lt;felt252&gt;&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send_message_to_l1_syscall"><a class="header" href="#send_message_to_l1_syscall">send_message_to_l1_syscall</a></h1>
<p>Sends a message to L1. <code>to_address</code> - The recipient's L1 address. <code>payload</code> - The content of the message.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::send_message_to_l1_syscall</code></p>
<pre><code class="language-rust">pub extern fn send_message_to_l1_syscall(
    to_address: felt252, payload: Span&lt;felt252&gt;,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_read_syscall"><a class="header" href="#storage_read_syscall">storage_read_syscall</a></h1>
<p>Gets the value of a key in the storage of the calling contract. <code>address_domain</code> - The domain of the address. Only address_domain 0 is currently supported,in the future it will enable access to address spaces with different data availability
guarantees.
<code>address</code> - The address of the storage key to read.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::storage_read_syscall</code></p>
<pre><code class="language-rust">pub extern fn storage_read_syscall(
    address_domain: u32, address: StorageAddress,
) -&gt; SyscallResult&lt;felt252&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage_write_syscall"><a class="header" href="#storage_write_syscall">storage_write_syscall</a></h1>
<p>Sets the value of a key in the storage of the calling contract. <code>address_domain</code> - The domain of the address. Only address_domain 0 is currently supported,in the future it will enable access to address spaces with different data availability
guarantees.
<code>address</code> - The address of the storage key to write.<code>value</code> - The value to write to the key.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::storage_write_syscall</code></p>
<pre><code class="language-rust">pub extern fn storage_write_syscall(
    address_domain: u32, address: StorageAddress, value: felt252,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="replace_class_syscall"><a class="header" href="#replace_class_syscall">replace_class_syscall</a></h1>
<p>Replaces the class hash of the current contract. <code>class_hash</code> - The class hash that should replace the current one.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::replace_class_syscall</code></p>
<pre><code class="language-rust">pub extern fn replace_class_syscall(
    class_hash: ClassHash,
) -&gt; SyscallResult&lt;()&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_class_hash_at_syscall"><a class="header" href="#get_class_hash_at_syscall">get_class_hash_at_syscall</a></h1>
<p>Gets the class hash of the contract at the given address. <code>contract_address</code> - The address of the deployed contract.  Returns the class hash of the contract's originating code.</p>
<p>Fully qualified path: <code>core::starknet::syscalls::get_class_hash_at_syscall</code></p>
<pre><code class="language-rust">pub extern fn get_class_hash_at_syscall(
    contract_address: ContractAddress,
) -&gt; SyscallResult&lt;ClassHash&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keccak_syscall"><a class="header" href="#keccak_syscall">keccak_syscall</a></h1>
<p>Computes the keccak of the input. The system call does not add any padding and the input needs to be a multiple of 1088 bits (== 17 u64 word).</p>
<p>Fully qualified path: <code>core::starknet::syscalls::keccak_syscall</code></p>
<pre><code class="language-rust">pub extern fn keccak_syscall(
    input: Span&lt;u64&gt;,
) -&gt; SyscallResult&lt;u256&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha256_process_block_syscall"><a class="header" href="#sha256_process_block_syscall">sha256_process_block_syscall</a></h1>
<p>Computes the next sha256 state of the input with the given state. The system call does not add any padding and the input needs to be a multiple of 512 bits (== 16 u32 word).</p>
<p>Fully qualified path: <code>core::starknet::syscalls::sha256_process_block_syscall</code></p>
<pre><code class="language-rust">pub extern fn sha256_process_block_syscall(
    state: core::sha256::Sha256StateHandle, input: Box&lt;[u32; 16]&gt;,
) -&gt; SyscallResult&lt;core::sha256::Sha256StateHandle&gt; implicits(GasBuiltin, System) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract_address_const-1"><a class="header" href="#contract_address_const-1">contract_address_const</a></h1>
<p>Fully qualified path: <code>core::starknet::contract_address::contract_address_const</code></p>
<pre><code class="language-rust">pub extern fn contract_address_const&lt;const address: felt252&gt;() -&gt; ContractAddress nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract_address_to_felt252"><a class="header" href="#contract_address_to_felt252">contract_address_to_felt252</a></h1>
<p>Fully qualified path: <code>core::starknet::contract_address::contract_address_to_felt252</code></p>
<pre><code class="language-rust">pub(crate) extern fn contract_address_to_felt252(address: ContractAddress) -&gt; felt252 nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract_address_try_from_felt252"><a class="header" href="#contract_address_try_from_felt252">contract_address_try_from_felt252</a></h1>
<p>Fully qualified path: <code>core::starknet::contract_address::contract_address_try_from_felt252</code></p>
<pre><code class="language-rust">pub(crate) extern fn contract_address_try_from_felt252(
    address: felt252,
) -&gt; Option&lt;ContractAddress&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class_hash_const"><a class="header" href="#class_hash_const">class_hash_const</a></h1>
<p>Fully qualified path: <code>core::starknet::class_hash::class_hash_const</code></p>
<pre><code class="language-rust">pub extern fn class_hash_const&lt;const address: felt252&gt;() -&gt; ClassHash nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class_hash_to_felt252"><a class="header" href="#class_hash_to_felt252">class_hash_to_felt252</a></h1>
<p>Fully qualified path: <code>core::starknet::class_hash::class_hash_to_felt252</code></p>
<pre><code class="language-rust">pub(crate) extern fn class_hash_to_felt252(address: ClassHash) -&gt; felt252 nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class_hash_try_from_felt252"><a class="header" href="#class_hash_try_from_felt252">class_hash_try_from_felt252</a></h1>
<p>Fully qualified path: <code>core::starknet::class_hash::class_hash_try_from_felt252</code></p>
<pre><code class="language-rust">pub(crate) extern fn class_hash_try_from_felt252(
    address: felt252,
) -&gt; Option&lt;ClassHash&gt; implicits(RangeCheck) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cheatcode"><a class="header" href="#cheatcode">cheatcode</a></h1>
<p>A general cheatcode function used to simplify implementation of Starknet testing functions.  This is the base function used by testing utilities to interact with the test environment. External users can implement custom cheatcodes by injecting a custom <code>CairoHintProcessor</code> in the runner.  # Arguments  <code>selector</code> - The cheatcode identifier. <code>input</code> - Input parameters for the cheatcode.  # Returns  * A span containing the cheatcode's output</p>
<p>Fully qualified path: <code>core::starknet::testing::cheatcode</code></p>
<pre><code class="language-rust">pub extern fn cheatcode&lt;const selector: felt252&gt;(
    input: Span&lt;felt252&gt;,
) -&gt; Span&lt;felt252&gt; implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revoke_ap_tracking"><a class="header" href="#revoke_ap_tracking">revoke_ap_tracking</a></h1>
<p>Fully qualified path: <code>core::internal::revoke_ap_tracking</code></p>
<pre><code class="language-rust">pub extern fn revoke_ap_tracking() implicits() nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="require_implicit"><a class="header" href="#require_implicit">require_implicit</a></h1>
<p>Function to enforce that <code>Implicit</code> is used by a function calling it. Note: This extern function is not mapped to a Sierra function, and all usages of it are removed during compilation.</p>
<p>Fully qualified path: <code>core::internal::require_implicit</code></p>
<pre><code class="language-rust">pub extern fn require_implicit&lt;Implicit&gt;() implicits(Implicit) nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes31_const"><a class="header" href="#bytes31_const">bytes31_const</a></h1>
<p>Fully qualified path: <code>core::bytes_31::bytes31_const</code></p>
<pre><code class="language-rust">pub(crate) extern fn bytes31_const&lt;const value: felt252&gt;() -&gt; bytes31 nopanic;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get_available_gas"><a class="header" href="#get_available_gas">get_available_gas</a></h1>
<p>Returns the amount of gas available in the <code>GasBuiltin</code>.  Useful for asserting that a certain amount of gas was consumed. Note: The actual gas consumption observed by calls to <code>get_available_gas</code> is only exact immediately before calls to <code>withdraw_gas</code>.  # Examples</p>
<pre><code class="language-cairo">use core::testing::get_available_gas;

fn gas_heavy_function() {
    // ... some gas-intensive code
}

fn test_gas_consumption() {
    let gas_before = get_available_gas();
    // Making sure `gas_before` is exact.
    core::gas::withdraw_gas().unwrap();

    gas_heavy_function();

    let gas_after = get_available_gas();
    // Making sure `gas_after` is exact
    core::gas::withdraw_gas().unwrap();

    assert!(gas_after - gas_before &lt; 100_000);
}
</code></pre>
<p>Fully qualified path: <code>core::testing::get_available_gas</code></p>
<pre><code class="language-rust">pub extern fn get_available_gas() -&gt; u128 implicits(GasBuiltin) nopanic;</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
